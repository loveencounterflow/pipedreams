{"version":3,"sources":["main.coffee"],"names":[],"mappings":"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","file":"main.js","sourceRoot":"/source/","sourcesContent":["\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'PIPEDREAMS2'\nlog                       = CND.get_logger 'plain',     badge\ninfo                      = CND.get_logger 'info',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\nalert                     = CND.get_logger 'alert',     badge\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\n### https://github.com/dominictarr/event-stream ###\nES                        = @_ES = require 'event-stream'\n#...........................................................................................................\n### https://github.com/dominictarr/sort-stream ###\n@$sort                    = require 'sort-stream'\n#...........................................................................................................\n### https://github.com/dominictarr/stream-combiner ###\ncombine                   = require 'stream-combiner'\n#...........................................................................................................\n@new_densort              = ( DS = require './densort' ).new_densort.bind DS\nPIPEDREAMS                = @\nLODASH                    = CND.LODASH\n#...........................................................................................................\n### http://stringjs.com ###\nS                         = require 'string'\n\n\n\n#===========================================================================================================\n# GENERIC METHODS\n#-----------------------------------------------------------------------------------------------------------\n# @create_readstream            = HELPERS.create_readstream             .bind HELPERS\n# @create_readstream_from_text  = HELPERS.create_readstream_from_text   .bind HELPERS\n# @pimp_readstream              = HELPERS.pimp_readstream               .bind HELPERS\n# @merge                        = ES.merge                              .bind ES\n@$split                       = ES.split                              .bind ES\n$map                          = ES.map                                .bind ES\n# @$chain                       = ES.pipeline                           .bind ES\n# @through                      = ES.through                            .bind ES\n# @duplex                       = ES.duplex                             .bind ES\n# @as_readable                  = ES.readable                           .bind ES\n# @read_list                    = ES.readArray                          .bind ES\n\n# #-----------------------------------------------------------------------------------------------------------\n# D.$map_plus = ( transform ) ->\n#   ### TAINT looks like `write` occurs too late or `end` too early ###\n#   ### Like `map`, but calls `transform` one more time (hence the name) with `undefined` in place of data\n#   just before the stream has ended; this gives the caller one more chance to send data. ###\n#   R = ES.map transform # ( data, handler ) -> transform data, handler\n#   _end = R.end.bind R\n#   R.end = ->\n#     transform undefined, ( error, data ) ->\n#       return R.error error if error?\n#       debug '©GbYu0', data\n#       R.write data if data?\n#       setImmediate _end\n#   return R\n\n\n#===========================================================================================================\n# REMIT\n#-----------------------------------------------------------------------------------------------------------\n@remit = ( method ) ->\n  send      = null\n  on_end    = null\n  #.........................................................................................................\n  get_send = ( self ) ->\n    R             = (  data ) -> self.emit 'data',  data # if data?\n    R.error       = ( error ) -> self.emit 'error', error\n    R.end         =           -> self.emit 'end'\n    R.pause       =           -> self.pause()\n    R.resume      =           -> self.resume()\n    R.read        =           -> self.read()\n    # R[ '%self' ]  = self\n    R.stream      = self\n    return R\n  #.....................................................................................................\n  on_data = ( data ) ->\n    send = get_send @ unless send?\n    method data, send\n  #.........................................................................................................\n  switch arity = method.length\n    when 2\n      null\n    #.......................................................................................................\n    when 3\n      on_end = ->\n        send  = get_send @ unless send?\n        end   = => @emit 'end'\n        method undefined, send, end\n    #.......................................................................................................\n    else\n      throw new Error \"expected a method with an arity of 2 or 3, got one with an arity of #{arity}\"\n  #.........................................................................................................\n  return ES.through on_data, on_end\n\n#-----------------------------------------------------------------------------------------------------------\n@remit_async = ( method ) ->\n  unless ( arity = method.length ) is 2\n    throw new Error \"expected a method with an arity of 2, got one with an arity of #{arity}\"\n  return $map ( input_data, handler ) =>\n    ### TAINT should add `done.end`, `done.pause` and so on ###\n    done        = ( output_data ) => if output_data? then handler null, output_data else handler()\n    done.error  = ( error )       => handler error\n    method input_data, done\n\n#-----------------------------------------------------------------------------------------------------------\n$       = @remit.bind @\n$async  = @remit_async.bind @\n\n\n#===========================================================================================================\n# COMBINING STREAM TRANSFORMS\n#-----------------------------------------------------------------------------------------------------------\n@combine = ( transforms... ) ->\n  return combine transforms...\n\n\n#===========================================================================================================\n# EXPERIMENTAL: STREAM LINKING, CONCATENATING\n#-----------------------------------------------------------------------------------------------------------\n@$continue = ( stream ) ->\n  return $ ( data, send, end ) =>\n    stream.write data\n    if end?\n      stream.end()\n      end()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @$link = ( transforms... ) ->\n#   return @create_throughstream() if transforms.length is 0\n#   source  = sink = @create_throughstream()\n#   sink    = sink.pipe transform for transform in LODASH.flatten transforms\n#   _send   = null\n#   sink.on 'data', ( data ) => _send data\n#   return $ ( data, send ) =>\n#     _send = send\n#     source.write data\n\n#-----------------------------------------------------------------------------------------------------------\n@create_fitting_from_pipeline = ( pipeline, settings ) ->\n  ### Given a pipeline (in the form of a list of `transforms`) and an optional `settings` object,\n  derive input, transformation and output from these givens and return a `PIPEDREAMS/fitting` object with\n  the following entries:\n\n  * `input`: the reading side of the pipeline; this will be `settings[ 'input' ]` where present, or else\n    a newly created throughstream;\n  * `output`: the writing side of the pipeline; either `settings[ 'output' ]` or a new stream;\n  * `inputs`: a copy of `settings[ 'inputs' ]` or a blank object;\n  * `outputs`: a copy of `settings[ 'outputs' ]` or a blank object.\n\n  The `inputs` and `outputs` members of the fitting are a mere convenience, a convention meant to aid\n  in mainting consistent APIs. The consumer of `create_fitting` is responsible to populate these entries\n  in a meaningful way. ###\n  unless ( type = CND.type_of pipeline ) is 'list'\n    throw new Error \"expected a list for pipeline, got a #{type}\"\n  confluence  = @combine pipeline...\n  return @_create_fitting_from_confluence confluence, settings ? {}\n\n#-----------------------------------------------------------------------------------------------------------\n@create_fitting_from_readwritestreams = ( readstream, writestream, settings ) ->\n  ### Same as `create_fitting_from_pipeline`, but accepts a `readstream` and a `writestream` (and an\n  optional `settings` object). `readstream` should somehow be connected to `writestream`, and the pair\n  should be suitable arguments to the [EventsStream `duplex`\n  method](https://github.com/dominictarr/event-stream#duplex-writestream-readstream). ###\n  confluence  = @_ES.duplex readstream, writestream\n  return @_create_fitting_from_confluence confluence, settings ? {}\n\n#-----------------------------------------------------------------------------------------------------------\n@_create_fitting_from_confluence = ( confluence, settings ) ->\n  input       = settings[ 'input'  ] ? @create_throughstream()\n  output      = settings[ 'output' ] ? @create_throughstream()\n  input\n    .pipe confluence\n    .pipe output\n  R =\n    '~isa':       'PIPEDREAMS/fitting'\n    input:        input\n    output:       output\n    inputs:       if settings[ 'inputs'  ]? then LODASH.clone settings[ 'inputs'  ] else {}\n    outputs:      if settings[ 'outputs' ]? then LODASH.clone settings[ 'outputs' ] else {}\n  return R\n\n\n#-----------------------------------------------------------------------------------------------------------\n@$lockstep = ( input, settings ) ->\n  ### Usage:\n\n  ```coffee\n  input_1\n    .pipe D.$lockstep input_2 # or `.pipe D.$lockstep input_2, fallback: null`\n    .pipe $ ( [ data_1, data_2, ], send ) =>\n      ...\n  ```\n\n  `$lockstep` combines each piece of data coming down the stream with one piece of data emitted from the\n  stream you passed in when calling the function. If the two streams turn out to have unequal lengths,\n  an error is sent into the stream unless you called the function with an additional `fallback: value`\n  argument.\n  ###\n  #.........................................................................................................\n  fallback  = settings?[ 'fallback' ]\n  idx_1     = 0\n  idx_2     = 0\n  buffer_1  = []\n  buffer_2  = []\n  _send     = null\n  _end_1    = null\n  _end_2    = null\n  #.........................................................................................................\n  flush = =>\n    #.......................................................................................................\n    if _send?\n      while ( buffer_1.length > 0 ) and ( buffer_2.length > 0 ) and idx_1 is idx_2\n        _send [ buffer_1.shift(), buffer_2.shift(), ]\n        idx_1 += +1\n        idx_2 += +1\n    #.......................................................................................................\n    if _end_1? and _end_2?\n      if ( buffer_1.length > 0 ) or ( buffer_2.length > 0 )\n        for idx in [ 0 ... Math.max buffer_1.length, buffer_2.length ]\n          data_1 = buffer_1[ idx ]\n          data_2 = buffer_2[ idx ]\n          if data_1 is undefined or data_2 is undefined\n            if fallback is undefined\n              return _send.error new Error \"streams of unequal lengths and no fallback value given\"\n            data_1 = fallback if data_1 is undefined\n            data_2 = fallback if data_2 is undefined\n          _send [ data_1, data_2, ]\n      _end_1()\n      _end_2()\n  #.........................................................................................................\n  input.on 'data', ( data_2 ) =>\n    buffer_2.push data_2\n    flush()\n  #.........................................................................................................\n  input.pipe @$on_end ( end ) =>\n    _end_2 = end\n    flush()\n  #.........................................................................................................\n  return $ ( data_1, send, end ) =>\n    _send   = send\n    #.......................................................................................................\n    if data_1?\n      buffer_1.push data_1\n      flush()\n    #.......................................................................................................\n    if end?\n      _end_1 = end\n      flush()\n\n\n#===========================================================================================================\n# OMITTING VALUES\n#-----------------------------------------------------------------------------------------------------------\n@$skip_first = ( n = 1 ) ->\n  count = 0\n  return $ ( data, send ) ->\n    count += +1\n    send data if count > n\n\n\n#===========================================================================================================\n# SPECIALIZED STREAMS\n#-----------------------------------------------------------------------------------------------------------\n@create_throughstream = ( P... ) ->\n  # R           = through2.obj P...\n  ### TAINT `end` events passed through synchronously even when `write` happens asynchronously ###\n  R           = ES.through P...\n  write       = R.write.bind R\n  end         = R.end.bind R\n  #.........................................................................................................\n  R.write = ( data, handler ) ->\n    if handler?\n      setImmediate ->\n        handler null, write data\n    else\n      return write data\n  #.........................................................................................................\n  R.end = ( handler ) ->\n    if handler?\n      setImmediate ->\n        handler null, end()\n    else\n      return end()\n  #.........................................................................................................\n  R.setMaxListeners 0\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@spawn_and_read = ( P... ) ->\n  readstream_from_spawn     = require 'spawn-to-readstream'\n  spawn                     = ( require 'child_process' ).spawn\n  return readstream_from_spawn spawn P...\n\n#-----------------------------------------------------------------------------------------------------------\n@spawn_and_read_lines = ( P... ) ->\n  last_line = null\n  R         = @create_throughstream()\n  input     = @spawn_and_read P...\n  #.........................................................................................................\n  input\n    .pipe @$split()\n    .pipe $ ( line, send, end ) =>\n      #.....................................................................................................\n      if line?\n        R.write last_line if last_line?\n        last_line = line\n      #.....................................................................................................\n      if end?\n        R.write last_line if last_line? and last_line.length > 0\n        R.end()\n        end()\n  #.........................................................................................................\n  return R\n\n\n#===========================================================================================================\n# NO-OP\n#-----------------------------------------------------------------------------------------------------------\n@$pass_through = -> $ ( data, send ) -> send data\n\n\n#===========================================================================================================\n# SUB-STREAMS\n#-----------------------------------------------------------------------------------------------------------\n@$sub = ( sub_transformer ) ->\n  #.........................................................................................................\n  _send   = null\n  # _end    = null\n  cache   = undefined\n  #.........................................................................................................\n  source        = @create_throughstream()\n  sink          = @create_throughstream()\n  state         = {}\n  source.ended  = false\n  sub_transformer source, sink, state\n  #.........................................................................................................\n  sink.on   'data', ( data )  => _send data\n  sink.on   'end',            => _send.end()\n  #.........................................................................................................\n  return $ ( data, send, end ) =>\n    if data?\n      _send = send\n      if cache is undefined\n        cache = data\n      else\n        source.write cache\n        cache = data\n    if end?\n      source.ended = true\n      source.write cache unless cache is undefined\n\n\n#===========================================================================================================\n# SORT AND SHUFFLE\n#-----------------------------------------------------------------------------------------------------------\n@$densort = ( key = 1, first_idx = 0, report_handler = null ) ->\n  ds        = @new_densort key, first_idx, report_handler\n  has_ended = no\n  #.........................................................................................................\n  # send_data = ( send, data ) =>\n  #.........................................................................................................\n  signal_end = ( send ) =>\n    send.end() unless has_ended\n    has_ended = yes\n  #.........................................................................................................\n  return $ ( input_data, send, end ) =>\n    #.......................................................................................................\n    if input_data?\n      ds input_data, ( error, output_data ) =>\n        return send.error error if error?\n        send output_data\n    #.......................................................................................................\n    if end?\n      ds null, ( error, output_data ) =>\n        return send.error error if error?\n        if output_data? then  send output_data\n        else                  signal_end send\n\n#-----------------------------------------------------------------------------------------------------------\n# @$shuffle =\n\n#===========================================================================================================\n# SAMPLING / THINNING OUT\n#-----------------------------------------------------------------------------------------------------------\n@$sample = ( p = 0.5, options ) ->\n  ### Given a `0 <= p <= 1`, interpret `p` as the *p*robability to *p*ick a given record and otherwise toss\n  it, so that `$sample 1` will keep all records, `$sample 0` will toss all records, and\n  `$sample 0.5` (the default) will toss (on average) every other record.\n\n  You can pipe several `$sample()` calls, reducing the data stream to 50% with each step. If you know\n  your data set has, say, 1000 records, you can cut down to a random sample of 10 by piping the result of\n  calling `$sample 1 / 1000 * 10` (or, of course, `$sample 0.01`).\n\n  Tests have shown that a data file with 3'722'578 records (which didn't even fit into memory when parsed)\n  could be perused in a matter of seconds with `$sample 1 / 1e4`, delivering a sample of around 370\n  records. Because these records are randomly selected and because the process is so immensely sped up, it\n  becomes possible to develop regular data processing as well as coping strategies for data-overload\n  symptoms with much more ease as compared to a situation where small but realistic data sets are not\n  available or have to be produced in an ad-hoc, non-random manner.\n\n  **Parsing CSV**: There is a slight complication when your data is in a CSV-like format: in that case,\n  there is, with `0 < p < 1`, a certain chance that the *first* line of a file is tossed, but some\n  subsequent lines are kept. If you start to transform the text line into objects with named values later in\n  the pipe (which makes sense, because you will typically want to thin out largeish streams as early on as\n  feasible), the first line kept will be mis-interpreted as a header line (which must come first in CSV\n  files) and cause all subsequent records to become weirdly malformed. To safeguard against this, use\n  `$sample p, headers: true` (JS: `$sample( p, { headers: true } )`) in your code.\n\n  **Predictable Samples**: Sometimes it is important to have randomly selected data where samples are\n  constant across multiple runs:\n\n  * once you have seen that a certain record appears on the screen log, you are certain it will be in the\n    database, so you can write a snippet to check for this specific one;\n\n  * you have implemented a new feature you want to test with an arbitrary subset of your data. You're\n    still tweaking some parameters and want to see how those affect output and performance. A random\n    sample that is different on each run would be a problem because the number of records and the sheer\n    bytecount of the data may differ from run to run, so you wouldn't be sure which effects are due to\n    which causes.\n\n  To obtain predictable samples, use `$sample p, seed: 1234` (with a non-zero number of your choice);\n  you will then get the exact same\n  sample whenever you re-run your piping application with the same stream and the same seed. An interesting\n  property of the predictable sample is that—everything else being the same—a sample with a smaller `p`\n  will always be a subset of a sample with a bigger `p` and vice versa. ###\n  #.........................................................................................................\n  unless 0 <= p <= 1\n    throw new Error \"expected a number between 0 and 1, got #{rpr p}\"\n  #.........................................................................................................\n  ### Handle trivial edge cases faster (hopefully): ###\n  return ( $ ( record, send ) => send record ) if p == 1\n  return ( $ ( record, send ) => null        ) if p == 0\n  #.........................................................................................................\n  headers = options?[ 'headers'     ] ? false\n  seed    = options?[ 'seed'        ] ? null\n  count   = 0\n  rnd     = rnd_from_seed seed\n  #.........................................................................................................\n  return $ ( record, send ) =>\n    count += 1\n    send record if ( count is 1 and headers ) or rnd() < p\n\n\n#===========================================================================================================\n# AGGREGATION & DISSEMINATION\n#-----------------------------------------------------------------------------------------------------------\n@$aggregate = ( initial_value, on_data, on_end = null ) ->\n  ### `$aggregate` allows to compose stream transformers that act on the entire stream. Aggregators may\n\n  * replace all data items with a single item;\n  * observe the entire stream and either add or print out summary values.\n\n  `$aggregate` should be called with two or three arguments:\n  * `initial_value` is the base value that represents the value of the aggregator when it never\n    gets to see any data; for a count or a sum that would be `0`, for a list of all data items, that would\n    be an empty list, and so on.\n  * `on_data` is the handler for each data items. It will be called as `on_data data, send`. Whatever\n    value the data handler returns becomes the next value of the aggregator. If you want to *keep* data\n    ittems in the stream, you must call `send data`; if you want to *omit* data items (and maybe later on\n    replace them with the aggregate), do not call `send data`.\n  * `on_end`, when given, will be called as `on_end current_value, send` after the last data item has come\n    down the stream, but before `end` is emitted on the stream. It gives you the chance to perform some\n    data transformation on your aggregate. If `on_end` is not given, the default operation is to just send\n    on the current value of the aggregate.\n\n  See `$count` and `$collect` for examples of aggregators.\n\n  Note that unlike `Array::reduce`, handlers will not be given much context; it is your obligation to do\n  all the bookkeeping—which should be a simple and flexible thing to implement using JS closures.\n  ###\n  current_value = initial_value\n  return $ ( data, send, end ) =>\n    if data?\n      current_value = on_data data, send\n    if end?\n      if on_end? then on_end current_value, send else send current_value\n      end()\n\n#-----------------------------------------------------------------------------------------------------------\n@$count = ( on_end = null ) ->\n  count = 0\n  #.........................................................................................................\n  on_data = ( data, send ) ->\n    send data\n    return count += +1\n  #.........................................................................................................\n  return @$aggregate count, on_data, on_end\n\n#-----------------------------------------------------------------------------------------------------------\n@$collect = ( on_end = null ) ->\n  collector = []\n  #.........................................................................................................\n  on_data = ( data, send ) ->\n    collector.push data\n    return collector\n  #.........................................................................................................\n  return @$aggregate collector, on_data, on_end\n\n#-----------------------------------------------------------------------------------------------------------\n@$spread = ( settings ) ->\n  indexed   = settings?[ 'indexed'  ] ? no\n  end       = settings?[ 'end'      ] ? no\n  return $ ( data, send ) =>\n    unless type = ( CND.type_of data ) is 'list'\n      return send.error new Error \"expected a list, got a #{rpr type}\"\n    for value, idx in data\n      send if indexed then [ idx, value, ] else value\n    send null if end\n\n#-----------------------------------------------------------------------------------------------------------\n@$batch = ( batch_size = 1000 ) ->\n  throw new Error \"buffer size must be non-negative integer, got #{rpr batch_size}\" if batch_size < 0\n  buffer = []\n  #.........................................................................................................\n  return $ ( data, send, end ) =>\n    if data?\n      buffer.push data\n      if buffer.length >= batch_size\n        send buffer\n        buffer = []\n    if end?\n      send buffer if buffer.length > 0\n      end()\n\n\n#===========================================================================================================\n# STREAM START & END DETECTION\n#-----------------------------------------------------------------------------------------------------------\n# @$signal_end = ( signal = @eos ) ->\n#   ### Given an optional `signal` (which defaults to `null`), return a stream transformer that emits\n#   `signal` as last value in the stream. Observe that whatever value you choose for `signal`, that value\n#   should be gracefully handled by any transformers that follow in the pipe. ###\n#   on_data = null\n#   on_end  = ->\n#     @emit 'data', signal\n#     @emit 'end'\n#   return ES.through on_data, on_end\n\n#-----------------------------------------------------------------------------------------------------------\n@$on_end = ( method ) ->\n  ### TAINT use `$map` to turn this into an async method? ###\n  switch arity = method.length\n    when 0, 1, 2 then null\n    else throw new Error \"expected method with arity 1 or 2, got one with arity #{arity}\"\n  return $ ( data, send, end ) ->\n    send data if data?\n    if end?\n      if arity is 0\n        method()\n        return end()\n      return method end if arity is 1\n      method send, end\n\n#-----------------------------------------------------------------------------------------------------------\n@$on_start = ( method ) ->\n  is_first = yes\n  return $ ( data, send ) ->\n    method send if is_first\n    is_first = no\n    send data\n\n\n#===========================================================================================================\n# FILTERING\n#-----------------------------------------------------------------------------------------------------------\n@$filter = ( method ) ->\n  return $ ( data, send ) =>\n    send data if method data\n\n# #-----------------------------------------------------------------------------------------------------------\n# @$take_last_good = ( method ) ->\n#   last_data = null\n#   return $ ( data, send, end ) =>\n#     if data?\n#       if method data\n#       last_data = data\n#     if end?\n#       end()\n\n#===========================================================================================================\n# REPORTING\n#-----------------------------------------------------------------------------------------------------------\n@$show = ( badge = null ) ->\n  my_show = CND.get_logger 'info', badge ? '*'\n  return $ ( record, send ) =>\n    my_show rpr record\n    send record\n\n#-----------------------------------------------------------------------------------------------------------\n@$observe = ( method ) ->\n  ### Call `method` for each piece of data; when `method` has returned with whatever result, send data on.\n  Essentially the same as a `$filter` transform whose method always returns `true`. ###\n  # return @$filter ( data ) -> method data; return true\n  switch arity = method.length\n    when 1\n      return $ ( data, send ) =>\n        method data\n        send data\n    when 2\n      return $ ( data, send, end ) =>\n        if data?\n          method data, false\n          send data\n        if end?\n          method undefined, true\n          end()\n    else throw new Error \"expected method with arity 1 or 2, got one with arity #{arity}\"\n\n#-----------------------------------------------------------------------------------------------------------\n@$stop_time = ( badge_or_handler ) ->\n  t0 = null\n  return @$observe ( data, is_last ) =>\n    t0 = +new Date() if data? and not t0?\n    if is_last\n      dt = ( new Date() ) - t0\n      switch type = CND.type_of badge_or_handler\n        when 'function'\n          badge_or_handler dt\n        when 'text', 'jsundefined'\n          logger = CND.get_logger 'info', badge_or_handler ? 'stop time'\n          logger \"#{(dt / 1000).toFixed 2}s\"\n        else\n          throw new Error \"expected function or text, got a #{type}\"\n\n\n#===========================================================================================================\n# THROUGHPUT LIMITING\n#-----------------------------------------------------------------------------------------------------------\n@$throttle_bytes = ( bytes_per_second ) ->\n  Throttle = require 'throttle'\n  return new Throttle bytes_per_second\n\n#-----------------------------------------------------------------------------------------------------------\n@$throttle_items = ( items_per_second ) ->\n  buffer    = []\n  count     = 0\n  idx       = 0\n  _send     = null\n  timer     = null\n  has_ended = no\n  #.........................................................................................................\n  emit = ->\n    if ( data = buffer[ idx ] ) isnt undefined\n      buffer[ idx ] = undefined\n      idx   += +1\n      count += -1\n      _send data\n    #.......................................................................................................\n    if has_ended and count < 1\n      clearInterval timer\n      _send.end()\n      buffer = _send = timer = null # necessary?\n    #.......................................................................................................\n    return null\n  #.........................................................................................................\n  start = ->\n    timer = setInterval emit, 1 / items_per_second * 1000\n  #---------------------------------------------------------------------------------------------------------\n  return $ ( data, send, end ) =>\n    if data?\n      unless _send?\n        _send = send\n        start()\n      buffer.push data\n      count += +1\n    #.......................................................................................................\n    if end?\n      has_ended = yes\n\n\n#===========================================================================================================\n# CSV\n#-----------------------------------------------------------------------------------------------------------\n@$parse_csv = ( options ) ->\n  field_names = null\n  options    ?= {}\n  headers     = options[ 'headers'    ] ? true\n  delimiter   = options[ 'delimiter'  ] ? ','\n  qualifier   = options[ 'qualifier'  ] ? '\"'\n  #.........................................................................................................\n  return @remit ( record, send ) =>\n    if record?\n      values = ( S record ).parseCSV delimiter, qualifier, '\\\\'\n      if headers\n        if field_names is null\n          field_names = values\n        else\n          record = {}\n          record[ field_names[ idx ] ] = value for value, idx in values\n          send record\n      else\n        send values\n\n\n#===========================================================================================================\n# ERROR HANDLING\n#-----------------------------------------------------------------------------------------------------------\n@run = ( method, handler ) ->\n  domain  = ( require 'domain' ).create()\n  domain.on 'error', ( error ) -> handler error\n  setImmediate -> domain.run method\n  return domain\n\n\n#===========================================================================================================\n# HELPERS\n#-----------------------------------------------------------------------------------------------------------\nget_random_integer = ( rnd, min, max ) ->\n  return ( Math.floor rnd() * ( max + 1 - min ) ) + min\n\n#-----------------------------------------------------------------------------------------------------------\nrnd_from_seed = ( seed ) ->\n  return if seed? then CND.get_rnd seed else Math.random\n\n\n\n#===========================================================================================================\n# EXPERIMENTAL\n# #-----------------------------------------------------------------------------------------------------------\n# @_$send_later = ->\n#   #.........................................................................................................\n#   R     = D.create_throughstream()\n#   count = 0\n#   _end  = null\n#   #.....................................................................................................\n#   send_end = =>\n#     if _end? and count <= 0\n#       _end()\n#     else\n#       setImmediate send_end\n#   #.....................................................................................................\n#   R\n#     .pipe $ ( data, send, end ) =>\n#       if data?\n#         count += +1\n#         setImmediate =>\n#           count += -1\n#           send data\n#           debug '©MxyBi', count\n#       if end?\n#         _end = end\n#   #.....................................................................................................\n#   send_end()\n#   return R\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_$pull = ->\n#   queue     = []\n#   # _send     = null\n#   is_first  = yes\n#   pull = ->\n#     if queue.length > 0\n#       return queue.pop()\n#     else\n#       return [ 'empty', ]\n#   return $ ( data, send, end ) =>\n#     if is_first\n#       is_first = no\n#       send pull\n#     if data?\n#       queue.unshift [ 'data', data, ]\n#     if end?\n#       queue.unshift [ 'end', end, ]\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_$take = ->\n#   return $ ( pull, send ) =>\n#     # debug '©vKkJf', pull\n#     # debug '©vKkJf', pull()\n#     process = =>\n#       [ type, data, ] = pull()\n#       # debug '©bamOB', [ type, data, ]\n#       switch type\n#         when 'data'   then send data\n#         when 'empty'  then null\n#         when 'end'    then return send.end()\n#         else send.error new Error \"unknown event type #{rpr type}\"\n#       setImmediate process\n#     process()\n\n\n\n\n"]}