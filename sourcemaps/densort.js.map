{"version":3,"sources":["densort.coffee"],"names":[],"mappings":"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","file":"densort.js","sourceRoot":"/source/","sourcesContent":["\n\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr.bind CND\nbadge                     = 'PIPEDREAMS2/densort'\nlog                       = CND.get_logger 'plain',     badge\ninfo                      = CND.get_logger 'info',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\nalert                     = CND.get_logger 'alert',     badge\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\necho                      = CND.echo.bind CND\n\n\n\n#-----------------------------------------------------------------------------------------------------------\n@new_densort = ( getter = 1, first_idx = 0, report_handler = null ) ->\n  ### Given up to three arguments—a `getter`, a `first_idx`, and a `report_handler`—return a function\n  `densort = ( element, handler ) ->` that in turn accepts a series of indexed elements and a callback\n  function which it will be called once for each element and in the order of the element indices.\n\n  The `densort` function should be called one for each element; each element should be an object or\n  primitive value. In case `getter` is not callable, then indices will be retrieved as `element[ getter ]`\n  (`getter` defaulting to `1`, because i often send 'event' lists similar to `[ type, idx, payload... ]` down\n  the stream); in case `getter` is a function, indices will be retrieved as `getter element`. When the series\n  of elements has ended, `densort` should be called once more with a `null` value to signal this.\n\n  The `handler` argument to `densort` should be a NodeJS-style callback function, i.e. it should accept\n  two arguments, `error` and `element`; it is sort of symmetric to `densort` as it will be called once\n  as `handler null, element` for each element and once as `handler null, null` to signal exhaustion of the\n  series.\n\n\n  ###\n  #.........................................................................................................\n  getter_is_function  = CND.isa_function getter\n  buffer              = []\n  buffer_size         = 0             # Amount of buffered items\n  previous_idx        = first_idx - 1 # Index of most recently sent item\n  smallest_idx        = Infinity      # Index of first item in buffer\n  min_legal_idx       = 0             # 'Backlog' of the range of indexes that have already been sent out\n  max_buffer_size     = 0\n  element_count       = 0\n  sent_count          = 0\n  #.........................................................................................................\n  if report_handler is true\n    report_handler = ( [ event_count, max_buffer_size, ] ) ->\n      percentage = (     max_buffer_size / event_count * 100  ).toFixed 2\n      efficiency = ( 1 - max_buffer_size / event_count        ).toFixed 2\n      info \"\"\"\\nPipeDreams DenSort:\n        of #{event_count} elements, up to #{max_buffer_size} (#{percentage}%) had to be buffered;\n        efficiency: #{efficiency}\"\"\"\n  #.........................................................................................................\n  buffer_element = ( idx, element, handler ) =>\n    return handler new Error \"duplicate index #{rpr idx}\" if buffer[ idx ]?\n    smallest_idx  = Math.min smallest_idx, idx\n    # debug '<---', smallest_idx\n    buffer[ idx ] = element\n    buffer_size  += +1\n    return null\n  #.........................................................................................................\n  send_buffered_elements = ( handler ) =>\n    ### Refuse to send anything unless all elements with smaller indexes have already been sent: ###\n    return if sent_count < ( smallest_idx - first_idx )\n    loop\n      ### Terminate loop in case nothing is in the buffer or we have reached an empty position: ###\n      if buffer_size < 1 or not ( element = buffer[ smallest_idx ] )?\n        # smallest_idx    = Infinity if buffer_size < 1\n        min_legal_idx   = Math.max min_legal_idx, smallest_idx\n        break\n      #.....................................................................................................\n      ### Remove element to be sent from buffer (making it a sparse list in most cases), adjust sentinels and\n      send element: ###\n      delete buffer[ smallest_idx ]\n      previous_idx    = smallest_idx\n      max_buffer_size = Math.max max_buffer_size, buffer_size\n      smallest_idx   += +1\n      buffer_size    += -1\n      sent_count     += +1\n      min_legal_idx   = Math.max min_legal_idx, smallest_idx\n      handler null, element\n  #.........................................................................................................\n  return ( element, handler ) =>\n    #.......................................................................................................\n    if element?\n      element_count += +1\n      idx            = if getter_is_function then getter element else element[ getter ]\n      return handler new Error \"index too small: #{rpr idx}\" if idx < first_idx\n      return handler new Error \"duplicate index: #{rpr idx}\" if idx < min_legal_idx\n      #.....................................................................................................\n      if buffer_size is 0 and idx is previous_idx + 1\n        previous_idx    = idx\n        min_legal_idx   = idx + 1\n        sent_count     += +1\n        smallest_idx    = Infinity if buffer_size < 1\n        handler null, element\n      #.....................................................................................................\n      else\n        buffer_element idx, element, handler\n        send_buffered_elements handler\n    #.......................................................................................................\n    else\n      send_buffered_elements handler\n      return handler new Error \"detected missing elements\" if buffer_size > 0\n      report_handler [ element_count, max_buffer_size, ] if report_handler?\n      handler null, null\n\n\n\n"]}