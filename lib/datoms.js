// Generated by CoffeeScript 2.5.1
(function() {
  'use strict';
  var CND, LFT, LFT_nofreeze, assign, badge, copy, debug, echo, help, info, isa, jr, rpr, type_of, types, urge, validate, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS/DATOMS';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  ({assign, copy, jr} = CND);

  //...........................................................................................................
  types = require('./_types');

  ({isa, validate, type_of} = types);

  LFT = require('letsfreezethat');

  LFT_nofreeze = LFT.nofreeze;

  this._copy = LFT_nofreeze._copy.bind(LFT);

  this._nofreeze = false;

  //-----------------------------------------------------------------------------------------------------------
  this.create_nofreeze = function() {
    var R;
    R = new this.Pipedreams();
    R._nofreeze = true;
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.freeze = function(d) {
    if (this._nofreeze) {
      return LFT_nofreeze.freeze(d);
    } else {
      return LFT.freeze(d);
    }
  };

  this.thaw = function(d) {
    if (this._nofreeze) {
      return LFT_nofreeze.thaw(d);
    } else {
      return LFT.thaw(d);
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this.lets = function(original, modifier) {
    var draft;
    if (this._nofreeze) {
      draft = this._copy(original);
      if (modifier != null) {
        modifier(draft);
        if (draft.$dirty === original.dirty) {
          draft.$dirty = true;
        }
      }
      return draft;
    }
    //.........................................................................................................
    draft = this.thaw(original);
    if (modifier != null) {
      modifier(draft);
      if (draft.$dirty === original.dirty) {
        draft.$dirty = true;
      }
    }
    return this.freeze(draft);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.set = function(d, k, ...P) {
    var count;
    if (isa.text(k)) {
      if ((count = P.length) !== 1) {
        throw new Error(`Âµ67663 expected 1 value got ${count}`);
      }
      return this.lets(d, function(d) {
        return d[k] = P[0];
      });
    }
    return this.lets(d, function(d) {
      var ref1, results, v;
      ref1 = assign({}, k, ...P);
      results = [];
      for (k in ref1) {
        v = ref1[k];
        results.push(d[k] = v);
      }
      return results;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.unset = function(d, k) {
    return this.lets(d, function(d) {
      return delete d[k];
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.stamp = function(d, ...P) {
    /* Set the `$stamped` attribute on datom to sigil it as processed. Stamped datoms will not be selected
     by the `select` method unless tag '#stamped' is used. */
    return this.lets(d, function(d) {
      return assign(d, ...P, {
        $stamped: true
      });
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.unstamp = function(d) {
    if (!d.$stamped) {
      return d;
    }
    return this.lets(d, function(d) {
      return delete d.$stamped;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.is_system = function(d) {
    /* Return whether datom is a system datom (i.e. whether its `sigil` equals `'~'`). */
    return d.key.match(/^[~\[\]]/);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.is_stamped = function(d) {
    var ref1;
    return (ref1 = d.$stamped) != null ? ref1 : false/* i.e. already processed? */;
  };

  this.is_fresh = function(d) {
    var ref1;
    return (ref1 = d.$fresh) != null ? ref1 : false/* i.e. created within stream? */;
  };

  this.is_dirty = function(d) {
    var ref1;
    return (ref1 = d.$dirty) != null ? ref1 : false/* i.e. modified? */;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_datom = function(key, value, ...other) {
    var R;
    /* TAINT should validate key */
    /* When `other` contains a key `$`, it is treated as a hint to copy
     system-level attributes; if the value of key `$` is a POD that has itself a
     key `$`, then a copy of that value is used. This allows to write `new_datom
     ..., $: d` to copy system-level attributes such as source locations to a new
     datom. */
    validate.pd_datom_key(key);
    if (value != null) {
      if (!isa.object(value)) {
        value = {value};
      }
      R = assign({key}, value, ...other);
    } else {
      R = assign({key}, ...other);
    }
    while ((isa.object(R.$)) && (isa.object(R.$.$))) {
      R.$ = copy(R.$.$);
    }
    return this.freeze(R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_single_datom = function(key, value, ...other) {
    return this.new_datom(`^${key}`, value, ...other);
  };

  this.new_open_datom = function(key, value, ...other) {
    return this.new_datom(`<${key}`, value, ...other);
  };

  this.new_close_datom = function(key, value, ...other) {
    return this.new_datom(`>${key}`, value, ...other);
  };

  this.new_system_datom = function(key, value, ...other) {
    return this.new_datom(`~${key}`, value, ...other);
  };

  this.new_text_datom = function(value, ...other) {
    return this.new_single_datom('text', value, ...other);
  };

  this.new_end_datom = function() {
    return this.new_system_datom('end');
  };

  // @new_flush_datom    =                           -> @new_system_datom  'flush'

  //-----------------------------------------------------------------------------------------------------------
  this.new_warning = function(ref, message, d, ...other) {
    return this.new_system_datom('warning', d, {ref, message}, ...other);
  };

}).call(this);

//# sourceMappingURL=datoms.js.map
