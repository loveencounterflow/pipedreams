// Generated by CoffeeScript 1.8.0
(function() {
  var TRM, alert, badge, debug, echo, help, info, log, rpr, urge, warn, whisper;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'PIPEDREAMS2';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  this.remit = function(method) {
    var arity, cache, get_send, on_data, on_end, send;
    send = null;
    cache = null;
    on_end = null;
    get_send = function(self, encoding, done) {
      var R;
      R = function(data) {
        return done(new Error("Pipedreams v2 API changed; use `send.one` or `send.done`"));
      };
      R.one = function(data) {
        return self.push(data);
      };
      R.done = function(data) {
        if (data != null) {
          self.push(data);
        }
        return done();
      };
      R.error = function(error) {
        return done(error);
      };

      /* TAINT it's presently not quite clear whether using the advisory `@emit 'end'` or else the
        prescriptive `@end()` is the better way to tell the stream we've finished; until i find out,
        we add one more method, `send.finish()` that uses `@end` instead of emitting an event.
       */
      R.end = function() {
        return self.emit('end');
      };
      R.finish = function() {
        return self.end();
      };
      R.encoding = encoding;
      return R;
    };
    switch (arity = method.length) {
      case 2:
        on_data = function(data, encoding, done) {
          if (send == null) {
            send = get_send(this, encoding, done);
          }
          return method(data, send);
        };
        break;
      case 3:
        cache = [];
        on_data = function(data, encoding, done) {
          var _ref;
          if (cache.length === 0) {
            cache[0] = data;
            return done();
          }
          _ref = [data, cache[0]], cache[0] = _ref[0], data = _ref[1];
          send = get_send(this, encoding, done);
          return method(data, send, null);
        };
        on_end = function(done) {
          var data;
          if (cache.length === 0) {
            data = null;
          } else {
            data = cache[0];
            cache.length = 0;
          }
          send = get_send(this, null, done);
          return method(data, send, send.end);
        };
        break;
      default:
        throw new Error("expected a method with an arity of 2 or 3, got one with an arity of " + arity);
    }

    /* TAINT no way to use byte / text streaming? necessary? */
    return through2.obj(on_data, on_end);
  };

}).call(this);
