// Generated by CoffeeScript 1.9.0
(function() {
  var $, CND, DS, ES, LODASH, PIPEDREAMS, alert, badge, debug, echo, help, info, log, rpr, through2, urge, warn, whisper,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS2';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);


  /* https://github.com/rvagg/through2 */

  through2 = require('through2');


  /* https://github.com/dominictarr/event-stream */

  ES = require('event-stream');


  /* https://github.com/dominictarr/sort-stream */

  this.$sort = require('sort-stream');

  this.new_densort = (DS = require('./densort')).new_densort.bind(DS);

  PIPEDREAMS = this;

  LODASH = CND.LODASH;

  this.HOTMETAL = require('hotmetal');

  this.$split = ES.split.bind(ES);

  this.remit = function(method) {
    var arity, get_send, on_data, on_end, send;
    send = null;
    on_end = null;
    get_send = function(self) {
      var R;
      R = function(data) {
        return self.emit('data', data);
      };
      R.error = function(error) {
        return self.emit('error', error);
      };
      R.end = function() {
        return self.emit('end');
      };
      R.pause = function() {
        return self.pause();
      };
      R.resume = function() {
        return self.resume();
      };
      R.read = function() {
        return self.read();
      };
      R.stream = self;
      return R;
    };
    on_data = function(data) {
      if (send == null) {
        send = get_send(this);
      }
      return method(data, send);
    };
    switch (arity = method.length) {
      case 2:
        null;
        break;
      case 3:
        on_end = function() {
          var end;
          if (send == null) {
            send = get_send(this);
          }
          end = (function(_this) {
            return function() {
              return _this.emit('end');
            };
          })(this);
          return method(void 0, send, end);
        };
        break;
      default:
        throw new Error("expected a method with an arity of 2 or 3, got one with an arity of " + arity);
    }
    return ES.through(on_data, on_end);
  };

  $ = this.remit.bind(this);

  this.$skip_first = function(n) {
    var count;
    if (n == null) {
      n = 1;
    }
    count = 0;
    return $(function(data, send) {
      count += +1;
      if (count > n) {
        return send(data);
      }
    });
  };

  this.create_throughstream = function() {
    var P, R;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    R = through2.obj.apply(through2, P);
    R.setMaxListeners(0);
    return R;
  };

  this.$sub = function(sub_transformer) {
    var cache, sink, source, state, _end, _send;
    _send = null;
    _end = null;
    cache = void 0;
    source = this.create_throughstream();
    sink = this.create_throughstream();
    state = {};
    source.ended = false;
    sub_transformer(source, sink, state);
    sink.on('data', (function(_this) {
      return function(data) {
        return _send(data);
      };
    })(this));
    sink.on('end', (function(_this) {
      return function() {
        return _send.end();
      };
    })(this));
    return $((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          _send = send;
          if (cache === void 0) {
            cache = data;
          } else {
            source.write(cache);
            cache = data;
          }
        }
        if (end != null) {
          source.ended = true;
          if (cache !== void 0) {
            return source.write(cache);
          }
        }
      };
    })(this));
  };

  this.$densort = function(key, first_idx, report_handler) {
    var ds, has_ended, send_data, signal_end;
    if (key == null) {
      key = 1;
    }
    if (first_idx == null) {
      first_idx = 0;
    }
    if (report_handler == null) {
      report_handler = null;
    }
    ds = this.new_densort(key, first_idx, report_handler);
    has_ended = false;
    send_data = (function(_this) {
      return function(send, data) {};
    })(this);
    signal_end = (function(_this) {
      return function(send) {
        if (!has_ended) {
          send.end();
        }
        return has_ended = true;
      };
    })(this);
    return $((function(_this) {
      return function(input_data, send, end) {
        if (input_data != null) {
          ds(input_data, function(error, output_data) {
            if (error != null) {
              return send.error(error);
            }
            return send(output_data);
          });
        }
        if (end != null) {
          return ds(null, function(error, output_data) {
            if (error != null) {
              return send.error(error);
            }
            if (output_data != null) {
              return send(output_data);
            } else {
              return signal_end(send);
            }
          });
        }
      };
    })(this));
  };

  this.$aggregate = function(aggregator, on_end) {
    var Z;
    if (on_end == null) {
      on_end = null;
    }
    Z = null;
    return $((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          Z = aggregator(data);
          if (on_end != null) {
            send(data);
          }
        }
        if (end != null) {
          if (on_end != null) {
            on_end(Z);
          } else {
            send(Z);
          }
          return end();
        }
      };
    })(this));
  };

  this.$count = function(on_end) {
    var count;
    if (on_end == null) {
      on_end = null;
    }
    count = 0;
    return this.$aggregate((function() {
      return count += +1;
    }), on_end);
  };

  this.$collect = function(on_end) {
    var aggregator, collector;
    if (on_end == null) {
      on_end = null;
    }
    collector = [];
    aggregator = function(data) {
      collector.push(data);
      return collector;
    };
    return this.$aggregate(aggregator, on_end);
  };

  this.$spread = function(settings) {
    var end, indexed, _ref, _ref1;
    indexed = (_ref = settings != null ? settings['indexed'] : void 0) != null ? _ref : false;
    end = (_ref1 = settings != null ? settings['end'] : void 0) != null ? _ref1 : false;
    return $((function(_this) {
      return function(data, send) {
        var idx, type, value, _i, _len;
        if (!(type = (CND.type_of(data)) === 'list')) {
          return send.error(new Error("expected a list, got a " + (rpr(type))));
        }
        for (idx = _i = 0, _len = data.length; _i < _len; idx = ++_i) {
          value = data[idx];
          send(indexed ? [idx, value] : value);
        }
        if (end) {
          return send(null);
        }
      };
    })(this));
  };

  this.$signal_end = function(signal) {
    var on_data, on_end;
    if (signal == null) {
      signal = this.eos;
    }

    /* Given an optional `signal` (which defaults to `null`), return a stream transformer that emits
    `signal` as last value in the stream. Observe that whatever value you choose for `signal`, that value
    should be gracefully handled by any transformers that follow in the pipe.
     */
    on_data = null;
    on_end = function() {
      this.emit('data', signal);
      return this.emit('end');
    };
    return ES.through(on_data, on_end);
  };

  this.$on_end = function(method) {
    return $(function(data, send, end) {
      if (data != null) {
        send(data);
      }
      if (end != null) {
        return method(send, end);
      }
    });
  };

  this.$on_start = function(method) {
    var is_first;
    is_first = true;
    return $(function(data, send) {
      if (is_first) {
        method(send);
      }
      is_first = false;
      return send(data);
    });
  };

  this.$filter = function(select) {
    return $((function(_this) {
      return function(event, send) {
        if (select(event)) {
          return send(event);
        }
      };
    })(this));
  };

  this.$show = function(badge) {
    var my_show;
    if (badge == null) {
      badge = null;
    }
    my_show = CND.get_logger('info', badge != null ? badge : '*');
    return $((function(_this) {
      return function(record, send) {
        my_show(rpr(record));
        return send(record);
      };
    })(this));
  };

  this.$continue = function(stream) {
    return $((function(_this) {
      return function(data, send, end) {
        stream.write(data);
        if (end != null) {
          stream.end();
          return end();
        }
      };
    })(this));
  };

  this.$link = function() {
    var sink, source, transform, transforms, _i, _len, _ref, _send;
    transforms = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (transforms.length === 0) {
      return this.create_throughstream();
    }
    source = sink = this.create_throughstream();
    _ref = LODASH.flatten(transforms);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      transform = _ref[_i];
      sink = sink.pipe(transform);
    }
    _send = null;
    sink.on('data', (function(_this) {
      return function(data) {
        return _send(data);
      };
    })(this));
    return $((function(_this) {
      return function(data, send) {
        _send = send;
        return source.write(data);
      };
    })(this));
  };

  this.new_hyphenate = function(hyphenation, min_length) {
    var HYPHER, Hypher;
    if (hyphenation == null) {
      hyphenation = null;
    }
    if (min_length == null) {
      min_length = 2;
    }

    /* https://github.com/bramstein/hypher */
    Hypher = require('hypher');
    if (hyphenation == null) {
      hyphenation = require('hyphenation.en-us');
    }
    HYPHER = new Hypher(hyphenation);
    return HYPHER.hyphenateText.bind(HYPHER);
  };

  this.$hyphenate = function(hyphenation, min_length) {
    var hyphenate;
    if (hyphenation == null) {
      hyphenation = null;
    }
    if (min_length == null) {
      min_length = 4;
    }
    hyphenate = this.new_hyphenate(hyphenation, min_length);
    return $((function(_this) {
      return function(text, send) {
        return send(hyphenate(text, min_length));
      };
    })(this));
  };

  this.break_lines = function(text, settings) {
    var R, breakpoint, extended, incremental, last_position, line_breaker, part, position, required, _ref, _ref1;
    text = text.replace(/\n/g, ' ');
    last_position = null;
    incremental = (_ref = settings != null ? settings['incremental'] : void 0) != null ? _ref : true;
    extended = (_ref1 = settings != null ? settings['extended'] : void 0) != null ? _ref1 : false;
    line_breaker = new (require('linebreak'))(text);
    R = [];
    while (breakpoint = line_breaker.nextBreak()) {
      position = breakpoint.position, required = breakpoint.required;
      if (incremental && (last_position != null)) {
        part = text.slice(last_position, breakpoint.position);
      } else {
        part = text.slice(0, breakpoint.position);
      }
      last_position = position;
      R.push(extended ? [part, required, position] : part);
    }
    return R;
  };

  this.$break_lines = function(settings) {
    return $((function(_this) {
      return function(text, send) {
        return send(_this.break_lines(text, settings));
      };
    })(this));
  };

  this.TYPO = {};

  this.TYPO.quotes = function(text) {
    return (require('typogr')).smartypants(text);
  };

  this.TYPO.dashes = function(text) {
    return (require('typogr')).smartypants(text);
  };

  this.TYPO.$quotes = function() {
    return $((function(_this) {
      return function(text, send) {
        return send(_this.quotes(text));
      };
    })(this));
  };

  this.TYPO.$dashes = function() {
    return $((function(_this) {
      return function(text, send) {
        return send(_this.dashes(text));
      };
    })(this));
  };

  this.MD = {};

  this.MD.new_parser = function(settings) {
    var MarkdownIt;
    if (settings != null) {
      throw new Error("settings not yet supported");
    }
    settings = {
      html: true,
      linkify: true,
      typographer: true
    };
    MarkdownIt = require('markdown-it');
    return new MarkdownIt(settings);
  };

  this.MD.as_html = function(md, parser) {
    if (parser == null) {
      parser = null;
    }
    return (parser != null ? parser : this.new_parser()).render(md);
  };

  this.MD.$as_html = function() {
    var parser;
    parser = this.new_parser();
    return $((function(_this) {
      return function(md, send) {
        return send(_this.as_html(md, parser));
      };
    })(this));
  };

  this.HTML = {};

  this.HTML.parse = function(html, disperse, hyphenation) {
    var H, R, break_lines, handlers, hyphenate, lone_tags, parser;
    if (disperse == null) {
      disperse = true;
    }
    if (hyphenation == null) {
      hyphenation = true;
    }
    H = PIPEDREAMS.HOTMETAL;
    lone_tags = "area base br col command embed hr img input keygen link meta param\nsource track wbr".split(/\s+/);
    if (disperse) {
      break_lines = PIPEDREAMS.break_lines.bind(PIPEDREAMS);
      if (hyphenation === false) {
        hyphenate = (function(_this) {
          return function(text) {
            return text;
          };
        })(this);
      } else if (CND.isa_function(hyphenation)) {
        hyphenate = hyphenation;
      } else {
        hyphenation = hyphenation === true ? null : hyphenation;
        hyphenate = PIPEDREAMS.new_hyphenate(hyphenation);
      }
    } else {
      break_lines = function(text) {
        return [text];
      };
      hyphenate = (function(_this) {
        return function(text) {
          return text;
        };
      })(this);
    }
    handlers = {
      doctype: (function(_this) {
        return function(name, pid, sid) {
          return H.add(R, 'doctype', name, pid, sid);
        };
      })(this),
      endTag: (function(_this) {
        return function(name) {
          return H.add(R, 'close-tag', name);
        };
      })(this),
      comment: (function(_this) {
        return function(text) {
          return H.add(R, 'comment', CND.escape_html(text));
        };
      })(this),
      text: (function(_this) {
        return function(text) {
          var text_part, _i, _len, _ref, _results;
          text = CND.escape_html(text);
          text = hyphenate(text);
          _ref = break_lines(text);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            text_part = _ref[_i];
            _results.push(H.add(R, 'text', text_part));
          }
          return _results;
        };
      })(this),
      startTag: (function(_this) {
        return function(name, a) {
          var attributes, k, v, _i, _len, _ref;
          attributes = {};
          if (a != null) {
            for (_i = 0, _len = a.length; _i < _len; _i++) {
              _ref = a[_i], k = _ref.name, v = _ref.value;
              attributes[k] = v;
            }
          }
          if (__indexOf.call(lone_tags, name) >= 0) {
            if (name === 'wbr') {
              if ((Object.keys(attributes)).length > 0) {
                throw new Error("illegal <wbr> tag with attributes");
              }

              /* as per https://developer.mozilla.org/en/docs/Web/HTML/Element/wbr */
              return H.add(R, 'text', '\u200b');
            } else {
              return H.add(R, 'lone-tag', name, attributes);
            }
          } else {
            return H.add(R, 'open-tag', name, attributes);
          }
        };
      })(this)
    };
    parser = new (require('parse5')).SimpleApiParser(handlers);
    R = H._new_hotml();
    parser.parse(html);
    return R;
  };

  this.HTML.$parse = function(disperse, hyphenation) {
    if (disperse == null) {
      disperse = true;
    }
    if (hyphenation == null) {
      hyphenation = true;
    }
    return $((function(_this) {
      return function(html, send) {
        return send(_this.parse(html, disperse, hyphenation));
      };
    })(this));
  };

  this.HTML.$slice_toplevel_tags = function() {
    return $((function(_this) {
      return function(me, send) {
        return PIPEDREAMS.HOTMETAL.slice_toplevel_tags(me, function(error, slice) {
          if (error != null) {
            return send.error(error);
          }
          return send(slice);
        });
      };
    })(this));
  };

  this.HTML.$unwrap = function(silent) {
    if (silent == null) {
      silent = false;
    }
    return $((function(_this) {
      return function(me, send) {
        return send(PIPEDREAMS.HOTMETAL.unwrap(me, silent));
      };
    })(this));
  };

  this.$throttle_bytes = function(bytes_per_second) {
    var Throttle;
    Throttle = require('throttle');
    return new Throttle(bytes_per_second);
  };

  this.$throttle_items = function(items_per_second) {
    var buffer, count, emit, has_ended, idx, start, timer, _send;
    buffer = [];
    count = 0;
    idx = 0;
    _send = null;
    timer = null;
    has_ended = false;
    emit = function() {
      var data;
      if ((data = buffer[idx]) !== void 0) {
        buffer[idx] = void 0;
        idx += +1;
        count += -1;
        _send(data);
      }
      if (has_ended && count < 1) {
        clearInterval(timer);
        _send.end();
        buffer = _send = timer = null;
      }
      return null;
    };
    start = function() {
      return timer = setInterval(emit, 1 / items_per_second * 1000);
    };
    return $((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          if (_send == null) {
            _send = send;
            start();
          }
          buffer.push(data);
          count += +1;
        }
        if (end != null) {
          return has_ended = true;
        }
      };
    })(this));
  };

}).call(this);
