// Generated by CoffeeScript 1.10.0
(function() {
  var CND, MSP, alert, badge, debug, echo, help, info, log, pluck, rnd_from_seed, rpr, urge, warn, whisper,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);


  /* https://github.com/maxogden/mississippi */

  MSP = require('mississippi');


  /* http://stringjs.com */


  /* https://github.com/mcollina/split2 */


  /* https://github.com/mziccard/node-timsort */

  this.new_stream = function() {
    var P, R, hints, kind, ref, seed, settings;
    P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    ref = this.new_stream._read_arguments(P), kind = ref[0], seed = ref[1], hints = ref[2], settings = ref[3];
    R = (function() {
      switch (kind) {
        case '*plain':
          return this._new_stream(seed, hints, settings);
        case 'file':
        case 'path':
          return this._new_stream_from_path(seed, hints, settings);
        case 'pipeline':
          return this._new_stream_from_pipeline(seed, hints, settings);
        case 'text':
          return this._new_stream_from_text(seed, hints, settings);
        case 'url':
          return this._new_stream_from_url(seed, hints, settings);
        case 'transform':
          return this._new_stream_from_transform(seed, hints, settings);
        default:
          throw new Error("unknown kind " + (rpr(kind)) + " (shouldn't happen)");
      }
    }).call(this);
    return R;
  };

  this.new_stream._read_arguments = (function(_this) {
    return function(P) {
      var expected, got, hints, kind, kind_and_seed, kind_count, seed, settings, x;
      kind_and_seed = null;
      settings = null;
      kind = null;
      seed = null;
      hints = null;
      if (P.length > 0) {
        if (P.length > 1) {
          if (!CND.isa_text(P[P.length - 1])) {
            kind_and_seed = P.pop();
          }
        }
        if (!CND.isa_text(P[P.length - 1])) {
          settings = kind_and_seed;
          kind_and_seed = P.pop();
        }
      }
      hints = P;
      if (kind_and_seed == null) {
        kind = '*plain';
      } else {
        if ((kind_count = (Object.keys(kind_and_seed)).length) !== 1) {
          throw new Error("expected 0 or 1 'kind', got " + kind_count);
        }
        for (kind in kind_and_seed) {
          seed = kind_and_seed[kind];
          break;
        }
      }
      if (indexOf.call(_this.new_stream._kinds, kind) < 0) {
        expected = ((function() {
          var i, len, ref, results;
          ref = this.new_stream._kinds;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            x = ref[i];
            results.push(rpr(x));
          }
          return results;
        }).call(_this)).join(', ');
        got = rpr(kind);
        throw new Error("expected a 'kind' out of " + expected + ", got " + got);
      }
      if (hints.length === 0) {
        hints = null;
      }
      return [kind, seed, hints, settings];
    };
  })(this);

  this.new_stream._kinds = ['*plain', 'file', 'path', 'pipeline', 'text', 'url', 'transform'];

  this._new_stream = function(seed, hints, settings) {
    if ((seed == null) && (settings == null) && (hints != null) && (hints.length === 1) && indexOf.call(hints, 'devnull') >= 0) {
      return this._new_devnull_stream();
    }
    if (seed != null) {
      throw new Error("_new_stream doesn't accept 'seed', got " + (rpr(seed)));
    }
    if (hints != null) {
      throw new Error("_new_stream doesn't accept 'hints', got " + (rpr(hints)));
    }
    if (settings != null) {
      throw new Error("_new_stream doesn't accept 'settings', got " + (rpr(settings)));
    }
    return MSP.through.obj();
  };

  this._new_devnull_stream = function() {
    var pipeline, x;
    x = new Buffer("data\n");
    pipeline = [
      this.$((function(_this) {
        return function(data, send) {
          return send(x);
        };
      })(this)), this.new_stream('write', {
        path: '/dev/null'
      })
    ];
    return this.new_stream({
      pipeline: pipeline
    });
  };

  this._new_stream_from_path = function(path, hints, settings) {
    var encoding, expected, got, i, key, len, pipeline, ref, role, role_count, type, use_line_mode, x;
    if (!(type = (CND.type_of(path)) === 'text')) {
      throw new Error("expected path to be a text, got a " + type);
    }
    role = 'read';
    encoding = null;
    use_line_mode = null;
    pipeline = [];
    settings = Object.assign({}, settings);
    if (hints != null) {
      if (!CND.is_subset(hints, this._new_stream_from_path._hints)) {
        expected = ((function() {
          var i, len, ref, results;
          ref = this._new_stream_from_path._hints;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            x = ref[i];
            results.push(rpr(x));
          }
          return results;
        }).call(this)).join(', ');
        got = ((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = hints.length; i < len; i++) {
            x = hints[i];
            if (indexOf.call(this._new_stream_from_path._hints, x) < 0) {
              results.push(rpr(x));
            }
          }
          return results;
        }).call(this)).join(', ');
        throw new Error("expected 'hints' out of " + expected + ", got " + got);
      }
      use_line_mode = indexOf.call(hints, 'lines') >= 0;
      role_count = 0;
      if (indexOf.call(hints, 'read') >= 0) {
        role = 'read';
        role_count += +1;
      }
      if (indexOf.call(hints, 'write') >= 0) {
        role = 'write';
        role_count += +1;
      }
      if (indexOf.call(hints, 'append') >= 0) {
        role = 'append';
        role_count += +1;
      }
      if (role_count > 1) {
        throw new Error("can only specify one of `read`, `write` or `append`; got " + (rpr(hints)));
      }
    }
    if (hints != null) {
      ref = ['ascii', 'utf8', 'utf-8', 'ucs2', 'base64', 'binary', 'hex', 'buffer'];
      for (i = 0, len = ref.length; i < len; i++) {
        key = ref[i];
        if (indexOf.call(hints, key) >= 0) {
          if (encoding != null) {
            throw new Error("hints contain multiple encodings: " + (rpr(hints)));
          }
          encoding = key;
        }
      }
    }
    if (role === 'read') {
      if (use_line_mode) {
        pipeline.push((require('fs')).createReadStream(path, settings));
        pipeline.push(this.$split({
          encoding: encoding
        }));
      } else {
        if (settings['encoding'] == null) {
          settings['encoding'] = encoding === 'buffer' ? null : encoding;
        }
        pipeline.push((require('fs')).createReadStream(path, settings));
      }
    } else {
      if (role === 'append') {
        settings['flags'] = 'a';
      }
      if (encoding !== 'buffer') {
        if (settings['encoding'] == null) {
          settings['encoding'] = encoding;
        }
      }
      if (use_line_mode) {
        pipeline.push(this.$as_line());
      }
      pipeline.push(this.$bridge((require('fs')).createWriteStream(path, settings)));
    }
    return this.new_stream({
      pipeline: pipeline
    });
  };

  this._new_stream_from_path._hints = ['ascii', 'utf8', 'utf-8', 'ucs2', 'base64', 'binary', 'hex', 'buffer', 'read', 'write', 'append', 'lines'];

  this._new_stream_from_pipeline = function(pipeline, hints, settings) {

    /* Given a list of transforms (a.k.a. a 'pipeline'), return a stream that has all the transforms
    successively linked with `.pipe` calls; writing to the stream will write to the first transform, and
    reading from the stream will read from the last transform.
     */
    var ref, type;
    if (hints != null) {
      throw new Error("_new_stream_from_pipeline doesn't accept 'hints', got " + (rpr(hints)));
    }
    if (settings != null) {
      throw new Error("_new_stream_from_pipeline doesn't accept 'settings', got " + (rpr(settings)));
    }
    if ((type = CND.type_of(pipeline)) !== 'list') {
      throw new Error("expected a list, got a " + type);
    }

    /* The underlying implementation does not allow to get passed less than two streams, so we
    add pass-through transforms to satisfy it:
     */
    if (pipeline.length < 2) {
      pipeline = Object.assign([], pipeline);
      while (pipeline.length < 2) {
        if ((pipeline.length === 1) && (this.isa_readonly_stream(pipeline[0]))) {
          pipeline.push(this.$pass_through());
        } else {
          pipeline.unshift(this.$pass_through());
        }
      }
    }
    return (ref = MSP.pipeline).obj.apply(ref, pipeline);
  };

  this._new_stream_from_text = function(text, hints, settings) {

    /* Given a text, return a stream that has `text` written into it; as soon as you `.pipe` it to some
    other stream or transformer pipeline, those parts will get to read the text. Unlike PipeDreams v2, the
    returned stream will not have to been resumed explicitly.
     */
    var R, ref, type;
    if (hints != null) {
      throw new Error("_new_stream_from_text doesn't accept 'hints', got " + (rpr(hints)));
    }
    if (settings != null) {
      throw new Error("_new_stream_from_text doesn't accept 'settings', got " + (rpr(settings)));
    }
    if ((ref = (type = CND.type_of(text))) !== 'text' && ref !== 'buffer') {
      throw new Error("expected text or buffer, got a " + type);
    }
    R = this.new_stream();
    R.write(text);
    R.end();
    return R;
  };

  this._new_stream_from_url = function(url, hints, settings) {
    var HTTP, R, hostname, http_settings, pathname, protocol, request, url_parts;
    url_parts = (require('url')).parse(url);
    protocol = url_parts.protocol, hostname = url_parts.hostname, pathname = url_parts.pathname;
    if (pathname == null) {
      pathname = '/';
    }
    if (hostname == null) {
      hostname = 'localhost';
    }
    debug('8090', url_parts);
    if (!((protocol === 'http:' || protocol === 'https:') && (hostname.length > 0) && (pathname.length > 0))) {
      throw new Error("URL not supported: " + (JSON.stringify(url_parts)) + "\n" + (rpr(url)));
    }
    http_settings = {
      hostname: hostname,
      pathname: pathname,
      protocol: protocol,
      followAllRedirects: true
    };
    R = this.new_stream();
    HTTP = require(protocol === 'http:' ? 'http' : 'https');
    request = HTTP.request(http_settings, (function(_this) {
      return function(response) {
        var sink;
        sink = _this.new_stream('devnull');
        _this.on_finish(sink, function() {
          return _this.end(R);
        });
        response.pipe(_this.$(function(data, send) {
          _this.send(R, data);
          return send(data);
        })).pipe(sink);
        return null;
      };
    })(this));
    request.end();
    return R;
  };

  this._new_stream_from_transform = function(transform, hints, settings) {
    var expected, got, x;
    if (settings != null) {
      throw new Error("_new_stream_from_transform doesn't accept 'settings', got " + (rpr(settings)));
    }
    if (hints == null) {
      hints = [];
    }
    if (!CND.is_subset(hints, this._new_stream_from_transform._hints)) {
      expected = ((function() {
        var i, len, ref, results;
        ref = this.new_stream._hints;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          results.push(rpr(x));
        }
        return results;
      }).call(this)).join(', ');
      got = ((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = hints.length; i < len; i++) {
          x = hints[i];
          if (indexOf.call(this.new_stream._hints, x) < 0) {
            results.push(rpr(x));
          }
        }
        return results;
      }).call(this)).join(', ');
      throw new Error("expected 'hints' out of " + expected + ", got " + got);
    }
    if (indexOf.call(hints, 'async') >= 0) {
      return this.$async(transform);
    }
    return this.$(transform);
  };

  this._new_stream_from_transform._hints = ['async'];


  /* thx to German Attanasio http://stackoverflow.com/a/28564000/256361 */

  this.isa_stream = function(x) {
    return x instanceof (require('stream')).Stream;
  };

  this.isa_readable_stream = function(x) {
    return (this.isa_stream(x)) && x.readable;
  };

  this.isa_writable_stream = function(x) {
    return (this.isa_stream(x)) && x.writable;
  };

  this.isa_readonly_stream = function(x) {
    return (this.isa_stream(x)) && x.readable && !x.writable;
  };

  this.isa_writeonly_stream = function(x) {
    return (this.isa_stream(x)) && x.writable && !x.readable;
  };

  this.isa_duplex_stream = function(x) {
    return (this.isa_stream(x)) && x.readable && x.writable;
  };

  this.$pass_through = function() {
    return MSP.through.obj();
  };

  this.remit = this.$ = function(method) {
    return this._new_remit('sync', method);
  };

  this.remit_async = this.$async = function(method) {
    return this._new_remit('async', method);
  };

  this._new_remit = function(mode, method) {
    var arity, flush, get_send, has_error, main;
    arity = method.length;
    if (arity !== 1 && arity !== 2 && arity !== 3) {
      throw new Error("method with " + arity + " arguments not supported");
    }
    if (mode !== 'sync' && mode !== 'async') {
      throw new Error("unknown mode " + (rpr(mode)));
    }
    has_error = false;
    flush = null;
    if (arity === 1) {
      if (mode === 'async') {
        throw new Error("method with " + arity + " arguments not supported for async transforms");
      }
      main = function(chunk, encoding, callback) {
        method(chunk);
        return callback(null, chunk);
      };
      flush = function(callback) {
        method(null);
        return callback();
      };
      return MSP.through.obj(main, flush);
    }
    if (arity === 3) {
      flush = function(callback) {

        /* TAINT do we have to re-construct `send` on each call, or can we recycle the same function? */
        var end, send;
        send = get_send(this, callback);
        end = function() {
          if (!has_error) {
            callback();
          }
          return null;
        };
        method(null, send, end);
        return null;
      };
    }
    get_send = function(self, callback) {
      var R;
      R = function(data) {
        return self.push(data);
      };
      R.error = function(error) {
        has_error = true;
        return callback(error);
      };
      R.end = function() {
        return self.push(null);
      };
      if (mode === 'async') {
        R.done = function(data) {
          if (data === void 0) {
            return callback();
          } else {
            return callback(null, data);
          }
        };
      }
      return R;
    };
    main = function(chunk, encoding, callback) {

      /* TAINT do we have to re-construct `send` on each call, or can we recycle the same function? */
      var send;
      send = get_send(this, callback);
      method(chunk, send);
      if (mode === 'sync') {
        if (!has_error) {
          callback();
        }
      }
      return null;
    };
    return MSP.through.obj(main, flush);
  };

  this.send = function(me, data) {

    /* Given a stream and some data, send / write / push that data into the stream. */
    me.write(data);
    return me;
  };

  this.end = function(me) {

    /* Given a stream, end it. */
    me.end();
    return me;
  };

  this.$join = function(joiner) {
    if (joiner == null) {
      joiner = '\n';
    }

    /* Join all strings in the stream using a `joiner`, which defaults to newline, so `$join` is the inverse
    of `$split()`. The current version only supports strings, but buffers could conceivably be made to work as
    well.
     */
    return this.new_stream({
      pipeline: [
        this.$((function(_this) {
          return function(x) {
            var type;
            if ((type = CND.type_of(x)) !== 'text') {
              throw new Error("expected a text, got a " + type);
            }
          };
        })(this)), this.$collect(), this.$((function(_this) {
          return function(collection, send) {
            return send(collection.join(joiner));
          };
        })(this))
      ]
    });
    return null;
  };

  this.$split = function(settings) {

    /* TAINT should allow to specify splitter, encoding, keep binary format */
    var R, encoding, matcher, ref, ref1, split, type;
    split = require('binary-split');
    matcher = (ref = settings != null ? settings['matcher'] : void 0) != null ? ref : '\n';
    encoding = (ref1 = settings != null ? settings['encoding'] : void 0) != null ? ref1 : 'utf-8';
    if ((type = CND.type_of(matcher)) !== 'text') {
      throw new Error("expected a text, got a " + type);
    }
    R = split(matcher);
    if (encoding === 'buffer') {
      return R;
    }
    return this.new_stream({
      pipeline: [R, this.$decode(encoding)]
    });
  };

  this.$decode = function(encoding) {
    if (encoding == null) {
      encoding = 'utf-8';
    }
    return this.$((function(_this) {
      return function(data, send) {
        if (!Buffer.isBuffer(data)) {
          return send(data);
        }
        return send(data.toString(encoding));
      };
    })(this));
  };

  this.$sort = function(sorter, settings) {

    /* https://github.com/mziccard/node-timsort */
    var TIMSORT, arity, collect, collector, ref;
    TIMSORT = require('timsort');
    switch (arity = arguments.length) {
      case 0:
      case 2:
        null;
        break;
      case 1:
        if (!CND.isa_function(sorter)) {
          settings = sorter;
          sorter = null;
        }
        break;
      default:
        throw new Error("expected 0 to 2 arguments, got " + arity);
    }
    collector = [];
    collect = (ref = settings != null ? settings['collect'] : void 0) != null ? ref : false;
    if (sorter == null) {
      sorter = (function(_this) {
        return function(a, b) {
          if (a > b) {
            return +1;
          }
          if (a < b) {
            return -1;
          }
          return 0;
        };
      })(this);
    }
    return this.$((function(_this) {
      return function(data, send, end) {
        var i, len, x;
        if (data != null) {
          collector.push(data);
        }
        if (end != null) {
          TIMSORT.sort(collector, sorter);
          if (collect) {
            send(collector);
          } else {
            for (i = 0, len = collector.length; i < len; i++) {
              x = collector[i];
              send(x);
            }
            collector.length = 0;
          }
          return end();
        }
      };
    })(this));
  };

  this.$as_text = function(stringify) {

    /* Turn all data items into texts using `JSON.stringify` or a custom stringifier. `null` and any strings
    in the data stream is passed through unaffected. Observe that buffers in the stream will very probably not
    come out the way you'd expect them; this is because there's no way to know for the method what kind of
    data they represent.
    
    This method is handy to put as a safeguard right in front of a `.pipe output_file` clause to avoid
    `illegal non-buffer` issues.
     */
    if (stringify == null) {
      stringify = JSON.stringify;
    }
    return this.$(function(data, send) {
      if (data === null) {
        return send(null);
      }
      if (!CND.isa_text(data)) {
        return send(stringify(data));
      }
      return send(data);
    });
  };

  this.$as_line = function(stringify) {

    /* Like `$as_text`, but appends a newline to each chunk. */
    var pipeline;
    pipeline = [
      this.$as_text(stringify), this.$((function(_this) {
        return function(text, send) {
          return send(text + '\n');
        };
      })(this))
    ];
    return this.new_stream({
      pipeline: pipeline
    });
  };

  this.$parse_csv = function(options) {
    throw new Error("$parse_csv is on hold; investigating other libraries and extensibility");
  };

  this.$lockstep = function(input, settings) {

    /* Usage:
    
    ```coffee
    input_1
      .pipe D.$lockstep input_2 # or `.pipe D.$lockstep input_2, fallback: null`
      .pipe $ ( [ data_1, data_2, ], send ) =>
        ...
    ```
    
    `$lockstep` combines each piece of data coming down the stream with one piece of data emitted from the
    stream you passed in when calling the function. If the two streams turn out to have unequal lengths,
    an error is sent into the stream unless you called the function with an additional `fallback: value`
    argument.
     */

    /* TAINT re-write in a less low-level fashion */

    /* TAINT re-write to avoid buffering both streams */
    var _end_1, _end_2, _send, buffer_1, buffer_2, fallback, flush, has_ended, idx_1, idx_2;
    fallback = settings != null ? settings['fallback'] : void 0;
    idx_1 = 0;
    idx_2 = 0;
    buffer_1 = [];
    buffer_2 = [];
    _send = null;
    _end_1 = null;
    _end_2 = null;
    has_ended = false;
    flush = (function(_this) {
      return function() {
        var data_1, data_2, i, idx, ref;
        if (_send != null) {
          while ((buffer_1.length > 0) && (buffer_2.length > 0) && idx_1 === idx_2) {
            _send([buffer_1.shift(), buffer_2.shift()]);
            idx_1 += +1;
            idx_2 += +1;
          }
        }
        if ((_end_1 != null) && (_end_2 != null)) {
          if ((buffer_1.length > 0) || (buffer_2.length > 0)) {
            for (idx = i = 0, ref = Math.max(buffer_1.length, buffer_2.length); 0 <= ref ? i < ref : i > ref; idx = 0 <= ref ? ++i : --i) {
              data_1 = buffer_1[idx];
              data_2 = buffer_2[idx];
              if (data_1 === void 0 || data_2 === void 0) {
                if (fallback === void 0) {
                  return _send.error(new Error("streams of unequal lengths and no fallback value given"));
                }
                if (data_1 === void 0) {
                  data_1 = fallback;
                }
                if (data_2 === void 0) {
                  data_2 = fallback;
                }
              }
              _send([data_1, data_2]);
            }
          }
          _end_1();
          return _end_2();
        }
      };
    })(this);
    alert("must not use .on 'data' use .read(), see http://codewinds.com/blog/2013-08-04-nodejs-readable-streams.html");
    input.on('data', (function(_this) {
      return function(data_2) {
        buffer_2.push(data_2);
        return flush();
      };
    })(this));
    input.pipe(this.$on_end((function(_this) {
      return function(end) {
        _end_2 = end;
        return flush();
      };
    })(this)));
    return this.$((function(_this) {
      return function(data_1, send, end) {
        _send = send;
        if (data_1 != null) {
          buffer_1.push(data_1);
          flush();
        }
        if (end != null) {
          _end_1 = end;
          return flush();
        }
      };
    })(this));
  };

  this.$sample = function(p, options) {
    var count, headers, ref, ref1, rnd, seed;
    if (p == null) {
      p = 0.5;
    }

    /* Given a `0 <= p <= 1`, interpret `p` as the *p*robability to *p*ick a given record and otherwise toss
    it, so that `$sample 1` will keep all records, `$sample 0` will toss all records, and
    `$sample 0.5` (the default) will toss (on average) every other record.
    
    You can pipe several `$sample()` calls, reducing the data stream to 50% with each step. If you know
    your data set has, say, 1000 records, you can cut down to a random sample of 10 by piping the result of
    calling `$sample 1 / 1000 * 10` (or, of course, `$sample 0.01`).
    
    Tests have shown that a data file with 3'722'578 records (which didn't even fit into memory when parsed)
    could be perused in a matter of seconds with `$sample 1 / 1e4`, delivering a sample of around 370
    records. Because these records are randomly selected and because the process is so immensely sped up, it
    becomes possible to develop regular data processing as well as coping strategies for data-overload
    symptoms with much more ease as compared to a situation where small but realistic data sets are not
    available or have to be produced in an ad-hoc, non-random manner.
    
    **Parsing CSV**: There is a slight complication when your data is in a CSV-like format: in that case,
    there is, with `0 < p < 1`, a certain chance that the *first* line of a file is tossed, but some
    subsequent lines are kept. If you start to transform the text line into objects with named values later in
    the pipe (which makes sense, because you will typically want to thin out largeish streams as early on as
    feasible), the first line kept will be mis-interpreted as a header line (which must come first in CSV
    files) and cause all subsequent records to become weirdly malformed. To safeguard against this, use
    `$sample p, headers: true` (JS: `$sample( p, { headers: true } )`) in your code.
    
    **Predictable Samples**: Sometimes it is important to have randomly selected data where samples are
    constant across multiple runs:
    
    * once you have seen that a certain record appears on the screen log, you are certain it will be in the
      database, so you can write a snippet to check for this specific one;
    
    * you have implemented a new feature you want to test with an arbitrary subset of your data. You're
      still tweaking some parameters and want to see how those affect output and performance. A random
      sample that is different on each run would be a problem because the number of records and the sheer
      bytecount of the data may differ from run to run, so you wouldn't be sure which effects are due to
      which causes.
    
    To obtain predictable samples, use `$sample p, seed: 1234` (with a non-zero number of your choice);
    you will then get the exact same
    sample whenever you re-run your piping application with the same stream and the same seed. An interesting
    property of the predictable sample is that—everything else being the same—a sample with a smaller `p`
    will always be a subset of a sample with a bigger `p` and vice versa.
     */
    if (!((0 <= p && p <= 1))) {
      throw new Error("expected a number between 0 and 1, got " + (rpr(p)));
    }

    /* Handle trivial edge cases faster (hopefully): */
    if (p === 1) {
      return this.$((function(_this) {
        return function(record, send) {
          return send(record);
        };
      })(this));
    }
    if (p === 0) {
      return this.$((function(_this) {
        return function(record, send) {
          return null;
        };
      })(this));
    }
    headers = (ref = options != null ? options['headers'] : void 0) != null ? ref : false;
    seed = (ref1 = options != null ? options['seed'] : void 0) != null ? ref1 : null;
    count = 0;
    rnd = rnd_from_seed(seed);
    return this.$((function(_this) {
      return function(record, send) {
        count += 1;
        if ((count === 1 && headers) || rnd() < p) {
          return send(record);
        }
      };
    })(this));
  };

  this.$count = function(on_end) {
    var count;
    if (on_end == null) {
      on_end = null;
    }
    count = 0;
    return $(function(data, send, end) {
      if (data != null) {
        send(data);
        count += +1;
      }
      if (end != null) {
        if (on_end != null) {
          on_end(count, send);
        } else {
          send(count);
        }
        return end();
      }
    });
  };

  this.$collect = function(on_end) {
    var collector;
    if (on_end == null) {
      on_end = null;
    }
    collector = [];
    return this.$(function(data, send, end) {
      if (data != null) {
        collector.push(data);
      }
      if (end != null) {
        send(collector);
        return end();
      }
    });
  };

  this.$spread = function(settings) {
    var indexed, ref;
    indexed = (ref = settings != null ? settings['indexed'] : void 0) != null ? ref : false;
    return this.$((function(_this) {
      return function(data, send) {
        var i, idx, len, type, value;
        if (!(type = (CND.type_of(data)) === 'list')) {
          return send.error(new Error("expected a list, got a " + (rpr(type))));
        }
        for (idx = i = 0, len = data.length; i < len; idx = ++i) {
          value = data[idx];
          send(indexed ? [idx, value] : value);
        }
        return null;
      };
    })(this));
  };

  this.$batch = function(batch_size) {
    var buffer;
    if (batch_size == null) {
      batch_size = 1000;
    }
    if (batch_size < 0) {
      throw new Error("buffer size must be non-negative integer, got " + (rpr(batch_size)));
    }
    buffer = [];
    return this.$((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          buffer.push(data);
          if (buffer.length >= batch_size) {
            send(buffer);
            buffer = [];
          }
        }
        if (end != null) {
          if (buffer.length > 0) {
            send(buffer);
          }
          return end();
        }
      };
    })(this));
  };

  this.$on_end = function(method) {
    var arity, ref;
    if (!((0 <= (ref = (arity = method.length)) && ref <= 1))) {
      throw new Error("expected method with 0 or 1 argument, got " + arity);
    }
    return this.$(function(data, send, end) {
      send(data);
      if (end != null) {
        if (arity === 1) {
          return method(end);
        } else {
          method();
          return end();
        }
      }
    });
  };

  this.$on_start = function(method) {
    var is_first;
    is_first = true;
    return this.$(function(data, send) {
      if (is_first) {
        method(send);
      }
      is_first = false;
      return send(data);
    });
  };

  this.$on_first = function(method) {
    var arity, is_first;
    is_first = true;
    if ((arity = method.length) !== 2) {
      throw new Error("expected method with 2 arguments, got one with " + arity);
    }
    return this.$(function(data, send) {
      if (is_first) {
        method(data, send);
        return is_first = false;
      } else {
        return send(data);
      }
    });
  };

  this.on_finish = function(stream, handler) {
    return stream.on('finish', (function(_this) {
      return function() {
        return setImmediate(handler);
      };
    })(this));
  };

  this.$on_finish = function(method) {
    var R;
    R = this.new_stream();
    this.on_finish(R, method);
    return R;
  };

  this.$filter = function(method) {
    return this.$((function(_this) {
      return function(data, send) {
        if (method(data)) {
          return send(data);
        }
      };
    })(this));
  };

  this.$show = function(badge) {
    var my_show;
    if (badge == null) {
      badge = null;
    }
    my_show = CND.get_logger('info', badge != null ? badge : '*');
    return this.$((function(_this) {
      return function(record, send) {
        my_show(rpr(record));
        return send(record);
      };
    })(this));
  };

  this.$throttle_bytes = function(bytes_per_second) {
    return new (require('throttle'))(bytes_per_second);
  };

  this.$throttle_items = function(items_per_second) {
    var _send, buffer, count, emit, has_ended, idx, start, timer;
    buffer = [];
    count = 0;
    idx = 0;
    _send = null;
    timer = null;
    has_ended = false;
    emit = function() {
      var data;
      if ((data = buffer[idx]) !== void 0) {
        buffer[idx] = void 0;
        idx += +1;
        count += -1;
        _send(data);
      }
      if (has_ended && count < 1) {
        clearInterval(timer);
        _send.end();
        buffer = _send = timer = null;
      }
      return null;
    };
    start = function() {
      return timer = setInterval(emit, 1 / items_per_second * 1000);
    };
    return this.$((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          if (_send == null) {
            _send = send;
            start();
          }
          buffer.push(data);
          count += +1;
        }
        if (end != null) {
          return has_ended = true;
        }
      };
    })(this));
  };

  this.run = function(method, handler) {
    var domain;
    domain = (require('domain')).create();
    domain.on('error', function(error) {
      return handler(error);
    });
    setImmediate(function() {
      return domain.run(method);
    });
    return domain;
  };

  rnd_from_seed = function(seed) {

    /* TAINT use CND method */
    if (seed != null) {
      return CND.get_rnd(seed);
    } else {
      return Math.random;
    }
  };

  pluck = function(x, key) {

    /* TAINT use CND method */
    var R;
    R = x[key];
    delete x[key];
    return R;
  };

  this.$bridge = function(stream) {

    /* Make it so that the pipeline may be continued even below a writable but not readable stream.
    Conceivably, this method could have be named `tunnel` as well. Something to get you across, you get the
    meaning.
     */
    var arity;
    if ((arity = arguments.length) !== 1) {
      throw new Error("expected a single argument, got " + arity);
    }
    if (!this.isa_stream(stream)) {
      throw new Error("expected a stream, got a " + (CND.type_of(stream)));
    }
    if (!this.isa_writable_stream(stream)) {
      throw new Error("expected a writable stream");
    }
    return this.$((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          stream.write(data);
          send(data);
        }
        if (end != null) {
          stream.end();
          return end();
        }
      };
    })(this));
  };

  this.$split_tsv = (require('./transform-split-tsv')).$split_tsv;

  (function(PIPEDREAMS) {
    var i, key, len, ref, results, sub_key, value;
    ref = Object.keys(PIPEDREAMS);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      if (CND.isa_function(value = PIPEDREAMS[key])) {
        PIPEDREAMS[key] = value.bind(PIPEDREAMS);
        results.push((function() {
          var j, len1, ref1, results1;
          ref1 = Object.keys(value);
          results1 = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            sub_key = ref1[j];
            results1.push(PIPEDREAMS[key][sub_key] = value[sub_key]);
          }
          return results1;
        })());
      } else {
        results.push(PIPEDREAMS[key] = value);
      }
    }
    return results;
  })(this);

}).call(this);

//# sourceMappingURL=main.js.map
