// Generated by CoffeeScript 1.8.0
(function() {
  var BNP, ES, TRM, TYPES, alert, badge, debug, echo, help, info, log, rpr, through2, urge, warn, whisper,
    __slice = [].slice;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'PIPEDREAMS2';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);


  /* https://github.com/rvagg/through2 */

  through2 = require('through2');

  BNP = require('coffeenode-bitsnpieces');

  TYPES = require('coffeenode-types');


  /* https://github.com/dominictarr/event-stream */

  ES = require('event-stream');

  this.$split = ES.split.bind(ES);

  this.remit = function(method) {
    var arity, cache, get_send, on_data, on_end, send;
    send = null;
    cache = null;
    on_end = null;
    get_send = function(self) {
      var R;
      R = function(data) {
        return self.emit('data', data);
      };
      R.error = function(error) {
        return self.emit('error', error);
      };
      R.end = function() {
        return self.emit('end');
      };
      return R;
    };
    switch (arity = method.length) {
      case 2:
        on_data = function(data) {
          if (send == null) {
            send = get_send(this);
          }
          return method(data, send);
        };
        break;
      case 3:
        cache = [];
        on_data = function(data) {
          var _ref;
          if (cache.length === 0) {
            cache[0] = data;
            return;
          }
          if (send == null) {
            send = get_send(this);
          }
          _ref = [data, cache[0]], cache[0] = _ref[0], data = _ref[1];
          return method(data, send, null);
        };
        on_end = function() {
          var data, end;
          if (send == null) {
            send = get_send(this);
          }
          end = (function(_this) {
            return function() {
              return _this.emit('end');
            };
          })(this);
          if (cache.length === 0) {
            data = null;
          } else {
            data = cache[0];
            cache.length = 0;
          }
          return method(data, send, end);
        };
        break;
      default:
        throw new Error("expected a method with an arity of 2 or 3, got one with an arity of " + arity);
    }
    return ES.through(on_data, on_end);
  };

  this.$skip_first = function(n) {
    var count;
    if (n == null) {
      n = 1;
    }
    count = 0;
    return this.remit(function(data, send) {
      count += +1;
      if (count > n) {
        return send(data);
      }
    });
  };

  this.create_throughstream = function() {
    var P, R;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    R = through2.obj.apply(through2, P);
    R.setMaxListeners(0);
    return R;
  };

  this.$count = function(label, handler) {
    var count;
    if (handler == null) {
      handler = null;
    }
    count = 0;
    return this.remit((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          count += 1;
        }
        if (end == null) {
          return send.done(data);
        } else {
          if (handler != null) {
            handler(null, count);
          } else {
            info("encountered " + count + " " + label);
          }
          return end();
        }
      };
    })(this));
  };

  this.$dense_sort = function(key, first_idx, handler) {
    var buffer, buffer_event, buffer_size, event_count, key_is_function, max_buffer_size, min_legal_idx, previous_idx, send_buffered_events, sent_count, smallest_idx;
    if (key == null) {
      key = 1;
    }
    if (first_idx == null) {
      first_idx = 0;
    }
    if (handler == null) {
      handler = null;
    }

    /* Given a stream of `data` items with an index available as `data[ key ]`, re-emit data items in order
    such that indexes are ordered, and no items are left out. This is is called 'dense sort' as it presupposes
    that no single index is left out of the sequence, such that whenever an item with index `n` is seen, it
    can be passed on as soon as all items with index m < n have been seen and passed on. Conversely, any item
    whose predecessors have not yet been seen and passed on must be buffered. The method my be called as
    `$dense_sort k, n0`, where `k` is the key to pick up the index from each data item (defaulting to `1`,
    i.e. assuming an 'event list' whose first item is the index event name, the second is the index, and
    the rest represents the payload), and `n0` is the lowest index (defaulting to `0` as
    well).
    
    In contradistinction to 'agnostic' sorting (which must buffer all data until the stream has ended), the
    hope in a dense sort is that buffering will only ever occur over few data items which should hold as long
    as the stream originates from a source that emitted items in ascending order over a reasonably 'reliable'
    network (i.e. one that does not arbitrarily scramble the ordering of packages); however, it is always
    trivial to cause the buffering of *all* data items by withholding the first data item until all others
    have been sent; thus, the performance of this method cannot be guaranteed.
    
    To ensure data integrity, this method will throw an exception if the stream should end before all items
    between `n0` and the last seen index have been sent (i.e. in cases where the stream was expected to be
    dense, but turned out to be sparse), and when a duplicate index has been detected.
    
    You may pass in a `handler` that will be called after the entire stream has been processed; that function,
    if present, will be called with a pair `[ n, m, ]` where `n` is the total number of events encountered,
    and `m <= n` is the maximal number of elements that had to be buffered at any one single point in time.
    `m` will equal `n` if the logically first item happened to arrive last (and corresponds to the number of
    items that have to be buffered with 'sparse', agnostic sorting); `m` will be zero if all items happened
    to arrive in their logical order (the optimal case).
     */
    key_is_function = TYPES.isa_function(key);
    buffer = [];

    /* Amount of buffered items: */
    buffer_size = 0;

    /* Index of most recently sent item: */
    previous_idx = first_idx - 1;

    /* Index of first item in buffer: */
    smallest_idx = Infinity;

    /* 'Backlog' of the range of indexes that have already been sent out: */
    min_legal_idx = 0;
    max_buffer_size = 0;
    event_count = 0;
    sent_count = 0;
    buffer_event = (function(_this) {
      return function(idx, event) {
        smallest_idx = Math.min(smallest_idx, idx);
        buffer[idx] = event;
        buffer_size += +1;
        return null;
      };
    })(this);
    send_buffered_events = (function(_this) {
      return function(send) {

        /* Refuse to send anything unless all events with smaller indexes have already been sent: */
        var event, _results;
        if (sent_count < (smallest_idx - first_idx)) {
          return;
        }
        _results = [];
        while (true) {

          /* Terminate loop in case nothing is in the buffer or we have reached an empty position: */
          if (buffer_size < 1 || ((event = buffer[smallest_idx]) == null)) {
            min_legal_idx = smallest_idx;
            break;
          }

          /* Remove event to be sent from buffer (making it a sparse list in most cases), adjust sentinels and
          send event:
           */
          delete buffer[smallest_idx];
          previous_idx = smallest_idx;
          max_buffer_size = Math.max(max_buffer_size, buffer_size);
          smallest_idx += +1;
          buffer_size += -1;
          sent_count += +1;
          _results.push(send(event));
        }
        return _results;
      };
    })(this);
    return this.remit((function(_this) {
      return function(event, send, end) {
        var idx;
        if (event != null) {
          event_count += +1;
          idx = key_is_function ? key(event) : event[key];
          if (idx < min_legal_idx) {
            return send.error(new Error("duplicate index " + (rpr(idx))));
          }
          if (buffer_size === 0 && idx === previous_idx + 1) {

            /* In case no items are in the buffer and the current index is the one after the previous index, we
            can send on the event immediately:
             */
            previous_idx = idx;
            sent_count += +1;
            send(event);
          } else {

            /* Otherwise, we put the event into the buffer under its index; should the position in the buffer
            not be vacant, we emit an error. Afterwards, we try to emit as many events from the buffer as
            possible:
             */
            if (buffer[idx] != null) {
              return send.error(new Error("duplicate index " + (rpr(idx))));
            }
            buffer_event(idx, event);
            send_buffered_events(send);
          }
        }
        if (end != null) {

          /* Lastly, let's emit all remaining events in the buffer; should there be any elements left, we issue
          an error:
           */
          send_buffered_events(send);
          if (buffer_size > 0) {
            warn(buffer);
          }
          if (buffer_size > 0) {
            send.error(new Error("detected missing events"));
          }
          if (handler != null) {
            handler([event_count, max_buffer_size]);
          }
          return end();
        }
      };
    })(this));
  };

  this.$collect = function() {
    var collector;
    collector = [];
    return this.remit((function(_this) {
      return function(event, send, end) {
        if (event != null) {
          collector.push(event);
        }
        if (end != null) {
          send(collector);
          return end();
        }
      };
    })(this));
  };

  this.$show = function(badge) {
    var my_show;
    if (badge == null) {
      badge = null;
    }
    my_show = TRM.get_logger('info', badge != null ? badge : '*');
    return this.remit((function(_this) {
      return function(record, send) {
        my_show(rpr(record));
        return send(record);
      };
    })(this));
  };

}).call(this);
