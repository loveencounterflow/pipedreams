// Generated by CoffeeScript 1.9.0
(function() {
  var $, CND, DS, ES, LODASH, LineBreaker, PIPEDREAMS, alert, badge, debug, echo, help, info, log, rpr, through2, urge, warn, whisper,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS2';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);


  /* https://github.com/rvagg/through2 */

  through2 = require('through2');


  /* https://github.com/dominictarr/event-stream */

  ES = require('event-stream');


  /* https://github.com/dominictarr/sort-stream */

  this.$sort = require('sort-stream');

  this.new_densort = (DS = require('./densort')).new_densort.bind(DS);

  PIPEDREAMS = this;

  LODASH = require('lodash');

  LineBreaker = require('linebreak');

  this.$split = ES.split.bind(ES);

  this.remit = function(method) {
    var arity, get_send, on_data, on_end, send;
    send = null;
    on_end = null;
    get_send = function(self) {
      var R;
      R = function(data) {
        return self.emit('data', data);
      };
      R.error = function(error) {
        return self.emit('error', error);
      };
      R.end = function() {
        return self.emit('end');
      };
      R.pause = function() {
        return self.pause();
      };
      R.resume = function() {
        return self.resume();
      };
      R.read = function() {
        return self.read();
      };
      R.stream = self;
      return R;
    };
    on_data = function(data) {
      if (send == null) {
        send = get_send(this);
      }
      return method(data, send);
    };
    switch (arity = method.length) {
      case 2:
        null;
        break;
      case 3:
        on_end = function() {
          var end;
          if (send == null) {
            send = get_send(this);
          }
          end = (function(_this) {
            return function() {
              return _this.emit('end');
            };
          })(this);
          return method(void 0, send, end);
        };
        break;
      default:
        throw new Error("expected a method with an arity of 2 or 3, got one with an arity of " + arity);
    }
    return ES.through(on_data, on_end);
  };

  $ = this.remit.bind(this);

  this.$skip_first = function(n) {
    var count;
    if (n == null) {
      n = 1;
    }
    count = 0;
    return $(function(data, send) {
      count += +1;
      if (count > n) {
        return send(data);
      }
    });
  };

  this.create_throughstream = function() {
    var P, R;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    R = through2.obj.apply(through2, P);
    R.setMaxListeners(0);
    return R;
  };

  this.$sub = function(sub_transformer) {
    var cache, sink, source, state, _end, _send;
    _send = null;
    _end = null;
    cache = void 0;
    source = this.create_throughstream();
    sink = this.create_throughstream();
    state = {};
    source.ended = false;
    sub_transformer(source, sink, state);
    sink.on('data', (function(_this) {
      return function(data) {
        return _send(data);
      };
    })(this));
    sink.on('end', (function(_this) {
      return function() {
        return _send.end();
      };
    })(this));
    return $((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          _send = send;
          if (cache === void 0) {
            cache = data;
          } else {
            source.write(cache);
            cache = data;
          }
        }
        if (end != null) {
          source.ended = true;
          if (cache !== void 0) {
            return source.write(cache);
          }
        }
      };
    })(this));
  };

  this.$densort = function(key, first_idx, report_handler) {
    var ds, has_ended, send_data, signal_end;
    if (key == null) {
      key = 1;
    }
    if (first_idx == null) {
      first_idx = 0;
    }
    if (report_handler == null) {
      report_handler = null;
    }
    ds = this.new_densort(key, first_idx, report_handler);
    has_ended = false;
    send_data = (function(_this) {
      return function(send, data) {};
    })(this);
    signal_end = (function(_this) {
      return function(send) {
        if (!has_ended) {
          send.end();
        }
        return has_ended = true;
      };
    })(this);
    return $((function(_this) {
      return function(input_data, send, end) {
        if (input_data != null) {
          ds(input_data, function(error, output_data) {
            if (error != null) {
              return send.error(error);
            }
            return send(output_data);
          });
        }
        if (end != null) {
          return ds(null, function(error, output_data) {
            if (error != null) {
              return send.error(error);
            }
            if (output_data != null) {
              return send(output_data);
            } else {
              return signal_end(send);
            }
          });
        }
      };
    })(this));
  };

  this.$aggregate = function(aggregator, on_end) {
    var Z;
    if (on_end == null) {
      on_end = null;
    }
    Z = null;
    return $((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          Z = aggregator(data);
          if (on_end != null) {
            send(data);
          }
        }
        if (end != null) {
          if (on_end != null) {
            on_end(Z);
          } else {
            send(Z);
          }
          return end();
        }
      };
    })(this));
  };

  this.$count = function(on_end) {
    var count;
    if (on_end == null) {
      on_end = null;
    }
    count = 0;
    return this.$aggregate((function() {
      return count += +1;
    }), on_end);
  };

  this.$collect = function(on_end) {
    var aggregator, collector;
    if (on_end == null) {
      on_end = null;
    }
    collector = [];
    aggregator = function(data) {
      collector.push(data);
      return collector;
    };
    return this.$aggregate(aggregator, on_end);
  };

  this.$spread = function(settings) {
    var end, indexed, _ref, _ref1;
    indexed = (_ref = settings != null ? settings['indexed'] : void 0) != null ? _ref : false;
    end = (_ref1 = settings != null ? settings['end'] : void 0) != null ? _ref1 : false;
    return $((function(_this) {
      return function(data, send) {
        var idx, type, value, _i, _len;
        if (!(type = (CND.type_of(data)) === 'list')) {
          return send.error(new Error("expected a list, got a " + (rpr(type))));
        }
        for (idx = _i = 0, _len = data.length; _i < _len; idx = ++_i) {
          value = data[idx];
          send(indexed ? [idx, value] : value);
        }
        if (end) {
          return send(null);
        }
      };
    })(this));
  };

  this.$signal_end = function(signal) {
    var on_data, on_end;
    if (signal == null) {
      signal = this.eos;
    }

    /* Given an optional `signal` (which defaults to `null`), return a stream transformer that emits
    `signal` as last value in the stream. Observe that whatever value you choose for `signal`, that value
    should be gracefully handled by any transformers that follow in the pipe.
     */
    on_data = null;
    on_end = function() {
      this.emit('data', signal);
      return this.emit('end');
    };
    return ES.through(on_data, on_end);
  };

  this.$on_end = function(method) {
    return $(function(data, send, end) {
      if (data != null) {
        send(data);
      }
      if (end != null) {
        return method(send, end);
      }
    });
  };

  this.$on_start = function(method) {
    var is_first;
    is_first = true;
    return $(function(data, send) {
      if (is_first) {
        method(send);
      }
      is_first = false;
      return send(data);
    });
  };

  this.$filter = function(select) {
    return $((function(_this) {
      return function(event, send) {
        if (select(event)) {
          return send(event);
        }
      };
    })(this));
  };

  this.$show = function(badge) {
    var my_show;
    if (badge == null) {
      badge = null;
    }
    my_show = CND.get_logger('info', badge != null ? badge : '*');
    return $((function(_this) {
      return function(record, send) {
        my_show(rpr(record));
        return send(record);
      };
    })(this));
  };

  this.$continue = function(stream) {
    return $((function(_this) {
      return function(data, send, end) {
        stream.write(data);
        if (end != null) {
          stream.end();
          return end();
        }
      };
    })(this));
  };

  this.$link = function() {
    var sink, source, transform, transforms, _i, _len, _ref, _send;
    transforms = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (transforms.length === 0) {
      return this.create_throughstream();
    }
    source = sink = this.create_throughstream();
    _ref = LODASH.flatten(transforms);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      transform = _ref[_i];
      sink = sink.pipe(transform);
    }
    _send = null;
    sink.on('data', (function(_this) {
      return function(data) {
        return _send(data);
      };
    })(this));
    return $((function(_this) {
      return function(data, send) {
        _send = send;
        return source.write(data);
      };
    })(this));
  };

  this.new_hyphenate = function(hyphenation, min_length) {
    var HYPHER, Hypher;
    if (hyphenation == null) {
      hyphenation = null;
    }
    if (min_length == null) {
      min_length = 4;
    }

    /* https://github.com/bramstein/hypher */
    Hypher = require('hypher');
    if (hyphenation == null) {
      hyphenation = require('hyphenation.en-us');
    }
    HYPHER = new Hypher(hyphenation);
    return HYPHER.hyphenateText.bind(HYPHER);
  };

  this.$hyphenate = function(hyphenation, min_length) {
    var hyphenate;
    if (hyphenation == null) {
      hyphenation = null;
    }
    if (min_length == null) {
      min_length = 4;
    }
    hyphenate = this.new_hyphenate(hyphenation, min_length);
    return $((function(_this) {
      return function(text, send) {
        return send(hyphenate(text, min_length));
      };
    })(this));
  };

  this.break_lines = function(text, settings) {
    var R, breakpoint, extended, incremental, last_position, line_breaker, part, position, required, _ref, _ref1;
    text = text.replace(/\n/g, ' ');
    last_position = null;
    incremental = (_ref = settings != null ? settings['incremental'] : void 0) != null ? _ref : true;
    extended = (_ref1 = settings != null ? settings['extended'] : void 0) != null ? _ref1 : false;
    line_breaker = new LineBreaker(text);
    R = [];
    while (breakpoint = line_breaker.nextBreak()) {
      position = breakpoint.position, required = breakpoint.required;
      if (incremental && (last_position != null)) {
        part = text.slice(last_position, breakpoint.position);
      } else {
        part = text.slice(0, breakpoint.position);
      }
      last_position = position;
      R.push(extended ? [part, required, position] : part);
    }
    return R;
  };

  this.$break_lines = function(settings) {
    return $((function(_this) {
      return function(text, send) {
        return send(_this.break_lines(text, settings));
      };
    })(this));
  };

  this.HTML = {};

  this.HTML._new_parser = function(settings, stream) {

    /* NB.: Will not send empty text nodes; will not join ('normalize') adjacent text nodes. */
    var Htmlparser, handlers, lone_tags;
    lone_tags = "area base br col command embed hr img input keygen link meta param\nsource track wbr".split(/\s+/);
    handlers = {
      onopentag: function(name, attributes) {
        if (__indexOf.call(lone_tags, name) >= 0) {
          if (name === 'wbr') {
            if ((Object.keys(attributes)).length > 0) {
              throw new Error("illegal <wbr> tag with attributes");
            }

            /* as per https://developer.mozilla.org/en/docs/Web/HTML/Element/wbr */
            return stream.write(['text', '\u200b']);
          } else {
            return stream.write(['lone-tag', name, attributes]);
          }
        } else {
          return stream.write(['open-tag', name, attributes]);
        }
      },
      onclosetag: function(name) {
        if (__indexOf.call(lone_tags, name) < 0) {
          return stream.write(['close-tag', name]);
        }
      },
      ontext: function(text) {
        return stream.write(['text', CND.escape_html(text)]);
      },
      onend: function() {
        stream.write(['end']);
        return stream.end();
      },
      onerror: function(error) {
        throw error;
      }
    };
    Htmlparser = (require('htmlparser2')).Parser;
    return new Htmlparser(handlers, settings);
  };

  this.HTML.$parse = function() {
    var html_parser, settings, stream, _send;
    settings = {
      decodeEntities: true
    };
    stream = PIPEDREAMS.create_throughstream();
    html_parser = this._new_parser(settings, stream);
    _send = null;
    stream.on('data', function(data) {
      return _send(data);
    });
    stream.on('end', function() {
      return _send.end();
    });
    return $((function(_this) {
      return function(source, send, end) {
        _send = send;
        if (source != null) {
          html_parser.write(source);
        }
        if (end != null) {
          return html_parser.end();
        }
      };
    })(this));
  };

  this.HTML.$collect_closing_tags = function() {

    /* Keeps trace of all opened tags and adds a list to each event that speels out the names of tags to be
    closed at that point; that list anticipates all the `close-tag` events that are due to arrive later in the
    stream.
     */
    var pending_tag_buffer;
    pending_tag_buffer = [];
    return $(function(event, send) {
      var tail, type;
      type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
      if (type === 'open-tag') {
        pending_tag_buffer.unshift(tail[0][0]);
      } else if (type === 'close-tag') {
        pending_tag_buffer.shift();
      }
      if (type !== 'end') {
        event.push(pending_tag_buffer.slice(0));
      }
      return send(event);
    });
  };

  this.HTML.$collect_texts = function() {
    var send_buffer, text_buffer, _send;
    text_buffer = [];
    _send = null;
    send_buffer = function() {
      if (text_buffer.length > 0) {
        _send(['text', text_buffer.join('')]);
        return text_buffer.length = 0;
      }
    };
    return $(function(event, send) {
      var tail, type;
      _send = send;
      type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
      if (type === 'text') {
        return text_buffer.push(tail[0]);
      } else {
        send_buffer();
        return send(event);
      }
    });
  };

  this.HTML.$disperse_texts = function(hyphenation) {
    var hyphenate;
    if (hyphenation === false) {
      hyphenate = (function(_this) {
        return function(text) {
          return text;
        };
      })(this);
    } else if (CND.isa_function(hyphenation)) {
      hyphenate = hyphenation;
    } else {
      hyphenation = hyphenation === true ? null : hyphenation;
      hyphenate = PIPEDREAMS.new_hyphenate(hyphenation);
    }
    return $((function(_this) {
      return function(event, send) {
        var tail, text_part, type, _i, _len, _ref, _results;
        type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
        if (type === 'text') {
          _ref = PIPEDREAMS.break_lines(hyphenate(tail[0]));
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            text_part = _ref[_i];
            _results.push(send(['text', text_part]));
          }
          return _results;
        } else {
          return send(event);
        }
      };
    })(this));
  };

  this.$throttle_bytes = function(bytes_per_second) {
    var Throttle;
    Throttle = require('throttle');
    return new Throttle(bytes_per_second);
  };

  this.$throttle_items = function(items_per_second) {
    var buffer, count, emit, has_ended, idx, start, timer, _send;
    buffer = [];
    count = 0;
    idx = 0;
    _send = null;
    timer = null;
    has_ended = false;
    emit = function() {
      var data;
      if ((data = buffer[idx]) !== void 0) {
        buffer[idx] = void 0;
        idx += +1;
        count += -1;
        _send(data);
      }
      if (has_ended && count < 1) {
        clearInterval(timer);
        _send.end();
        buffer = _send = timer = null;
      }
      return null;
    };
    start = function() {
      return timer = setInterval(emit, 1 / items_per_second * 1000);
    };
    return $((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          if (_send == null) {
            _send = send;
            start();
          }
          buffer.push(data);
          count += +1;
        }
        if (end != null) {
          return has_ended = true;
        }
      };
    })(this));
  };

}).call(this);
