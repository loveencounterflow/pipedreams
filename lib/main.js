// Generated by CoffeeScript 1.8.0
(function() {
  var TRM, alert, badge, debug, echo, help, info, log, rpr, through2, urge, warn, whisper;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'PIPEDREAMS2';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);


  /* https://github.com/rvagg/through2 */

  through2 = require('through2');

  this.remit = function(method) {
    var arity, get_send, on_data, on_end, send, _ref;
    send = null;
    on_end = null;
    if (!((2 <= (_ref = (arity = method.length)) && _ref <= 3))) {
      throw new Error("expected a method with an arity of 2 or 3, got one with an arity of " + arity);
    }
    get_send = function(self, encoding, done) {
      var P2_send_method;
      P2_send_method = function(data) {
        return done(new Error("Pipedreams v2 API changed; use `send.one` or `send.done`"));
      };
      P2_send_method.one = function(data) {
        return self.push(data);
      };
      P2_send_method.done = function(data) {
        if (data != null) {
          self.push(data);
        }
        return done();
      };
      P2_send_method.error = function(error) {
        return done(error);
      };
      P2_send_method.pause = function() {
        return self.pause();
      };
      P2_send_method.resume = function() {
        return self.resume();
      };

      /* TAINT it's presently not quite clear whether using the advisory `@emit 'end'` or else the
        prescriptive `@end()` is the better way to tell the stream we've finished; until i find out,
        we add one more method, `send.finish()` that uses `@end` instead of emitting an event.
       */
      P2_send_method.end = function() {
        return self.emit('end');
      };
      P2_send_method.finish = function() {
        return self.end();
      };
      P2_send_method.encoding = encoding;
      return P2_send_method;
    };
    on_data = function(data, encoding, done) {
      if (send == null) {
        send = get_send(this, encoding, done);
      }
      return method(data, send, null);
    };
    if (arity === 3) {
      on_end = function(done) {
        send = get_send(this, null, done);
        return method(null, null, send.end);
      };
    }

    /* TAINT no way to use byte / text streaming? necessary? */
    return through2.obj(on_data, on_end);
  };

  this.create_throughstream = function() {
    var R;
    R = through2.obj();
    R.setMaxListeners(0);
    return R;
  };

  this.$count = function(label, handler) {
    var count;
    if (handler == null) {
      handler = null;
    }
    count = 0;
    return this.remit((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          count += 1;
        }
        if (end == null) {
          return send.done(data);
        } else {
          if (handler != null) {
            handler(null, count);
          } else {
            info("encountered " + count + " " + label);
          }
          return end();
        }
      };
    })(this));
  };

  this.$show = function(badge) {
    var show;
    if (badge == null) {
      badge = null;
    }
    if (badge != null) {
      show = TRM.get_logger('info', badge);
    } else {
      show = info;
    }
    return this.remit((function(_this) {
      return function(record, send) {
        show(rpr(record));
        return send.done(record);
      };
    })(this));
  };

  this.$sink = function() {

    /* TAINT not sure whether this is needed, but i found cases where pipelines without an all-accepting
      last member wouldn't run properly. Try `.pipe P2.$sink()` in cases where pipelines stop transporting
      data early. This method may be a temporary fix.
     */
    return (require('fs')).createWriteStream('/dev/null');
  };

}).call(this);
