// Generated by CoffeeScript 1.10.0
(function() {
  var CND, alert, badge, debug, echo, help, info, insp, log, rpr, urge, warn, whisper,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  insp = (require('util')).inspect;

  this.σ_null = Symbol["for"]('null');

  this.σ_pass = Symbol["for"]('pass');

  this.σ_drop = Symbol["for"]('drop');


  /*
  
  **Note** Conventions:
  
  * Never call a stream/transform-producing 3rd party API from an arbitrary place in this or affiliate
    modules, but to always route such calls through a proxy method to be collected in the space below;
  
  * Issue `require` 3rd party libraries in a 'lazy' fashion / on-demand (i.e. on API-method call time, not on
    module load time);
  
  * Wrap all stream/transform creation calls so that printing of shorthand descriptions of pipelines becomes
    feasible. Printouts of unwrapped stream objects can extend over hundreds of lines and are nearly
    impossible to digest properly (in the future, a more sophisticated solution may be implemented, but even
    then and until such time, the wrapping is not going to hurt either).
   */

  this._new_stream$read_from_file = function(path, settings) {
    var R;
    R = (require('fs')).createReadStream(path, settings);
    return this._rpr("*🖹 △", "*FS-read", rpr(path), R);
  };

  this._new_stream$write_to_file = function(path, settings) {
    var R;
    R = (require('fs')).createWriteStream(path, settings);
    return this._rpr("*🖹 ▼", "*FS-write", rpr(path), R);
  };

  this._new_stream$append_to_file = function(path, settings) {
    var R, ref;
    settings['flags'] = ((ref = settings['flags']) != null ? ref : '') + 'a';
    R = (require('fs')).createWriteStream(path, settings);
    return this._rpr("*🖹 ⏬", "*FS-append", rpr(path), R);
  };

  this._new_stream$split_buffer = function(matcher) {
    var R;
    R = (require('binary-split'))(matcher);
    return this._rpr("*✀", "*split", rpr(matcher), R);
  };

  this._new_stream$through = function() {
    var P, R, ref;
    P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    R = (ref = require('through2')).obj.apply(ref, P);
    return this._rpr("*⦵", "*through", null, R);
  };

  this._duplex$duplexer2 = function(receiver, sender) {
    var R;
    R = (require('duplexer2'))({
      objectMode: true
    }, receiver, sender);
    return this._rpr("*↹", "*duplex", (rpr(receiver)) + (rpr(sender)), R);
    return R;
  };

  this._new_stream$pump = function(pipeline, handler) {
    var R;
    R = (require('pump')).apply(null, slice.call(pipeline).concat([handler]));
    return this._rpr("*❡", "*pump", null, R);
    return R;
  };

  this._new_stream$throttle_bytes = function(bytes_per_second) {
    return new (require('throttle'))(bytes_per_second);
  };

  this.NULL = Symbol["for"]('null');

  this._rpr = function(symbol, name, extra, stream) {
    var arity;
    if ((arity = arguments.length) !== 4) {
      throw new Error("expected 4 arguments, got " + arity);
    }
    return this._rprx('(', symbol, name, extra, ')', stream);
  };

  this._rprx = function(start, symbol, name, extra, stop, stream) {
    var _brackets, _extra, _name, _sub, _symbols, arity, gl, parts, show_names, show_subs, sub_inspect;
    if ((arity = arguments.length) !== 6) {
      throw new Error("expected 6 arguments, got " + arity);
    }
    _symbols = CND.yellow;
    gl = CND.gold;
    _name = CND.grey;
    _brackets = CND.white;
    _sub = CND.crimson;
    _extra = CND.orange;
    sub_inspect = stream.inspect;
    show_subs = true;
    show_names = true;
    parts = [];
    parts.push(_brackets(start));
    parts.push(' ');
    if (symbol != null) {
      parts.push(_symbols(symbol));
    }
    if (symbol != null) {
      parts.push(' ');
    }
    if (show_names) {
      parts.push(_name(name));
    }
    if (show_names) {
      parts.push(' ');
    }
    if (extra != null) {
      parts.push(_extra(extra));
    }
    if (extra != null) {
      parts.push(' ');
    }
    if (show_subs && (sub_inspect != null)) {
      parts.push(_sub(' {='));
    }
    if (show_subs && (sub_inspect != null)) {
      parts.push(sub_inspect());
    }
    if (show_subs && (sub_inspect != null)) {
      parts.push(_sub('=} '));
    }
    parts.push(_brackets(stop));
    stream.inspect = function() {
      return parts.join('');
    };
    return stream;
  };

  this.new_stream = function() {
    var P, R, hints, kind, ref, seed, settings;
    P = 1 <= arguments.length ? slice.call(arguments, 0) : [];

    /*
    @new_stream._read_arguments_2 P
     */
    ref = this.new_stream._read_arguments(P), kind = ref[0], seed = ref[1], hints = ref[2], settings = ref[3];
    R = (function() {
      switch (kind) {
        case '*plain':
          return this._new_stream(seed, hints, settings);
        case 'file':
        case 'path':
          return this._new_stream_from_path(seed, hints, settings);
        case 'pipeline':
          return this._new_stream_from_pipeline(seed, hints, settings);
        case 'text':
          return this._new_stream_from_text(seed, hints, settings);
        case 'url':
          return this._new_stream_from_url(seed, hints, settings);
        case 'transform':
          return this._new_stream_from_transform(seed, hints, settings);
        case 'duplex':
          return this._new_stream_from_duplex(seed, hints, settings);
        default:
          throw new Error("unknown kind " + (rpr(kind)) + " (shouldn't happen)");
      }
    }).call(this);
    return R;
  };


  /*
  #-----------------------------------------------------------------------------------------------------------
  @new_stream._read_arguments_2 = ( P ) =>
    R =
      flags:        []
      kind:         null
      seed:         null
      settings:     {}
    #.....................................................................................................
     * ultimate_idx    = P.length - 1
     * penultimate_idx = ultimate_idx - 1
    flags_over      = no
    #.....................................................................................................
    for p, idx in P
      if CND.isa_text p
        if flags_over
          throw new Error "detected flag at illegal position in call signature #{rpr P}"
        R.flags.push p
      else
        flags_over = yes
        unless R.kind?
          for kind, seed of p
            if R.kind?
              throw new Error "can't have more than single key in kind selector object, got #{rpr P}"
            unless kind in @new_stream._kinds
              expected  = ( rpr x for x in @new_stream._kinds ).join ', '
              got       =   rpr kind
              throw new Error "expected a 'kind' out of #{expected}, got #{got}"
            R.kind  = kind
            R.seed  = seed
        else
          R.settings = Object.assign {}, P[ idx .. ]...
    #.....................................................................................................
    R.kind ?= 'through'
    #.....................................................................................................
    rprd = ( x ) -> insp x, depth: 1
     * echo '3345', ( CND.white rprd P ), ( CND.grey '=>' ), ( CND.lime rprd R )
     * debug '3345', ( CND.yellow ( require 'util' ).inspect P, depth: 0 )#, ( CND.grey '=>' ), ( CND.lime R )
    #.....................................................................................................
    return R
   */

  this.new_stream._read_arguments = (function(_this) {
    return function(P) {
      var expected, got, hints, kind, kind_and_seed, kind_count, seed, settings, x;
      kind_and_seed = null;
      settings = null;
      kind = null;
      seed = null;
      hints = null;
      if (P.length > 0) {
        if (P.length > 1) {
          if (!CND.isa_text(P[P.length - 1])) {
            kind_and_seed = P.pop();
          }
        }
        if (!CND.isa_text(P[P.length - 1])) {
          settings = kind_and_seed;
          kind_and_seed = P.pop();
        }
      }
      hints = P;
      if (kind_and_seed == null) {
        kind = '*plain';
      } else {
        if ((kind_count = (Object.keys(kind_and_seed)).length) !== 1) {
          throw new Error("expected 0 or 1 'kind', got " + kind_count);
        }
        for (kind in kind_and_seed) {
          seed = kind_and_seed[kind];
          break;
        }
      }
      if (indexOf.call(_this.new_stream._kinds, kind) < 0) {
        expected = ((function() {
          var i, len, ref, results;
          ref = this.new_stream._kinds;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            x = ref[i];
            results.push(rpr(x));
          }
          return results;
        }).call(_this)).join(', ');
        got = rpr(kind);
        throw new Error("expected a 'kind' out of " + expected + ", got " + got);
      }
      if (hints.length === 0) {
        hints = null;
      }
      return [kind, seed, hints, settings];
    };
  })(this);

  this.new_stream._kinds = ['*plain', 'file', 'path', 'pipeline', 'text', 'url', 'transform', 'duplex'];

  this._new_stream = function(seed, hints, settings) {
    if ((seed == null) && (settings == null) && (hints != null) && (hints.length === 1) && indexOf.call(hints, 'devnull') >= 0) {
      return this._new_devnull_stream();
    }
    if (seed != null) {
      throw new Error("_new_stream doesn't accept 'seed', got " + (rpr(seed)));
    }
    if (hints != null) {
      throw new Error("_new_stream doesn't accept 'hints', got " + (rpr(hints)));
    }
    if (settings != null) {
      throw new Error("_new_stream doesn't accept 'settings', got " + (rpr(settings)));
    }
    return this._rpr("#", "plain", null, this._new_stream$through());
  };

  this._new_devnull_stream = function() {
    var R, pipeline, plug, x;
    x = new Buffer("devnull\n");
    plug = this.new_stream();
    pipeline = [
      this.$((function(_this) {
        return function(data, send) {
          send(x);
          return _this.send(plug, data);
        };
      })(this)), this.new_stream('write', {
        file: '/dev/null'
      }), this.$((function(_this) {
        return function(data, send) {
          return null;
        };
      })(this)), plug
    ];
    R = this.new_stream({
      pipeline: pipeline
    });
    return this._rpr("⏚", "devnull", null, R);
  };

  this._new_stream_from_path = function(path, hints, settings) {
    var R, _encoding, encoding, extra, i, key, len, pipeline, ref, role, role_count, type, use_line_mode;
    if (!(type = (CND.type_of(path)) === 'text')) {
      throw new Error("expected path to be a text, got a " + type);
    }
    role = 'read';
    encoding = null;
    use_line_mode = null;
    pipeline = [];
    settings = Object.assign({}, settings);
    if (hints != null) {
      this._validate_keys("_new_stream_from_path", "one of", hints, this._new_stream_from_path._hints);
      use_line_mode = indexOf.call(hints, 'lines') >= 0;
      role_count = 0;
      if (indexOf.call(hints, 'read') >= 0) {
        role = 'read';
        role_count += +1;
      }
      if (indexOf.call(hints, 'write') >= 0) {
        role = 'write';
        role_count += +1;
      }
      if (indexOf.call(hints, 'append') >= 0) {
        role = 'append';
        role_count += +1;
      }
      if (role_count > 1) {
        throw new Error("can only specify one of `read`, `write` or `append`; got " + (rpr(hints)));
      }
    }
    if (hints != null) {
      ref = ['ascii', 'utf8', 'utf-8', 'ucs2', 'base64', 'binary', 'hex', 'buffer'];
      for (i = 0, len = ref.length; i < len; i++) {
        key = ref[i];
        if (indexOf.call(hints, key) >= 0) {
          if (encoding != null) {
            throw new Error("hints contain multiple encodings: " + (rpr(hints)));
          }
          encoding = key;
        }
      }
    }

    /* TAINT must simplify handling of encoding as tag and in settings */
    extra = "" + (rpr(path));
    _encoding = encoding != null ? encoding : settings['encoding'];
    if (_encoding != null) {
      extra += ' ' + _encoding;
    }

    /* TAINT no choice between symbol or name, no colorization */
    if (use_line_mode) {
      if (role === 'read') {
        extra += ' ' + "✀";
      } else {
        extra += ' ' + "∮";
      }
    }
    if (role === 'read') {
      if (use_line_mode) {
        return this._rpr("🖹 △", "file-read", extra, this.new_stream({
          pipeline: [
            this._new_stream$read_from_file(path, settings), this.$split({
              encoding: encoding
            })
          ]
        }));
      } else {
        if (settings['encoding'] == null) {
          settings['encoding'] = encoding === 'buffer' ? null : encoding;
        }
        return this._rpr("🖹 △", "file-read", extra, this._new_stream$read_from_file(path, settings));
      }
    }
    if (encoding !== 'buffer') {
      if (settings['encoding'] == null) {
        settings['encoding'] = encoding;
      }
    }
    if (role === 'append') {
      R = this.$bridge(this._new_stream$append_to_file(path, settings));
      if (use_line_mode) {
        return this._rpr("🖹 ⏬", "file-append", extra, this.new_stream({
          pipeline: [this.$as_line(), R]
        }));
      }
      return this._rpr("🖹 ⏬", "file-append", extra, R);
    }

    /* role is write */
    R = this.$bridge(this._new_stream$write_to_file(path, settings));
    if (use_line_mode) {
      return this._rpr("🖹 ▼", "file-write", extra, this.new_stream({
        pipeline: [this.$as_line(), R]
      }));
    }
    return this._rpr("🖹 ▼", "file-write", extra, R);
    return null;
  };

  this._new_stream_from_path._hints = ['ascii', 'utf8', 'utf-8', 'ucs2', 'base64', 'binary', 'hex', 'buffer', 'read', 'write', 'append', 'lines'];

  this._new_stream_from_pipeline = function(pipeline, hints, settings) {

    /* Given a list of transforms (a.k.a. a 'pipeline'), return a stream that has all the transforms
    successively linked with `.pipe` calls; writing to the stream will write to the first transform, and
    reading from the stream will read from the last transform.
     */
    var R, as_bridged, confluence, handler, inner_rpr, p, receiver, sender, transform, type;
    if (hints != null) {
      throw new Error("_new_stream_from_pipeline doesn't accept 'hints', got " + (rpr(hints)));
    }
    if (settings != null) {
      throw new Error("_new_stream_from_pipeline doesn't accept 'settings', got " + (rpr(settings)));
    }
    if ((type = CND.type_of(pipeline)) !== 'list') {
      throw new Error("expected a list, got a " + type);
    }
    as_bridged = (function(_this) {
      return function(transform) {
        if (_this.isa_writeonly_stream(transform)) {
          return _this.$bridge(transform);
        } else {
          return transform;
        }
      };
    })(this);
    if (pipeline.length === 0) {
      return this.$pass();
    }
    if (pipeline.length === 1) {
      return as_bridged(pipeline[0]);
    }
    handler = (function(_this) {
      return function(error) {
        if (error != null) {
          return R.emit('error', error);
        }
      };
    })(this);
    pipeline = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = pipeline.length; i < len; i++) {
        transform = pipeline[i];
        results.push(as_bridged(transform));
      }
      return results;
    })();
    receiver = pipeline[0];
    sender = pipeline[pipeline.length - 1];
    confluence = this._new_stream$pump(pipeline, handler);
    R = this._duplex$duplexer2(receiver, sender);
    inner_rpr = ((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = pipeline.length; i < len; i++) {
        p = pipeline[i];
        results.push(rpr(p));
      }
      return results;
    })()).join(' ');
    return this._rprx("[", null, "pipeline", inner_rpr, "]", R);
  };

  this._new_stream_from_text = function(text, hints, settings) {

    /* Given a text, return a stream that has `text` written into it; as soon as you `.pipe` it to some
    other stream or transformer pipeline, those parts will get to read the text. Unlike PipeDreams v2, the
    returned stream will not have to been resumed explicitly.
     */
    var R, ref, type;
    if (hints != null) {
      throw new Error("_new_stream_from_text doesn't accept 'hints', got " + (rpr(hints)));
    }
    if (settings != null) {
      throw new Error("_new_stream_from_text doesn't accept 'settings', got " + (rpr(settings)));
    }
    if ((ref = (type = CND.type_of(text))) !== 'text' && ref !== 'buffer') {
      throw new Error("expected text or buffer, got a " + type);
    }
    R = this.new_stream();
    R.write(text);
    R.end();
    return R;
  };

  this._new_stream_from_duplex = function(streams, hints, settings) {
    var receiver, sender, type;
    if (hints != null) {
      throw new Error("_new_stream_from_duplex doesn't accept 'hints', got " + (rpr(hints)));
    }
    if (settings != null) {
      throw new Error("_new_stream_from_duplex doesn't accept 'settings', got " + (rpr(settings)));
    }
    if ((type = CND.type_of(streams)) !== 'list') {
      throw new Error("expected a list, got a " + type);
    }
    if (streams.length !== 2) {
      throw new Error("expected list with 2 elements, git one with " + streams.length);
    }
    receiver = streams[0], sender = streams[1];
    if (!this.isa_readable_stream(receiver)) {
      throw new Error("expected readable stream");
    }
    if (!this.isa_writable_stream(sender)) {
      throw new Error("expected writable stream");
    }
    return this._duplex$duplexer2(receiver, sender);
  };

  this._new_stream_from_url = function(url, hints, settings) {
    var HTTP, R, hostname, http_settings, pathname, protocol, request, url_parts;
    url_parts = (require('url')).parse(url);
    protocol = url_parts.protocol, hostname = url_parts.hostname, pathname = url_parts.pathname;
    if (pathname == null) {
      pathname = '/';
    }
    if (hostname == null) {
      hostname = 'localhost';
    }
    debug('8090', url_parts);
    if (!((protocol === 'http:' || protocol === 'https:') && (hostname.length > 0) && (pathname.length > 0))) {
      throw new Error("URL not supported: " + (JSON.stringify(url_parts)) + "\n" + (rpr(url)));
    }
    http_settings = {
      hostname: hostname,
      pathname: pathname,
      protocol: protocol,
      followAllRedirects: true
    };
    R = this.new_stream();
    HTTP = require(protocol === 'http:' ? 'http' : 'https');
    request = HTTP.request(http_settings, (function(_this) {
      return function(response) {
        var sink;
        sink = _this.new_stream('devnull');
        _this.on_finish(sink, function() {
          return _this.end(R);
        });
        response.pipe(_this.$(function(data, send) {
          _this.send(R, data);
          return send(data);
        })).pipe(sink);
        return null;
      };
    })(this));
    request.end();
    return R;
  };

  this._new_stream_from_transform = function(transform, hints, settings) {
    var expected, got, x;
    if (settings != null) {
      throw new Error("_new_stream_from_transform doesn't accept 'settings', got " + (rpr(settings)));
    }
    if (hints == null) {
      hints = [];
    }
    if (!CND.is_subset(hints, this._new_stream_from_transform._hints)) {
      expected = ((function() {
        var i, len, ref, results;
        ref = this.new_stream._hints;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          results.push(rpr(x));
        }
        return results;
      }).call(this)).join(', ');
      got = ((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = hints.length; i < len; i++) {
          x = hints[i];
          if (indexOf.call(this.new_stream._hints, x) < 0) {
            results.push(rpr(x));
          }
        }
        return results;
      }).call(this)).join(', ');
      throw new Error("expected 'hints' out of " + expected + ", got " + got);
    }
    if (indexOf.call(hints, 'async') >= 0) {
      return this.$async(transform);
    }
    return this.$(transform);
  };

  this._new_stream_from_transform._hints = ['async'];

  this.$pass = function() {
    return this._rpr("⦵", "pass", null, this._new_stream$through());
  };

  this.$drop = function() {
    return this._rpr("◯", "drop", null, this.$((function(_this) {
      return function(data, send) {
        return null;
      };
    })(this)));
  };


  /* thx to German Attanasio http://stackoverflow.com/a/28564000/256361 */

  this.isa_stream = function(x) {
    return x instanceof (require('stream')).Stream;
  };

  this.isa_readable_stream = function(x) {
    return (this.isa_stream(x)) && x.readable;
  };

  this.isa_writable_stream = function(x) {
    return (this.isa_stream(x)) && x.writable;
  };

  this.isa_readonly_stream = function(x) {
    return (this.isa_stream(x)) && x.readable && !x.writable;
  };

  this.isa_writeonly_stream = function(x) {
    return (this.isa_stream(x)) && x.writable && !x.readable;
  };

  this.isa_duplex_stream = function(x) {
    return (this.isa_stream(x)) && x.readable && x.writable;
  };

  this.remit = this.$ = function() {
    var i, method, tags;
    tags = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), method = arguments[i++];
    return this._new_remit(tags, 'sync', method);
  };

  this.remit_async = this.$async = function() {
    var i, method, tags;
    tags = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), method = arguments[i++];
    return this._new_remit(tags, 'async', method);
  };

  this._new_remit = function(tags, mode, method) {
    var arity, flush, get_send, has_error, main, send_null;
    if (mode !== 'sync' && mode !== 'async') {
      throw new Error("unknown mode " + (rpr(mode)));
    }
    this._validate_keys("_new_remit", "one or more", tags, this._new_remit.tags);
    send_null = indexOf.call(tags, 'null') >= 0;
    if (send_null && mode === 'async') {
      throw new Error("tag 'null' not allowed for asynchronous transforms");
    }

    /* TAINT code duplication */
    if (indexOf.call(tags, 'first') >= 0) {
      if (mode === 'async') {
        throw new Error("cannot use async mode with tag 'first'");
      }
      if ((indexOf.call(tags, 'last') >= 0) || (indexOf.call(tags, 'start') >= 0) || (indexOf.call(tags, 'stop') >= 0)) {
        throw new Error("can only have one of 'first', 'last', 'start', 'stop' in tags");
      }
      if (send_null) {
        return this._$on_first('null', method);
      }
      return this._$on_first(method);
    }
    if (indexOf.call(tags, 'last') >= 0) {
      if (mode === 'async') {
        throw new Error("cannot use async mode with tag 'last'");
      }
      if ((indexOf.call(tags, 'first') >= 0) || (indexOf.call(tags, 'start') >= 0) || (indexOf.call(tags, 'stop') >= 0)) {
        throw new Error("can only have one of 'first', 'last', 'start', 'stop' in tags");
      }
      if (send_null) {
        return this._$on_last('null', method);
      }
      return this._$on_last(method);
    }
    if (indexOf.call(tags, 'start') >= 0) {
      if (mode === 'async') {
        throw new Error("cannot use async mode with tag 'start'");
      }
      if ((indexOf.call(tags, 'first') >= 0) || (indexOf.call(tags, 'last') >= 0) || (indexOf.call(tags, 'stop') >= 0)) {
        throw new Error("can only have one of 'first', 'last', 'start', 'stop' in tags");
      }
      if (send_null) {
        throw new Error("cannot use 'null' with 'start'");
      }
      return this._$on_start(method);
    }
    if (indexOf.call(tags, 'stop') >= 0) {
      if (mode === 'async') {
        throw new Error("cannot use async mode with tag 'stop'");
      }
      if ((indexOf.call(tags, 'first') >= 0) || (indexOf.call(tags, 'last') >= 0) || (indexOf.call(tags, 'start') >= 0)) {
        throw new Error("can only have one of 'first', 'last', 'start', 'stop' in tags");
      }
      if (send_null) {
        throw new Error("cannot use 'null' with 'stop'");
      }
      return this._$on_stop(method);
    }
    if (indexOf.call(tags, 'finish') >= 0) {
      if (mode === 'async') {
        throw new Error("cannot use async mode with tag 'finish'");
      }
      if ((indexOf.call(tags, 'first') >= 0) || (indexOf.call(tags, 'last') >= 0) || (indexOf.call(tags, 'start') >= 0)) {
        throw new Error("can only have one of 'first', 'last', 'start', 'finish' in tags");
      }
      if (send_null) {
        throw new Error("cannot use 'null' with 'finish'");
      }
      return this._$on_finish(method);
    }
    has_error = false;
    arity = method.length;
    if (mode === 'sync') {
      if (!((1 <= arity && arity <= 3))) {
        throw new Error("method with " + arity + " arguments not supported for synchronous transforms");
      }
    } else {
      if (arity !== 3) {
        throw new Error("method with " + arity + " arguments not supported for asynchronous transforms");
      }
    }
    if (arity === 1) {
      main = function(chunk, encoding, callback) {
        method(chunk);
        return callback(null, chunk);
      };
      flush = function(callback) {
        if (send_null) {
          method(null);
        }
        return callback();
      };
      return this._rpr("+", "$d", null, this._new_stream$through(main, flush));
    } else if (arity === 2) {
      if (send_null) {
        flush = function(callback) {
          var send;
          send = get_send(this, callback);
          method(null, send);
          if (!has_error) {
            callback();
          }
          return null;
        };
      } else {
        flush = null;
      }
    } else if (arity === 3) {
      flush = function(callback) {

        /* TAINT do we have to re-construct `send` on each call, or can we recycle the same function? */
        var end, send;
        send = get_send(this, callback);
        end = function() {
          if (!has_error) {
            callback();
          }
          return null;
        };
        method(null, send, end);
        return null;
      };
    }
    get_send = function(self, callback) {
      var R;
      R = function(data) {
        return self.push(data);
      };
      R.error = function(error) {
        has_error = true;
        return callback(error);
      };
      R.end = function() {
        return self.push(null);
      };
      if (mode === 'async') {
        R.done = function(data) {
          if (data === void 0) {
            return callback();
          } else {
            return callback(null, data);
          }
        };
      }
      return R;
    };
    main = function(chunk, encoding, callback) {

      /* TAINT do we have to re-construct `send` on each call, or can we recycle the same function? */
      var send;
      send = get_send(this, callback);
      method(chunk, send);
      if (mode === 'sync') {
        if (!has_error) {
          callback();
        }
      }
      return null;
    };
    if (arity === 2) {
      return this._rpr("⧺", "$ds", null, this._new_stream$through(main, flush));
    }
    return this._rpr("⧻", "$dse", null, this._new_stream$through(main, flush));
  };

  this._new_remit.tags = ['null', 'first', 'last', 'start', 'stop', 'finish'];

  this.send = function(me, data) {

    /* Given a stream and some data, send / write / push that data into the stream. */

    /* NOTE using `push` over `write` since `push null` does work as expected. */
    me.push(data);
    return me;
  };

  this.end = function(me) {

    /* Given a stream, end it. */
    me.end();
    return me;
  };

  this.$join = function(outer_joiner, inner_joiner) {
    var $f;
    if (outer_joiner == null) {
      outer_joiner = '\n';
    }
    if (inner_joiner == null) {
      inner_joiner = ', ';
    }

    /* Join all strings and lists in the stream. `$join` accepts two arguments, an `outer_joiner` and an
    `inner_joiner`. Joining works in three steps: First, all list encountered in the stream are joined using
    the `inner_joiner`, turning each list into a string as a matter of course. In the second step, the entire
    stream data is collected into a list (using PipeDreams `$collect`). In the last step, that collection is
    turned into a single string by joining them with the `outer_joiner`. The `outer_joiner` defaults to a
    newline, the `inner_joiner` to a comma and a space.
     */
    $f = (function(_this) {
      return function() {
        return _this.$(function(data, send) {
          var type;
          switch (type = CND.type_of(data)) {
            case 'text':
              return send(data);
            case 'list':
              return send(data.join(inner_joiner));
            default:
              throw new Error("expected a text or a list, got a " + type);
          }
        });
      };
    })(this);
    return this._rpr("join", "join", (rpr(outer_joiner)) + " " + (rpr(inner_joiner)), this.new_stream({
      pipeline: [
        $f(), this.$collect(), this.$((function(_this) {
          return function(collection, send) {
            return send(collection.join(outer_joiner));
          };
        })(this))
      ]
    }));
    return null;
  };

  this.$split = function(settings) {
    var R, encoding, extra, matcher, ref, ref1, type;
    matcher = (ref = settings != null ? settings['matcher'] : void 0) != null ? ref : '\n';
    encoding = (ref1 = settings != null ? settings['encoding'] : void 0) != null ? ref1 : 'utf-8';
    if ((type = CND.type_of(matcher)) !== 'text') {
      throw new Error("expected a text, got a " + type);
    }
    R = this._new_stream$split_buffer(matcher);
    extra = rpr(matcher);
    if (encoding !== 'buffer') {
      extra += " " + encoding;
    }
    if (encoding === 'buffer') {
      return this._rpr("✀", "split", extra, R);
    }
    return this._rpr("✀", "split", extra, this.new_stream({
      pipeline: [R, this.$decode(encoding)]
    }));
  };

  this.$decode = function(encoding) {
    if (encoding == null) {
      encoding = 'utf-8';
    }
    return this._rpr("?", "decode", encoding, this.$((function(_this) {
      return function(data, send) {
        if (!Buffer.isBuffer(data)) {
          return send(data);
        }
        return send(data.toString(encoding));
      };
    })(this)));
  };

  this.$sort = function(settings) {

    /* https://github.com/mziccard/node-timsort */
    var $sort, TIMSORT, arity, direction, key, ref, ref1, ref2, sorter, type_of, validate_type;
    TIMSORT = require('timsort');
    direction = 'ascending';
    sorter = null;
    key = null;
    switch (arity = arguments.length) {
      case 0:
        null;
        break;
      case 1:
        direction = (ref = settings['direction']) != null ? ref : 'ascending';
        sorter = (ref1 = settings['sorter']) != null ? ref1 : null;
        key = (ref2 = settings['key']) != null ? ref2 : null;
        break;
      default:
        throw new Error("expected 0 or 1 arguments, got " + arity);
    }
    if (direction !== 'ascending' && direction !== 'descending') {
      throw new Error("expected 'ascending' or 'descending' for direction, got " + (rpr(direction)));
    }
    if (sorter == null) {
      type_of = (function(_this) {
        return function(x) {

          /* NOTE for the purposes of magnitude comparison, `Infinity` can be treated as a number: */
          var R;
          R = CND.type_of(x);
          if (R === 'infinity') {
            return 'number';
          } else {
            return R;
          }
        };
      })(this);
      validate_type = (function(_this) {
        return function(type_a, type_b, include_list) {
          if (include_list == null) {
            include_list = false;
          }
          if (type_a !== type_b) {
            throw new Error("unable to compare a " + type_a + " with a " + type_b);
          }
          if (include_list) {
            if (type_a !== 'number' && type_a !== 'date' && type_a !== 'text' && type_a !== 'list') {
              throw new Error("unable to compare values of type " + type_a);
            }
          } else {
            if (type_a !== 'number' && type_a !== 'date' && type_a !== 'text') {
              throw new Error("unable to compare values of type " + type_a);
            }
          }
          return null;
        };
      })(this);
      if (key != null) {
        sorter = (function(_this) {
          return function(a, b) {
            a = a[key];
            b = b[key];
            validate_type(type_of(a), type_of(b), false);
            if ((direction === 'ascending' ? a > b : a < b)) {
              return +1;
            }
            if ((direction === 'ascending' ? a < b : a > b)) {
              return -1;
            }
            return 0;
          };
        })(this);
      } else {
        sorter = (function(_this) {
          return function(a, b) {
            var type_a, type_b;
            validate_type((type_a = type_of(a)), (type_b = type_of(b)), true);
            if (type_a === 'list') {
              a = a[0];
              b = b[0];
              validate_type(type_of(a), type_of(b), false);
            }
            if ((direction === 'ascending' ? a > b : a < b)) {
              return +1;
            }
            if ((direction === 'ascending' ? a < b : a > b)) {
              return -1;
            }
            return 0;
          };
        })(this);
      }
    }
    $sort = (function(_this) {
      return function() {
        var collector;
        collector = [];
        return _this.$(function(data, send, end) {
          var i, len, x;
          if (data != null) {
            collector.push(data);
          }
          if (end != null) {
            TIMSORT.sort(collector, sorter);
            for (i = 0, len = collector.length; i < len; i++) {
              x = collector[i];
              send(x);
            }
            collector.length = 0;
            end();
          }
          return null;
        });
      };
    })(this);
    return this._rpr("⮃", "sort", null, $sort());
  };

  this.$as_list = function() {
    var names;
    names = 1 <= arguments.length ? slice.call(arguments, 0) : [];

    /* Turn named attributes into list of values. */
    return this.$(function(data, send) {
      var name;
      send((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = names.length; i < len; i++) {
          name = names[i];
          results.push(data[name]);
        }
        return results;
      })());
      return null;
    });
  };

  this.$as_text = function(stringify) {

    /* Turn all data items into texts using `JSON.stringify` or a custom stringifier. `null` and any strings
    in the data stream is passed through unaffected. Observe that buffers in the stream will very probably not
    come out the way you'd expect them; this is because there's no way to know for the method what kind of
    data they represent.
    
    This method is handy to put as a safeguard right in front of a `.pipe output_file` clause to avoid
    `illegal non-buffer` issues.
     */
    if (stringify == null) {
      stringify = JSON.stringify;
    }
    return this.$(function(data, send) {
      if (!CND.isa_text(data)) {
        return send(stringify(data));
      }
      return send(data);
    });
  };

  this.$stringify = function(stringify) {

    /* Turn all data items into their JSON representations. */
    if (stringify != null) {
      return this.$((function(_this) {
        return function(data, send) {
          var ref, type;
          data = stringify(data);
          if ((ref = (type = CND.type_of(data))) !== 'null' && ref !== 'text') {
            return send.error(new Error("expected a text or `null`, got a " + type));
          }
        };
      })(this));
    }
    return this.$((function(_this) {
      return function(data, send) {
        if (data === _this.NULL) {
          return send('null');
        }
        if ((CND.type_of(data)) === 'symbol') {
          data = {
            '~isa': 'symbol',
            value: data.toString().replace(/^Symbol\((.*)\)$/, '$1')
          };
        }
        return send(JSON.stringify(data));
      };
    })(this));
  };

  this.$transform = function(method) {
    return this.$(function(data, send) {
      return send(method(data));
    });
  };

  this.$as_line = function(stringify) {

    /* Like `$as_text`, but appends a newline to each chunk. */
    var pipeline;
    pipeline = [
      this.$as_text(stringify), this.$((function(_this) {
        return function(text, send) {
          return send(text + '\n');
        };
      })(this))
    ];
    return this.new_stream({
      pipeline: pipeline
    });
  };

  this.$intersperse = function() {
    var R, _first_joiner, _last_joiner, _mid_joiner, arity, cache, call_first_joiner, call_joiner, call_last_joiner, call_mid_joiner, extra, first_joiner, joiners, last_joiner, mid_joiner, ref, ref1, ref2, ref3;
    joiners = 1 <= arguments.length ? slice.call(arguments, 0) : [];

    /* Similar to `$join`, but inserts events between (and around) existing events. */
    if (!((0 <= (ref = (arity = arguments.length)) && ref <= 3))) {
      throw new Error("expected 0 to 3 joiners, got " + arity);
    }
    if (arity === 0) {
      return this.$pass();
    }
    if ((joiners[0] === (ref1 = (ref2 = joiners[1]) != null ? ref2 : null) && ref1 === ((ref3 = joiners[2]) != null ? ref3 : null))) {
      return this.$pass();
    }
    cache = null;
    call_joiner = false;
    first_joiner = null;
    mid_joiner = null;
    last_joiner = null;
    call_first_joiner = false;
    call_mid_joiner = false;
    call_last_joiner = false;
    _first_joiner = null;
    _mid_joiner = null;
    _last_joiner = null;
    (function(_this) {
      return (function() {
        var i, idx, joiner, len, results;
        results = [];
        for (idx = i = 0, len = joiners.length; i < len; idx = ++i) {
          joiner = joiners[idx];
          switch (idx) {
            case 0:
              mid_joiner = joiner;
              results.push(call_mid_joiner = CND.isa_function(joiner));
              break;
            case 1:
              first_joiner = last_joiner = mid_joiner;
              call_first_joiner = call_last_joiner = call_mid_joiner;
              mid_joiner = joiner;
              results.push(call_mid_joiner = CND.isa_function(joiner));
              break;
            case 2:
              last_joiner = joiner;
              results.push(call_last_joiner = CND.isa_function(joiner));
              break;
            default:
              results.push(void 0);
          }
        }
        return results;
      });
    })(this)();
    if (call_first_joiner) {
      _first_joiner = ((function(_this) {
        return function(send, a, b) {
          var Z;
          if ((Z = first_joiner(a, b)) != null) {
            return send(Z);
          }
        };
      })(this));
    }
    if (call_mid_joiner) {
      _mid_joiner = ((function(_this) {
        return function(send, a, b) {
          var Z;
          if ((Z = mid_joiner(a, b)) != null) {
            return send(Z);
          }
        };
      })(this));
    }
    if (call_last_joiner) {
      _last_joiner = ((function(_this) {
        return function(send, a, b) {
          var Z;
          if ((Z = last_joiner(a, b)) != null) {
            return send(Z);
          }
        };
      })(this));
    }
    R = this.$((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          if (cache != null) {
            send(cache);
            if (mid_joiner != null) {
              if (call_mid_joiner) {
                _mid_joiner(send, cache, data);
              } else {
                send(mid_joiner);
              }
            }
          } else {
            if (first_joiner != null) {
              if (call_first_joiner) {
                _first_joiner(send, null, data);
              } else {
                send(first_joiner);
              }
            }
          }
          cache = data;
        }
        if (end != null) {
          if (cache != null) {
            send(cache);
            if (last_joiner != null) {
              if (call_last_joiner) {
                _last_joiner(send, data, null);
              } else {
                send(last_joiner);
              }
            }
          }
          cache = null;
          return end();
        }
      };
    })(this));
    extra = [];
    if (first_joiner != null) {
      extra.push(rpr(first_joiner));
    }
    if (mid_joiner != null) {
      extra.push(rpr(mid_joiner));
    }
    if (last_joiner != null) {
      extra.push(rpr(last_joiner));
    }
    extra = extra.join(' ');
    return this._rpr("intersperse", "intersperse", extra, R);
  };

  this.$as_json_list = function() {
    var R, arity, intersperse, pretty, tags, translate_null;
    tags = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if ((pretty = indexOf.call(tags, 'pretty') >= 0) && (arity = tags.length) > 1) {
      throw new Error("expected at most single tag 'pretty', go " + (rpr(tags)));
    }
    if (pretty) {
      intersperse = this.$intersperse('[\n  ', ',\n  ', '\n  ]\n');
    } else {
      intersperse = this.$intersperse('[', ',', ']');
    }
    translate_null = this.$((function(_this) {
      return function(data, send) {
        return send(data === _this.NULL ? 'null' : data);
      };
    })(this));
    R = this.new_stream({
      pipeline: [this.$stringify(), intersperse, translate_null, this.$join('')]
    });
    return this._rpr("as_json_list", "as_json_list", (pretty ? "pretty" : null), R);
  };

  this.$as_json_line = function() {
    var R;
    R = this.$((function(_this) {
      return function(data, send) {
        return send((JSON.stringify(data)) + '\n');
      };
    })(this));
    return this._rpr("as_json_line", "as_json_line", null, R);
  };

  this.$lockstep = function(input, settings) {

    /* Usage:
    
    ```coffee
    input_1
      .pipe D.$lockstep input_2 # or `.pipe D.$lockstep input_2, fallback: null`
      .pipe $ ( [ data_1, data_2, ], send ) =>
        ...
    ```
    
    `$lockstep` combines each piece of data coming down the stream with one piece of data emitted from the
    stream you passed in when calling the function. If the two streams turn out to have unequal lengths,
    an error is sent into the stream unless you called the function with an additional `fallback: value`
    argument.
     */

    /* TAINT re-write in a less low-level fashion */

    /* TAINT re-write to avoid buffering both streams */
    var _end_1, _end_2, _send, buffer_1, buffer_2, fallback, flush, has_ended, idx_1, idx_2;
    fallback = settings != null ? settings['fallback'] : void 0;
    idx_1 = 0;
    idx_2 = 0;
    buffer_1 = [];
    buffer_2 = [];
    _send = null;
    _end_1 = null;
    _end_2 = null;
    has_ended = false;
    flush = (function(_this) {
      return function() {
        var data_1, data_2, i, idx, ref;
        if (_send != null) {
          while ((buffer_1.length > 0) && (buffer_2.length > 0) && idx_1 === idx_2) {
            _send([buffer_1.shift(), buffer_2.shift()]);
            idx_1 += +1;
            idx_2 += +1;
          }
        }
        if ((_end_1 != null) && (_end_2 != null)) {
          if ((buffer_1.length > 0) || (buffer_2.length > 0)) {
            for (idx = i = 0, ref = Math.max(buffer_1.length, buffer_2.length); 0 <= ref ? i < ref : i > ref; idx = 0 <= ref ? ++i : --i) {
              data_1 = buffer_1[idx];
              data_2 = buffer_2[idx];
              if (data_1 === void 0 || data_2 === void 0) {
                if (fallback === void 0) {
                  return _send.error(new Error("streams of unequal lengths and no fallback value given"));
                }
                if (data_1 === void 0) {
                  data_1 = fallback;
                }
                if (data_2 === void 0) {
                  data_2 = fallback;
                }
              }
              _send([data_1, data_2]);
            }
          }
          _end_1();
          return _end_2();
        }
      };
    })(this);
    alert("must not use .on 'data' use .read(), see http://codewinds.com/blog/2013-08-04-nodejs-readable-streams.html");
    input.on('data', (function(_this) {
      return function(data_2) {
        buffer_2.push(data_2);
        return flush();
      };
    })(this));
    input.pipe(this.$((function(_this) {
      return function(data, send, end) {
        if (data) {
          send(data);
        }
        if (end != null) {
          _end_2 = end;
          return flush();
        }
      };
    })(this)));
    return this.$((function(_this) {
      return function(data_1, send, end) {
        _send = send;
        if (data_1 != null) {
          buffer_1.push(data_1);
          flush();
        }
        if (end != null) {
          _end_1 = end;
          return flush();
        }
      };
    })(this));
  };

  this.$sample = function(p, options) {
    var count, headers, ref, ref1, rnd, seed;
    if (p == null) {
      p = 0.5;
    }

    /* Given a `0 <= p <= 1`, interpret `p` as the *p*robability to *p*ick a given record and otherwise toss
    it, so that `$sample 1` will keep all records, `$sample 0` will toss all records, and
    `$sample 0.5` (the default) will toss (on average) every other record.
    
    You can pipe several `$sample()` calls, reducing the data stream to 50% with each step. If you know
    your data set has, say, 1000 records, you can cut down to a random sample of 10 by piping the result of
    calling `$sample 1 / 1000 * 10` (or, of course, `$sample 0.01`).
    
    Tests have shown that a data file with 3'722'578 records (which didn't even fit into memory when parsed)
    could be perused in a matter of seconds with `$sample 1 / 1e4`, delivering a sample of around 370
    records. Because these records are randomly selected and because the process is so immensely sped up, it
    becomes possible to develop regular data processing as well as coping strategies for data-overload
    symptoms with much more ease as compared to a situation where small but realistic data sets are not
    available or have to be produced in an ad-hoc, non-random manner.
    
    **Parsing CSV**: There is a slight complication when your data is in a CSV-like format: in that case,
    there is, with `0 < p < 1`, a certain chance that the *first* line of a file is tossed, but some
    subsequent lines are kept. If you start to transform the text line into objects with named values later in
    the pipe (which makes sense, because you will typically want to thin out largeish streams as early on as
    feasible), the first line kept will be mis-interpreted as a header line (which must come first in CSV
    files) and cause all subsequent records to become weirdly malformed. To safeguard against this, use
    `$sample p, headers: true` (JS: `$sample( p, { headers: true } )`) in your code.
    
    **Predictable Samples**: Sometimes it is important to have randomly selected data where samples are
    constant across multiple runs:
    
    * once you have seen that a certain record appears on the screen log, you are certain it will be in the
      database, so you can write a snippet to check for this specific one;
    
    * you have implemented a new feature you want to test with an arbitrary subset of your data. You're
      still tweaking some parameters and want to see how those affect output and performance. A random
      sample that is different on each run would be a problem because the number of records and the sheer
      bytecount of the data may differ from run to run, so you wouldn't be sure which effects are due to
      which causes.
    
    To obtain predictable samples, use `$sample p, seed: 1234` (with a non-zero number of your choice);
    you will then get the exact same
    sample whenever you re-run your piping application with the same stream and the same seed. An interesting
    property of the predictable sample is that—everything else being the same—a sample with a smaller `p`
    will always be a subset of a sample with a bigger `p` and vice versa.
     */
    if (!((0 <= p && p <= 1))) {
      throw new Error("expected a number between 0 and 1, got " + (rpr(p)));
    }

    /* Handle trivial edge cases faster (hopefully): */
    if (p === 1) {
      return this.$((function(_this) {
        return function(record, send) {
          return send(record);
        };
      })(this));
    }
    if (p === 0) {
      return this.$((function(_this) {
        return function(record, send) {
          return null;
        };
      })(this));
    }
    headers = (ref = options != null ? options['headers'] : void 0) != null ? ref : false;
    seed = (ref1 = options != null ? options['seed'] : void 0) != null ? ref1 : null;
    count = 0;
    rnd = this._rnd_from_seed(seed);
    return this.$((function(_this) {
      return function(record, send) {
        count += 1;
        if ((count === 1 && headers) || rnd() < p) {
          return send(record);
        }
      };
    })(this));
  };

  this.$count = function(on_end) {
    var count;
    if (on_end == null) {
      on_end = null;
    }
    count = 0;
    return this.$(function(data, send, end) {
      if (data != null) {
        send(data);
        count += +1;
      }
      if (end != null) {
        if (on_end != null) {
          on_end(count, send);
        } else {
          send(count);
        }
        return end();
      }
    });
  };

  this.$collect = function(on_end) {
    var collector;
    if (on_end == null) {
      on_end = null;
    }
    collector = [];
    return this._rpr("⚞", "collect", null, this.$(function(data, send, end) {
      if (data != null) {
        collector.push(data);
      }
      if (end != null) {
        send(collector);
        return end();
      }
    }));
  };

  this.tap = function() {
    var P, handler, i, pipeline, stream;
    stream = arguments[0], P = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), handler = arguments[i++];
    pipeline = [];
    pipeline.push(stream);
    if (P.length > 0) {
      pipeline.push(this.$sample.apply(this, P));
    }
    pipeline.push(this.$collect());
    pipeline.push(this.$((function(_this) {
      return function(collector) {
        return handler(null, collector);
      };
    })(this)));
    return this._rpr("tap", "tap", null, this.new_stream({
      pipeline: pipeline
    }));
  };

  this.$tap = function(stream, settings) {

    /* TAINT this didn't work with `@send stream, data`, `stream.push data`—why? */
    var copy;
    copy = settings != null ? settings.copy : void 0;
    if (copy === null) {
      copy = (function(data) {
        return data;
      });
    }
    if (copy == null) {
      copy = CND.deep_copy;
    }
    debug('30301', copy);
    return this.$((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          stream.write(copy(data));
          send(data);
        }
        if (end != null) {
          stream.end();
          end();
        }
        return null;
      };
    })(this));
  };

  this.$spread = function(settings) {
    var indexed, ref;
    indexed = (ref = settings != null ? settings['indexed'] : void 0) != null ? ref : false;
    return this._rpr("⚟", "spread", null, this.$((function(_this) {
      return function(data, send) {
        var i, idx, len, type, value;
        if (!(type = (CND.type_of(data)) === 'list')) {
          return send.error(new Error("expected a list, got a " + (rpr(type))));
        }
        for (idx = i = 0, len = data.length; i < len; idx = ++i) {
          value = data[idx];
          send(indexed ? [idx, value] : value);
        }
        return null;
      };
    })(this)));
  };

  this.$batch = function(batch_size) {
    var buffer;
    if (batch_size == null) {
      batch_size = 1000;
    }
    if (batch_size < 0) {
      throw new Error("buffer size must be non-negative integer, got " + (rpr(batch_size)));
    }
    buffer = [];
    return this.$((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          buffer.push(data);
          if (buffer.length >= batch_size) {
            send(buffer);
            buffer = [];
          }
        }
        if (end != null) {
          if (buffer.length > 0) {
            send(buffer);
          }
          return end();
        }
      };
    })(this));
  };

  this._$on_start = function(method) {
    var arity, ref;
    if (!((0 <= (ref = (arity = method.length)) && ref <= 1))) {
      throw new Error("expected method with up to 1 argument, got one with " + arity);
    }
    return this._$on_first('null', (function(_this) {
      return function(data, send) {
        if (arity === 1) {
          method(send);
        } else {
          method();
        }
        return send(data);
      };
    })(this));
  };

  this._$on_stop = function(method) {
    var arity, ref;
    if (!((0 <= (ref = (arity = method.length)) && ref <= 1))) {
      throw new Error("expected method with up to 1 argument, got one with " + arity);
    }
    return this._$on_last('null', (function(_this) {
      return function(data, send) {
        send(data);
        if (arity === 1) {
          return method(send);
        } else {
          return method();
        }
      };
    })(this));
  };

  this._$on_first = function() {
    var arity, i, is_first, method, tags;
    tags = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), method = arguments[i++];
    is_first = true;
    if (!CND.is_subset(tags, ['null'])) {
      throw new Error("allowed tag is 'null', got " + (rpr(tags)));
    }
    if ((arity = method.length) !== 2) {
      throw new Error("expected method with 2 arguments, got one with " + arity);
    }
    return this.$('null', function(data, send) {
      if (data != null) {
        if (is_first) {
          method(data, send);
          is_first = false;
        } else {
          send(data);
        }
      } else {
        if (is_first && indexOf.call(tags, 'null') >= 0) {
          method(data, send);
        }
        send(null);
      }
      return null;
    });
  };

  this._$on_last = function() {
    var arity, cache, i, is_first, method, tags;
    tags = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), method = arguments[i++];
    if (!CND.is_subset(tags, ['null'])) {
      throw new Error("allowed tag is 'null', got " + (rpr(tags)));
    }
    if ((arity = method.length) !== 2) {
      throw new Error("expected method with 2 argument, got one with " + arity);
    }
    cache = null;
    is_first = true;
    return this.$('null', function(data, send) {
      if (data != null) {
        is_first = false;
        if (cache != null) {
          send(cache);
        }
        cache = data;
      } else {
        if (cache != null) {
          method(cache, send);
        } else if (is_first && indexOf.call(tags, 'null') >= 0) {
          method(null, send);
        }
        send(null);
        cache = null;
      }
      return null;
    });
  };

  this.on_finish = function(stream, handler) {
    return stream.on('finish', (function(_this) {
      return function() {
        return setImmediate(function() {
          return handler();
        });
      };
    })(this));
  };

  this._$on_finish = function(method) {

    /* NOTE For reason not well understood, using `@new_stream()` here instead ov a `devnull` stream
    will in some cases not work, as the finish event never fires.
     */
    var R;
    R = this.new_stream('devnull');
    this.on_finish(R, method);
    return R;
  };

  this.$filter = function(method) {
    return this.$((function(_this) {
      return function(data, send) {
        if (method(data)) {
          return send(data);
        }
      };
    })(this));
  };

  this.$show = function(badge) {
    var my_show;
    if (badge == null) {
      badge = null;
    }
    my_show = CND.get_logger('info', badge != null ? badge : '*');
    return this.$((function(_this) {
      return function(record, send) {
        my_show(rpr(record));
        return send(record);
      };
    })(this));
  };

  this.$benchmark = function(title) {
    var R, me, pipeline, t0;
    if (title == null) {
      title = null;
    }
    t0 = null;
    me = {};
    me.n = 0;
    me.dt = null;
    me.rps = null;
    me.title = title != null ? title : "№" + (Object.keys(this.$benchmark.registry)).length;
    this.$benchmark.registry[title] = me;
    R = this.new_stream();
    pipeline = [];
    pipeline.push(this.$('start', (function(_this) {
      return function() {
        return t0 = +new Date();
      };
    })(this)));
    pipeline.push(this.$((function(_this) {
      return function(data) {
        return me.n += 1;
      };
    })(this)));
    pipeline.push(this.$('finish', (function(_this) {
      return function() {
        me.dt = (new Date() - t0) / 1000;
        me.rps = me.n / me.dt;
        return _this.$benchmark._report(me);
      };
    })(this)));
    return this.new_stream({
      pipeline: pipeline
    });
  };

  this.$benchmark.summarize = (function(_this) {
    return function() {
      return _this.$('finish', function() {
        var _, me, ref, results;
        urge("Benchmarks summary:");
        ref = _this.$benchmark.registry;
        results = [];
        for (_ in ref) {
          me = ref[_];
          results.push(_this.$benchmark._report(me));
        }
        return results;
      });
    };
  })(this);

  this.$benchmark._report = (function(_this) {
    return function(me) {
      var dt, n, rps;
      n = CND.format_number(me.n);
      dt = me.dt.toFixed(3);
      rps = me.rps.toFixed(3);
      info(CND.steel(me.title + ": " + n + " records in " + dt + " s (" + rps + " r/s)"));
      return null;
    };
  })(this);

  this.$benchmark.registry = {};

  this.$throttle_bytes = function(bytes_per_second) {
    return this._new_stream$throttle_bytes(bytes_per_second);
  };

  this.$throttle_items = function(items_per_second) {
    throw new Error("$throttle_items on hold");
  };

  this._rnd_from_seed = function(seed) {

    /* TAINT use CND method */
    if (seed != null) {
      return CND.get_rnd(seed);
    } else {
      return Math.random;
    }
  };

  this._deprecate = function(message) {
    return warn("DEPRECATION WARNING:", message);
  };

  this._validate_keys = function(title, arity, got, expected) {
    var x;
    if (CND.is_subset(got, expected)) {
      return;
    }
    got = ((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = got.length; i < len; i++) {
        x = got[i];
        if (indexOf.call(expected, x) < 0) {
          results.push(rpr(x));
        }
      }
      return results;
    })()).join(', ');
    expected = ((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = expected.length; i < len; i++) {
        x = expected[i];
        results.push(rpr(x));
      }
      return results;
    })()).join(', ');
    throw new Error(title + ":\nexpected " + arity + " " + expected + ",\ngot " + got);
  };

  this.$bridge = function(stream) {

    /* Make it so that the pipeline may be continued even below a writable but not readable stream.
    Conceivably, this method could have be named `tunnel` as well. Something to get you across, you get the
    meaning.
     */
    var R, arity, bridge, extra, handler, receiver, sender;
    if ((arity = arguments.length) !== 1) {
      throw new Error("expected a single argument, got " + arity);
    }
    if (!this.isa_stream(stream)) {
      throw new Error("expected a stream, got a " + (CND.type_of(stream)));
    }
    if (!this.isa_writable_stream(stream)) {
      throw new Error("expected a writable stream");
    }
    sender = this.new_stream();
    receiver = this.$((function(_this) {
      return function(data, send) {
        send(data);
        return _this.send(sender, data);
      };
    })(this));
    receiver.on('finish', (function(_this) {
      return function() {
        return sender.emit('finish');
      };
    })(this));
    receiver.on('end', (function(_this) {
      return function() {
        return sender.emit('end');
      };
    })(this));
    handler = (function(_this) {
      return function(error) {
        if (error != null) {
          return R.emit('error', error);
        }
      };
    })(this);
    bridge = this._new_stream$pump([receiver, stream], handler);
    R = this._duplex$duplexer2(receiver, sender);
    extra = (rpr(bridge)) + ' ↝ ' + (rpr(sender));
    return this._rpr("↷", "bridge", extra, R);
  };

  this.$select = function(selector, tracks) {
    var drop, my_streams, pass, receiver, sender;
    if (tracks == null) {
      tracks = null;
    }
    receiver = this.new_stream();
    sender = this.new_stream();
    drop = this.$drop();
    pass = this.$pass();
    pass.pipe(sender);
    my_streams = {};
    if (tracks != null) {
      (Object.keys(tracks)).forEach((function(_this) {
        return function(key) {
          var stream, sub_input;
          stream = tracks[key];
          my_streams[key] = sub_input = _this.new_stream();
          return sub_input.pipe(stream).pipe(sender);
        };
      })(this));
    }
    receiver.pipe(this.$((function(_this) {
      return function(raw_data, send, end) {
        var data, i, key, keys, len, selection, target_stream;
        if (raw_data != null) {
          keys = null;
          data = null;
          selection = selector(raw_data);
          if (selection == null) {
            throw new Error("expected value for selection, got " + (rpr(selection)));
          }
          key = selection.key, data = selection.data;
          if (key == null) {
            throw new Error("expected value for key, got " + (rpr(key)));
          }
          if (data == null) {
            data = raw_data;
          }
          keys = CND.isa_list(key) ? key : [key];
          for (i = 0, len = keys.length; i < len; i++) {
            key = keys[i];
            if (_this.isa_stream(key)) {
              target_stream = key;
            } else if ((CND.type_of(key)) === 'symbol') {
              switch (key) {
                case _this.σ_pass:
                  target_stream = pass;
                  break;
                case _this.σ_drop:
                  target_stream = drop;
                  break;
                default:
                  throw new Error("expected symbol for 'pass' or 'drop', got " + (rpr(key)));
              }
            } else {
              target_stream = my_streams[key];
              if (target_stream == null) {
                throw new Error("not a valid key: " + (rpr(key)));
              }
            }
            _this.send(target_stream, data);
          }
        }
        if (end != null) {
          if (tracks != null) {
            (Object.keys(tracks)).forEach(function(key) {
              return _this.end(my_streams[key]);
            });
          }
          _this.end(drop);
          _this.end(pass);
          return end();
        }
      };
    })(this)));
    return this._duplex$duplexer2(receiver, sender);
  };

  (function(PIPEDREAMS) {
    var i, key, len, ref, results, sub_key, value;
    ref = Object.keys(PIPEDREAMS);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      if (CND.isa_function(value = PIPEDREAMS[key])) {
        PIPEDREAMS[key] = value.bind(PIPEDREAMS);
        results.push((function() {
          var j, len1, ref1, results1;
          ref1 = Object.keys(value);
          results1 = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            sub_key = ref1[j];
            results1.push(PIPEDREAMS[key][sub_key] = value[sub_key]);
          }
          return results1;
        })());
      } else {
        results.push(PIPEDREAMS[key] = value);
      }
    }
    return results;
  })(this);

}).call(this);

//# sourceMappingURL=main.js.map
