// Generated by CoffeeScript 1.8.0
(function() {
  var $, CND, DS, alert, badge, debug, echo, help, info, log, rpr, through2, urge, warn, whisper,
    __slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS2';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);


  /* https://github.com/rvagg/through2 */

  through2 = require('through2');

  DS = require('./densort');

  this.new_densort = DS.new_densort.bind(DS);


  /* https://github.com/dominictarr/event-stream */

  this.ES = require('event-stream');


  /* https://github.com/dominictarr/sort-stream */

  this.$sort = require('sort-stream');

  this.$split = this.ES.split.bind(this.ES);

  this.remit = function(method) {
    var arity, get_send, on_data, on_end, send;
    send = null;
    on_end = null;
    get_send = function(self) {
      var R;
      R = function(data) {
        return self.emit('data', data);
      };
      R.error = function(error) {
        return self.emit('error', error);
      };
      R.end = function() {
        return self.emit('end');
      };
      R.pause = function() {
        return self.pause();
      };
      R.resume = function() {
        return self.resume();
      };
      R.read = function() {
        return self.read();
      };
      R['%self'] = self;
      return R;
    };
    on_data = function(data) {
      if (send == null) {
        send = get_send(this);
      }
      return method(data, send);
    };
    switch (arity = method.length) {
      case 2:
        null;
        break;
      case 3:
        on_end = function() {
          var end;
          if (send == null) {
            send = get_send(this);
          }
          end = (function(_this) {
            return function() {
              return _this.emit('end');
            };
          })(this);
          return method(void 0, send, end);
        };
        break;
      default:
        throw new Error("expected a method with an arity of 2 or 3, got one with an arity of " + arity);
    }
    return this.ES.through(on_data, on_end);
  };

  $ = this.remit.bind(this);

  this.$skip_first = function(n) {
    var count;
    if (n == null) {
      n = 1;
    }
    count = 0;
    return $(function(data, send) {
      count += +1;
      if (count > n) {
        return send(data);
      }
    });
  };

  this.create_throughstream = function() {
    var P, R;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    R = through2.obj.apply(through2, P);
    R.setMaxListeners(0);
    return R;
  };

  this.$sub = function(sub_transformer) {
    var cache, sink, source, _end, _send;
    _send = null;
    _end = null;
    cache = void 0;
    source = this.create_throughstream();
    sink = this.create_throughstream();
    source.ended = false;
    sub_transformer(source, sink, function() {
      return source.end();
    });
    sink.on('data', (function(_this) {
      return function(data) {
        return _send(data);
      };
    })(this));
    sink.on('end', (function(_this) {
      return function() {
        return _send.end();
      };
    })(this));
    return $((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          _send = send;
          if (cache === void 0) {
            cache = data;
          } else {
            source.write(cache);
            cache = data;
          }
        }
        if (end != null) {
          source.ended = true;
          if (cache !== void 0) {
            return source.write(cache);
          }
        }
      };
    })(this));
  };

  this.$densort = function(key, first_idx, report_handler) {
    var ds, has_ended, send_data, signal_end;
    if (key == null) {
      key = 1;
    }
    if (first_idx == null) {
      first_idx = 0;
    }
    if (report_handler == null) {
      report_handler = null;
    }
    ds = this.new_densort(key, first_idx, report_handler);
    has_ended = false;
    send_data = (function(_this) {
      return function(send, data) {};
    })(this);
    signal_end = (function(_this) {
      return function(send) {
        if (!has_ended) {
          send.end();
        }
        return has_ended = true;
      };
    })(this);
    return $((function(_this) {
      return function(input_data, send, end) {
        if (input_data != null) {
          ds(input_data, function(error, output_data) {
            if (error != null) {
              return send.error(error);
            }
            return send(output_data);
          });
        }
        if (end != null) {
          return ds(null, function(error, output_data) {
            if (error != null) {
              return send.error(error);
            }
            if (output_data != null) {
              return send(output_data);
            } else {
              return signal_end(send);
            }
          });
        }
      };
    })(this));
  };


  /* TAINT all these functions should have an optional callback (that does not take an error and
  should not be named 'handler'); with no callback, the aggregated data will be sent downstream; with a
  callback, the orighinal data will be sent downstream, and the aggregate is the sole argument for the callback on
  end-of-stream.
   */

  this.$count = function(handler) {
    var count;
    if (handler == null) {
      handler = null;
    }
    count = 0;
    return $((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          count += 1;
        }
        if (handler != null) {
          send(data);
        }
        if (end != null) {
          if (handler != null) {
            handler(count);
          } else {
            send(count);
          }
          return end();
        }
      };
    })(this));
  };

  this.$collect = function(collector) {
    if (collector == null) {
      collector = null;
    }
    if (collector == null) {
      collector = [];
    }
    return $((function(_this) {
      return function(event, send, end) {
        if (event != null) {
          collector.push(event);
        }
        if (end != null) {
          send(collector);
          return end();
        }
      };
    })(this));
  };

  this.$spread = function(settings) {
    var end, indexed, _ref, _ref1;
    indexed = (_ref = settings != null ? settings['indexed'] : void 0) != null ? _ref : false;
    end = (_ref1 = settings != null ? settings['end'] : void 0) != null ? _ref1 : false;
    return $((function(_this) {
      return function(event, send) {
        var idx, type, value, _i, _len;
        if (!(type = (CND.type_of(event)) === 'list')) {
          return send.error(new Error("expected a list, got a " + (rpr(type))));
        }
        for (idx = _i = 0, _len = event.length; _i < _len; idx = ++_i) {
          value = event[idx];
          send(indexed ? [idx, value] : value);
        }
        if (end) {
          return send(null);
        }
      };
    })(this));
  };

  this.$signal_end = function(signal) {
    var on_data, on_end;
    if (signal == null) {
      signal = this.eos;
    }

    /* Given an optional `signal` (which defaults to `null`), return a stream transformer that emits
    `signal` as last value in the stream. Observe that whatever value you choose for `signal`, that value
    should be gracefully handled by any transformers that follow in the pipe.
     */
    on_data = null;
    on_end = function() {
      this.emit('data', signal);
      return this.emit('end');
    };
    return this.ES.through(on_data, on_end);
  };

  this.$on_end = function(method) {
    return $(function(data, send, end) {
      if (data != null) {
        send(data);
      }
      if (end != null) {
        return method(send, end);
      }
    });
  };

  this.$on_start = function(method) {
    var is_first;
    is_first = true;
    return $(function(data, send) {
      if (is_first) {
        method(send);
      }
      is_first = false;
      return send(data);
    });
  };

  this.$filter = function(select) {
    return $((function(_this) {
      return function(event, send) {
        if (select(event)) {
          return send(event);
        }
      };
    })(this));
  };

  this.$show = function(badge) {
    var my_show;
    if (badge == null) {
      badge = null;
    }
    my_show = CND.get_logger('info', badge != null ? badge : '*');
    return $((function(_this) {
      return function(record, send) {
        my_show(rpr(record));
        return send(record);
      };
    })(this));
  };

  this.$continue = function(stream) {
    return $((function(_this) {
      return function(data, send, end) {
        stream.write(data);
        if (end != null) {
          stream.end();
          return end();
        }
      };
    })(this));
  };

}).call(this);
