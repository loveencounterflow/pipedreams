// Generated by CoffeeScript 1.10.0
(function() {
  var CND, alert, badge, debug, help, rpr, urge, warn,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS/PLUGIN-TABULATE';

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  this.$show_table = function(settings) {
    throw new Error("not implemented");
  };

  this.$tabulate = function(settings) {
    var $as_event, $as_row, $cleanup, $finalize, $read_parameters, as_row, as_text, expected, got, is_first, keys, pipeline, titles, to_width, type, widths, x;
    to_width = require('to-width').to_width;
    if (settings == null) {
      settings = {};
    }
    if (!CND.is_subset((keys = Object.keys(settings)), this.$tabulate._keys)) {
      expected = ((function() {
        var i, len, ref, results;
        ref = this.$tabulate._keys;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          results.push(rpr(x));
        }
        return results;
      }).call(this)).join(', ');
      got = ((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = keys.length; i < len; i++) {
          x = keys[i];
          if (indexOf.call(this.$tabulate._keys, x) < 0) {
            results.push(rpr(x));
          }
        }
        return results;
      }).call(this)).join(', ');
      throw new Error("expected " + expected + ", got " + got);
    }
    if (settings['width'] == null) {
      settings['width'] = 20;
    }
    if (settings['spacing'] == null) {
      settings['spacing'] = 'wide';
    }
    if (settings['columns'] == null) {
      settings['columns'] = null;
    }
    switch (settings['spacing']) {
      case 'wide':
        settings['_left'] = '│ ';
        settings['_mid'] = ' │ ';
        settings['_right'] = ' │';
        break;
      case 'tight':
        settings['_left'] = '│';
        settings['_mid'] = '│';
        settings['_right'] = '│';
        break;
      default:
        throw new Error("expected 'tight' or 'wide', got " + (rpr(settings['spacing'])) + " ");
    }
    settings['_slice'] = null;
    settings['_titles'] = null;
    switch (type = CND.type_of(settings['columns'])) {
      case 'null':
        null;
        break;
      case 'number':
        settings['_slice'] = settings['columns'];
        settings['columns'] = null;
        break;
      default:
        throw new Error("type " + type + " not implemented for settings 'columns'");
    }
    widths = null;
    keys = null;
    titles = null;
    as_text = (function(_this) {
      return function(x) {
        if (CND.isa_text(x)) {
          return x;
        } else {
          return rpr(x);
        }
      };
    })(this);
    pipeline = [];
    is_first = true;
    as_row = (function(_this) {
      return function(data, keys) {
        var R, i, idx, j, key, len, ref, ref1, ref2;
        if (keys == null) {
          keys = null;
        }
        R = [];
        if (keys != null) {
          for (idx = i = 0, len = keys.length; i < len; idx = ++i) {
            key = keys[idx];
            R.push(to_width(as_text(data[key]), (ref = widths != null ? widths[idx] : void 0) != null ? ref : settings['width']));
          }
        } else {
          for (idx = j = 0, ref1 = data.length; 0 <= ref1 ? j < ref1 : j > ref1; idx = 0 <= ref1 ? ++j : --j) {
            R.push(to_width(as_text(data[idx]), (ref2 = widths != null ? widths[idx] : void 0) != null ? ref2 : settings['width']));
          }
        }
        R = R.join(settings['_mid']);
        return settings['_left'] + R + settings['_right'];
      };
    })(this);
    $as_event = (function(_this) {
      return function() {
        return _this.$(function(data, send) {
          return send(['data', data]);
        });
      };
    })(this);
    $read_parameters = (function(_this) {
      return function() {
        return _this.$on_first(function(event, send) {
          var _, data, idx, key, mark, type_of_data;
          mark = event[0], data = event[1];
          send(event);
          if (mark !== 'data') {
            return;
          }
          send(['table', '']);
          if (keys == null) {
            switch (type_of_data = CND.type_of(data)) {
              case 'list':
                keys = (function() {
                  var i, len, results;
                  results = [];
                  for (idx = i = 0, len = data.length; i < len; idx = ++i) {
                    _ = data[idx];
                    results.push(idx);
                  }
                  return results;
                })();
                break;
              case 'pod':
                keys = (function() {
                  var results;
                  results = [];
                  for (key in data) {
                    results.push(key);
                  }
                  return results;
                })();
                if (titles == null) {
                  titles = keys;
                }
                break;
              default:
                return send.error(new Error("expected a list or a POD, got a " + type_of_data));
            }
            if (settings['_slice'] != null) {
              keys.length = settings['_slice'];
            }
          }
          if (widths == null) {
            widths = (function() {
              var i, len, results;
              results = [];
              for (i = 0, len = keys.length; i < len; i++) {
                key = keys[i];
                results.push(settings['width']);
              }
              return results;
            })();
          }
          if (titles != null) {
            send(['table', as_row(titles)]);
          }
          return send(['table', '│──────────────────────│──────────────────────│']);
        });
      };
    })(this);
    $as_row = (function(_this) {
      return function() {
        return _this.$(function(event, send) {
          var data, mark;
          mark = event[0], data = event[1];
          if (mark === 'data') {
            return send(['table', as_row(data, keys)]);
          }
          return send(event);
        });
      };
    })(this);
    $finalize = (function(_this) {
      return function() {
        return _this.$on_stop(function(send) {
          send(['table', '│──────────────────────│──────────────────────│']);
          return send(['table', '']);
        });
      };
    })(this);
    $cleanup = (function(_this) {
      return function() {
        return _this.$(function(event, send) {
          var data, mark;
          mark = event[0], data = event[1];
          if (mark === 'table') {
            send(data);
          }
          return null;
        });
      };
    })(this);
    pipeline = [$as_event(), $read_parameters(), $as_row(), $finalize(), $cleanup()];
    return this.new_stream({
      pipeline: pipeline
    });
  };

  this.$tabulate._keys = ['spacing', 'width', 'columns'];

  (function(self) {
    var D, name, results, value;
    D = require('./main');
    results = [];
    for (name in self) {
      value = self[name];
      results.push(D[name] = value);
    }
    return results;
  })(this);

}).call(this);

//# sourceMappingURL=plugin-tabulate.js.map
