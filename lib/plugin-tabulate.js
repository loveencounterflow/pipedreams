// Generated by CoffeeScript 1.10.0
(function() {
  var $, $as_event, $as_row, $async, $cleanup, $finalize, $read_parameters, CND, D, _new_state, alert, as_row, as_text, badge, debug, help, keys_default, keys_toplevel, rpr, to_width, urge, warn,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS/PLUGIN-TABULATE';

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  D = require('./main');

  $ = D.$, $async = D.$async;

  to_width = require('to-width').to_width;


  /*
  
  
  ┌───┬───┐
  │   │   │
  ╞═══╪═══╡
  │   │   │
  ├───┼───┤
  │   │   │
  └───┴───┘
  
    l   c   r     l   c   r
  t ┌───┬───┐   t ╭───┬───╮
    │   │   │     │   │   │
  m ├───┼───┤   m ├───┼───┤
    │   │   │     │   │   │
  b └───┴───┘   b ╰───┴───╯
  
  lt    ┌             ╭
  ct    ┬             ┬
  rt    ┐             ╮
  lm    ├             ├
  cm    ┼             ┼
  rm    ┤             ┤
  lb    └             ╰
  cb    ┴             ┴
  rb    ┘             ╯
  hc    │             │
  vc    ─             ─
  
  settings =
    default:
      width:          <number>  ::                                              // 20
      alignment:      <text>    :: 'left' | 'right' | 'center' | 'justify'      // 'left'
  
    widths:         [ <number> | '*' ]
    alignments:     [ <text> ]
    titles:         [ <text> ]
    keys:           [ <text> | <number> ]
  
    width:          <number>  ::                                                // 108
    ellipsis:       <text>                                                      // '…'
    pad:            <number> | <text>                                           // ''
   */

  this.$show_table = function(settings) {
    throw new Error("not implemented");
  };

  _new_state = function(settings) {
    var S, keys, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
    S = {};

    /* TAINT better to use formal schema here? */
    if (!CND.is_subset((keys = Object.keys(settings)), keys_toplevel)) {
      throw new Error("### MEH 1 ### " + (rpr(keys)));
    }
    if (settings['default'] != null) {
      if (CND.is_subset((keys = Object.keys(settings['default'])), keys_default)) {
        throw new Error("### MEH 2 ### " + (rpr(keys)));
      }
    }
    if (settings['widths'] != null) {
      throw new Error("'widths' not yet supported");
    }
    if (settings['alignments'] != null) {
      throw new Error("'alignments' not yet supported");
    }
    S.widths = (ref = settings['widths']) != null ? ref : [];
    S.alignments = (ref1 = settings['alignments']) != null ? ref1 : [];
    S.titles = (ref2 = settings['titles']) != null ? ref2 : null;
    S.keys = (ref3 = settings['keys']) != null ? ref3 : null;
    S.width = (ref4 = settings['width']) != null ? ref4 : 108;
    S.ellipsis = (ref5 = settings['ellipsis']) != null ? ref5 : '…';
    S.pad = (ref6 = settings['pad']) != null ? ref6 : '';
    S["default"] = {};
    S["default"].width = (ref7 = (ref8 = settings['default']) != null ? ref8['width'] : void 0) != null ? ref7 : 20;
    S["default"].alignment = (ref9 = (ref10 = settings['default']) != null ? ref10['alignment'] : void 0) != null ? ref9 : 'left';
    return S;
  };

  keys_toplevel = ['default', 'widths', 'alignments', 'titles', 'keys', 'width', 'ellipsis', 'pad'];

  keys_default = ['width', 'alignment'];

  this.$tabulate = function(settings) {
    var S, expected, got, keys, pipeline, ref, ref1, ref2, type, x;
    if (settings == null) {
      settings = {};
    }
    debug('7233', _new_state(settings));
    if (settings == null) {
      settings = {};
    }
    S = {};
    if (!CND.is_subset((keys = Object.keys(settings)), this.$tabulate._keys)) {
      expected = ((function() {
        var i, len, ref, results;
        ref = this.$tabulate._keys;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          results.push(rpr(x));
        }
        return results;
      }).call(this)).join(', ');
      got = ((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = keys.length; i < len; i++) {
          x = keys[i];
          if (indexOf.call(this.$tabulate._keys, x) < 0) {
            results.push(rpr(x));
          }
        }
        return results;
      }).call(this)).join(', ');
      throw new Error("expected " + expected + ", got " + got);
    }
    S.width = (ref = settings['width']) != null ? ref : 20;
    S.spacing = (ref1 = settings['spacing']) != null ? ref1 : 'wide';
    S.columns = (ref2 = settings['columns']) != null ? ref2 : null;
    switch (S.spacing) {
      case 'wide':
        S._left = '│ ';
        S._mid = ' │ ';
        S._right = ' │';
        break;
      case 'tight':
        S._left = '│';
        S._mid = '│';
        S._right = '│';
        break;
      default:
        throw new Error("expected 'tight' or 'wide', got " + (rpr(S.spacing)) + " ");
    }
    S._slice = null;
    S._titles = null;
    switch (type = CND.type_of(S.columns)) {
      case 'null':
        null;
        break;
      case 'number':
        S._slice = S.columns;
        S.columns = null;
        break;
      default:
        throw new Error("type " + type + " not implemented for settings 'columns'");
    }
    S.widths = null;
    S.keys = null;
    S.titles = null;
    pipeline = [];
    pipeline = [$as_event(S), $read_parameters(S), $as_row(S), $finalize(S), $cleanup(S)];
    return this.new_stream({
      pipeline: pipeline
    });
  };

  this.$tabulate._keys = ['spacing', 'width', 'columns'];

  $as_event = function(S) {
    return $(function(data, send) {
      return send(['data', data]);
    });
  };

  as_text = function(x) {
    if (CND.isa_text(x)) {
      return x;
    } else {
      return rpr(x);
    }
  };

  $read_parameters = function(S) {
    return D.$on_first(function(event, send) {
      var _, data, idx, key, mark, type_of_data, widths;
      mark = event[0], data = event[1];
      send(event);
      if (mark !== 'data') {
        return;
      }
      send(['table', '']);
      if (S.keys == null) {
        switch (type_of_data = CND.type_of(data)) {
          case 'list':
            S.keys = (function() {
              var i, len, results;
              results = [];
              for (idx = i = 0, len = data.length; i < len; idx = ++i) {
                _ = data[idx];
                results.push(idx);
              }
              return results;
            })();
            break;
          case 'pod':
            S.keys = (function() {
              var results;
              results = [];
              for (key in data) {
                results.push(key);
              }
              return results;
            })();
            if (S.titles == null) {
              S.titles = S.keys;
            }
            break;
          default:
            return send.error(new Error("expected a list or a POD, got a " + type_of_data));
        }
        if (S._slice != null) {
          S.keys.length = S._slice;
        }
      }
      if (typeof widths === "undefined" || widths === null) {
        widths = (function() {
          var i, len, ref, results;
          ref = S.keys;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            key = ref[i];
            results.push(S.width);
          }
          return results;
        })();
      }
      if (S.titles != null) {
        if (S._slice != null) {
          S.titles.length = S._slice;
        }
        send(['table', as_row(S, S.titles)]);
      }
      return send(['table', '│──────────────────────│──────────────────────│']);
    });
  };

  as_row = (function(_this) {
    return function(S, data, keys) {
      var R, i, idx, j, key, len, ref, ref1, ref2, ref3, ref4;
      if (keys == null) {
        keys = null;
      }
      R = [];
      if (keys != null) {
        for (idx = i = 0, len = keys.length; i < len; idx = ++i) {
          key = keys[idx];
          R.push(to_width(as_text(data[key]), (ref = (ref1 = S.widths) != null ? ref1[idx] : void 0) != null ? ref : S.width));
        }
      } else {
        for (idx = j = 0, ref2 = data.length; 0 <= ref2 ? j < ref2 : j > ref2; idx = 0 <= ref2 ? ++j : --j) {
          R.push(to_width(as_text(data[idx]), (ref3 = (ref4 = S.widths) != null ? ref4[idx] : void 0) != null ? ref3 : S.width));
        }
      }
      return S._left + (R.join(S._mid)) + S._right;
    };
  })(this);

  $as_row = function(S) {
    return $(function(event, send) {
      var data, mark;
      mark = event[0], data = event[1];
      if (mark === 'data') {
        return send(['table', as_row(S, data, S.keys)]);
      }
      return send(event);
    });
  };

  $finalize = function(S) {
    return D.$on_stop(function(send) {
      send(['table', '│──────────────────────│──────────────────────│']);
      return send(['table', '']);
    });
  };

  $cleanup = function(S) {
    return $(function(event, send) {
      var data, mark;
      mark = event[0], data = event[1];
      if (mark === 'table') {
        send(data);
      }
      return null;
    });
  };

  (function(self) {
    var name, results, value;
    D = require('./main');
    results = [];
    for (name in self) {
      value = self[name];
      results.push(D[name] = value);
    }
    return results;
  })(this);

}).call(this);

//# sourceMappingURL=plugin-tabulate.js.map
