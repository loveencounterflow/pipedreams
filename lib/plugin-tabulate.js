// Generated by CoffeeScript 1.10.0
(function() {
  var $, $as_event, $as_row, $async, $cleanup, $finalize, $read_parameters, CND, D, _new_state, alert, as_row, as_text, badge, debug, help, keys_default, keys_toplevel, rpr, to_width, urge, values_alignment, values_overflow, warn,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS/PLUGIN-TABULATE';

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  D = require('./main');

  $ = D.$, $async = D.$async;

  to_width = require('to-width').to_width;


  /*
  
  
  ┌───┬───┐
  │   │   │
  ╞═══╪═══╡
  │   │   │
  ├───┼───┤
  │   │   │
  └───┴───┘
  
    l   c   r     l   c   r
  t ┌───┬───┐   t ╭───┬───╮
    │   │   │     │   │   │
  m ├───┼───┤   m ├───┼───┤
    │   │   │     │   │   │
  b └───┴───┘   b ╰───┴───╯
  
  lt    ┌             ╭
  ct    ┬             ┬
  rt    ┐             ╮
  lm    ├             ├
  cm    ┼             ┼
  rm    ┤             ┤
  lb    └             ╰
  cb    ┴             ┴
  rb    ┘             ╯
  hc    │             │
  vc    ─             ─
  
  settings =
  
    width:          <number>  ::                                                // 12
    alignment:      <text>    :: 'left' | 'right' | 'center' | 'justify'        // 'left'
    fit:            <number> | <null> ::                                        // null
    ellipsis:       <text>                                                      // '…'
    pad:            <number> | <text>                                           // ''
    overflow:       <text> :: 'hide' | 'show'                                   // 'show'
  
  
    widths:         <number>
    alignments:     [ <text> ]
    headings:       [ <text> ]
    keys:           [ <text> | <number> ]
  
  **Formatting modes**: When width is given and a number, relative mode is used; otherwise, absolute mode.
  
  In absolute mode, the width of a column in terms of character cells is either given by a column-specific
  setting in `settings[ 'widths' ]` or by the fallback value in `settings[ 'width' ]`. The resulting table
  will take up as many character cells as needed for each column, plus the ones needed for padding and
  borders.
  
  In relative mode, an attempt is made to keep the overall width of the table—including paddings and
  borders—to the number of character cells given in `settings[ 'fit' ]`. Columns widths given in `settings[
  'widths' ]` are interpreted as proportional to their sum; columns may stretch or shrink to meet the desired
  table width. Since a minimum width of two character cells must be assumed and there is no way to fit
  arbitrarily many columns into a finite table width, overflow may occur. When `settings[ 'overflow' ]` is set
  to `'show'`, then overlong lines may occur; if it is set to `'hide'`, overlong lines are truncated so that
  line wrap is avoided on terminals.
  
  **Keys, Column Headings, and Data Types**: PipeDreams `$tabulate` accepts data items from the stream and
  reformats them into a tabular format (or prints that table as a convenience shortcut). The table may or
  may not have headings; the incoming data items must either be lists of values or JS objects with key/value
  pairs (a.k.a. properties or attributes). The question is:
  
  **Q 1)** In what order is data be mapped to columns?
  **Q 2)** From which attributes of the streamed data do table contents come?
  **Q 3)** If headings are used, where do they come from?
  
  **A 1)** If the data events are lists, then columns will appear in the same order as in those events,
  naturally. With PODs (plain old dictionaries, a.k.a. JS objects), the matter is a bit more complicated: most
  JS engines used to iterate over object keys in insertion order (which is good), but V8 started a trend to
  treat keys that look like list indexes (such as `'3'` or `'756') and sort them first in numerical order.
  Whatever be the case, when the first data event comes down the stream and it is a POD, `$tabulate` will walk
  over its keys and save them for all subsequent rows. Thus, in the absence of other settings, the first data
  event determines how many columns from what attributes in which order are put into to the table. But see the
  next point.
  
  **A 2)** Point 1, above, explains the default behavior of `$tabulate` when no explicit setting is given. You
  can, however, specify your preferred selection and order of columns with the setting `keys`; when given,
  this should be a list of the keys used to access the values of each streamed data event; for example, if
  your data events look like `[ 'file', 'emerald.jpg', '~/downloads', '-rw-r-----', 109418, '2016-03-21
  17:57', ]`, you can specify `.pipe $tabulate keys: [ 2, 1, 4, ]` to display only folder, filename and size
  in the table.
  
  **A 3)** By default, `$tabulate` will display column headings in the first row of the table; this can be
  switched off with the setting `headings: false`. With the default setting or `true`, headings will be the
  keys used to access the data fields as discussed in point 2, above. When `headings` is a list, the list
  items become column headings; if that list has less items than the table has columns, the reamining headers
  are left blank; the same goes for intermittent elements that are set to `null`.
   */

  this.$show_table = function(settings) {
    throw new Error("not implemented");
  };

  _new_state = function(settings) {
    var S, keys, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
    S = {};

    /* TAINT better to use formal schema here? */
    if (!CND.is_subset((keys = Object.keys(settings)), keys_toplevel)) {
      throw new Error("### MEH 1 ### " + (rpr(keys)));
    }
    if (settings['default'] != null) {
      if (CND.is_subset((keys = Object.keys(settings['default'])), keys_default)) {
        throw new Error("### MEH 2 ### " + (rpr(keys)));
      }
    }
    if (settings['widths'] != null) {
      throw new Error("'widths' not yet supported");
    }
    if (settings['alignments'] != null) {
      throw new Error("'alignments' not yet supported");
    }
    S.width = (ref = settings['width']) != null ? ref : 12;
    S.alignment = (ref1 = settings['alignment']) != null ? ref1 : 'left';

    /*
    process.stdout.columns
     */
    S.fit = (ref2 = settings['fit']) != null ? ref2 : null;
    S.ellipsis = (ref3 = settings['ellipsis']) != null ? ref3 : '…';
    S.pad = (ref4 = settings['pad']) != null ? ref4 : '';
    S.overflow = (ref5 = settings['overflow']) != null ? ref5 : 'show';
    S.widths = (ref6 = settings['widths']) != null ? ref6 : [];
    S.alignments = (ref7 = settings['alignments']) != null ? ref7 : [];
    S.headings = (ref8 = settings['headings']) != null ? ref8 : true;
    S.keys = (ref9 = settings['keys']) != null ? ref9 : null;
    if (ref10 = S.alignment, indexOf.call(values_alignment, ref10) < 0) {
      throw new Error("### MEH 3 ### " + (rpr(S.alignment)));
    }
    if (ref11 = S.overflow, indexOf.call(values_overflow, ref11) < 0) {
      throw new Error("### MEH 4 ### " + (rpr(S.overflow)));
    }
    if (S.fit != null) {
      throw new Error("setting `fit` not yet implemented");
    }

    /* TAINT check widths are non-zero integers */

    /* TAINT check values in headings, widths, keys (?) */
    return S;
  };


  /*
    #.........................................................................................................
    unless CND.is_subset ( keys = Object.keys settings ), @$tabulate._keys
      expected  = ( rpr x for x in @$tabulate._keys                    ).join ', '
      got       = ( rpr x for x in keys when x not in @$tabulate._keys ).join ', '
      throw new Error "expected #{expected}, got #{got}"
  
    switch S.spacing
      when 'wide'
        S._left     =  '│ '
        S._mid      = ' │ '
        S._right    = ' │'
      when 'tight'
        S._left     = '│'
        S._mid      = '│'
        S._right    = '│'
   */

  keys_toplevel = ['default', 'widths', 'alignments', 'headings', 'keys', 'width', 'ellipsis', 'pad'];

  keys_default = ['width', 'alignment'];

  values_overflow = ['show', 'hide'];

  values_alignment = ['left', 'right', 'center', 'justify'];

  this.$tabulate = function(settings) {
    var S, pipeline;
    if (settings == null) {
      settings = {};
    }
    S = _new_state(settings);
    debug('4404', S);
    pipeline = [$as_event(S), $read_parameters(S), $as_row(S), $finalize(S), $cleanup(S)];
    return this.new_stream({
      pipeline: pipeline
    });
  };

  $as_event = function(S) {
    return $(function(data, send) {
      return send(['data', data]);
    });
  };

  as_text = function(x) {
    if (CND.isa_text(x)) {
      return x;
    } else {
      return rpr(x);
    }
  };

  $read_parameters = function(S) {
    return D.$on_first(function(event, send) {
      var _, base, data, i, idx, key, mark, ref, ref1;
      mark = event[0], data = event[1];
      send(event);
      if (mark !== 'data') {
        return;
      }
      if (S.keys == null) {
        if (CND.isa_list(data)) {
          S.keys = (function() {
            var i, len, results;
            results = [];
            for (idx = i = 0, len = data.length; i < len; idx = ++i) {
              _ = data[idx];
              results.push(idx);
            }
            return results;
          })();
        } else if (CND.isa_pod(data)) {
          S.keys = (function() {
            var results;
            results = [];
            for (key in data) {
              results.push(key);
            }
            return results;
          })();
        } else {
          return send.error(new Error("expected a list or a POD, got a " + (CND.type_of(data))));
        }
      }
      if (S.headings === true) {
        S.headings = S.keys;
      }
      if (S.widths != null) {
        for (idx = i = 0, ref = S.widths.length; 0 <= ref ? i < ref : i > ref; idx = 0 <= ref ? ++i : --i) {
          if ((base = S.widths)[idx] == null) {
            base[idx] = S.width;
          }
        }
      } else {
        S.widths = (function() {
          var j, len, ref1, results;
          ref1 = S.keys;
          results = [];
          for (j = 0, len = ref1.length; j < len; j++) {
            key = ref1[j];
            results.push(S.width);
          }
          return results;
        })();
      }
      if ((ref1 = S.headings) !== null && ref1 !== false) {
        return send(['table', as_row(S, S.headings)]);
      }
    });
  };

  as_row = (function(_this) {
    return function(S, data, keys) {
      var R, i, idx, j, key, len, ref, ref1, ref2, ref3, ref4;
      if (keys == null) {
        keys = null;
      }
      R = [];
      if (keys != null) {
        for (idx = i = 0, len = keys.length; i < len; idx = ++i) {
          key = keys[idx];
          R.push(to_width(as_text(data[key]), (ref = (ref1 = S.widths) != null ? ref1[idx] : void 0) != null ? ref : S.width));
        }
      } else {
        for (idx = j = 0, ref2 = data.length; 0 <= ref2 ? j < ref2 : j > ref2; idx = 0 <= ref2 ? ++j : --j) {
          R.push(to_width(as_text(data[idx]), (ref3 = (ref4 = S.widths) != null ? ref4[idx] : void 0) != null ? ref3 : S.width));
        }
      }
      return S._left + (R.join(S._mid)) + S._right;
    };
  })(this);

  $as_row = function(S) {
    return $(function(event, send) {
      var data, mark;
      mark = event[0], data = event[1];
      if (mark === 'data') {
        return send(['table', as_row(S, data, S.keys)]);
      }
      return send(event);
    });
  };

  $finalize = function(S) {
    return D.$on_stop(function(send) {});
  };

  $cleanup = function(S) {
    return $(function(event, send) {
      var data, mark;
      mark = event[0], data = event[1];
      if (mark === 'table') {
        send(data);
      }
      return null;
    });
  };

  (function(self) {
    var name, results, value;
    D = require('./main');
    results = [];
    for (name in self) {
      value = self[name];
      results.push(D[name] = value);
    }
    return results;
  })(this);

}).call(this);

//# sourceMappingURL=plugin-tabulate.js.map
