// Generated by CoffeeScript 1.10.0
(function() {
  var $, $as_event, $as_row, $async, $cleanup, $finalize, $read_parameters, CND, D, _new_state, alert, as_row, as_text, badge, debug, help, keys_default, keys_toplevel, rpr, to_width, urge, values_alignment, values_overflow, warn,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS/PLUGIN-TABULATE';

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  D = require('./main');

  $ = D.$, $async = D.$async;

  to_width = require('to-width').to_width;


  /*
  
  
  ┌───┬───┐
  │   │   │
  ╞═══╪═══╡
  │   │   │
  ├───┼───┤
  │   │   │
  └───┴───┘
  
    l   c   r     l   c   r
  t ┌───┬───┐   t ╭───┬───╮
    │   │   │     │   │   │
  m ├───┼───┤   m ├───┼───┤
    │   │   │     │   │   │
  b └───┴───┘   b ╰───┴───╯
  
  lt    ┌             ╭
  ct    ┬             ┬
  rt    ┐             ╮
  lm    ├             ├
  cm    ┼             ┼
  rm    ┤             ┤
  lb    └             ╰
  cb    ┴             ┴
  rb    ┘             ╯
  hc    │             │
  vc    ─             ─
  
  settings =
  
    width:          <number>  ::                                                // 12
    alignment:      <text>    :: 'left' | 'right' | 'center' | 'justify'        // 'left'
    fit:            <number> | <null> ::                                        // null
    ellipsis:       <text>                                                      // '…'
    pad:            <number> | <text>                                           // ''
    overflow:       <text> :: 'hide' | 'show'                                   // 'show'
  
  
    widths:         <number>
    alignments:     [ <text> ]
    titles:         [ <text> ]
    keys:           [ <text> | <number> ]
  
  **Formatting modes**: When width is given and a number, relative mode is used; otherwise, absolute mode.
  
  In absolute mode, the width of a column in terms of character cells is either given by a column-specific
  setting in `settings[ 'widths' ]` or by the fallback value in `settings[ 'width' ]`. The resulting table
  will take up as many character cells as needed for each column, plus the ones needed for padding and
  borders.
  
  In relative mode, an attempt is made to keep the overall width of the table—including paddings and
  borders—to the number of character cells given in `settings[ 'fit' ]`. Columns widths given in `settings[
  'widths' ]` are interpreted as proportional to their sum; columns may stretch or shrink to meet the desired
  table width. Since a minimum width of two character cells must be assumed and there is no way to fit
  arbitrarily many columns into a finite table width, overflow may occur. When `settings[ 'overflow' ]` is set
  to `'show'`, then overlong lines may occur; if it is set to `'hide'`, overlong lines are truncated so that
  line wrap is avoided on terminals.
   */

  this.$show_table = function(settings) {
    throw new Error("not implemented");
  };

  _new_state = function(settings) {
    var S, keys, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
    S = {};

    /* TAINT better to use formal schema here? */
    if (!CND.is_subset((keys = Object.keys(settings)), keys_toplevel)) {
      throw new Error("### MEH 1 ### " + (rpr(keys)));
    }
    if (settings['default'] != null) {
      if (CND.is_subset((keys = Object.keys(settings['default'])), keys_default)) {
        throw new Error("### MEH 2 ### " + (rpr(keys)));
      }
    }
    if (settings['widths'] != null) {
      throw new Error("'widths' not yet supported");
    }
    if (settings['alignments'] != null) {
      throw new Error("'alignments' not yet supported");
    }
    S.width = (ref = settings['width']) != null ? ref : 12;
    S.alignment = (ref1 = settings['alignment']) != null ? ref1 : 'left';
    S.fit = (ref2 = settings['fit']) != null ? ref2 : null;
    S.ellipsis = (ref3 = settings['ellipsis']) != null ? ref3 : '…';
    S.pad = (ref4 = settings['pad']) != null ? ref4 : '';
    S.overflow = (ref5 = settings['overflow']) != null ? ref5 : 'show';
    S.widths = (ref6 = settings['widths']) != null ? ref6 : [];
    S.alignments = (ref7 = settings['alignments']) != null ? ref7 : [];
    S.titles = (ref8 = settings['titles']) != null ? ref8 : null;
    S.keys = (ref9 = settings['keys']) != null ? ref9 : null;
    if (ref10 = S.alignment, indexOf.call(values_alignment, ref10) < 0) {
      throw new Error("### MEH 3 ### " + (rpr(S.alignment)));
    }
    if (ref11 = S.overflow, indexOf.call(values_overflow, ref11) < 0) {
      throw new Error("### MEH 4 ### " + (rpr(S.overflow)));
    }

    /* TAINT check widths are non-zero integers */

    /* TAINT check values in titles, widths, keys (?) */
    return S;
  };


  /*
    #.........................................................................................................
    unless CND.is_subset ( keys = Object.keys settings ), @$tabulate._keys
      expected  = ( rpr x for x in @$tabulate._keys                    ).join ', '
      got       = ( rpr x for x in keys when x not in @$tabulate._keys ).join ', '
      throw new Error "expected #{expected}, got #{got}"
  
    switch S.spacing
      when 'wide'
        S._left     =  '│ '
        S._mid      = ' │ '
        S._right    = ' │'
      when 'tight'
        S._left     = '│'
        S._mid      = '│'
        S._right    = '│'
   */

  keys_toplevel = ['default', 'widths', 'alignments', 'titles', 'keys', 'width', 'ellipsis', 'pad'];

  keys_default = ['width', 'alignment'];

  values_overflow = ['show', 'hide'];

  values_alignment = ['left', 'right', 'center', 'justify'];

  this.$tabulate = function(settings) {
    var S, pipeline;
    if (settings == null) {
      settings = {};
    }
    S = _new_state(settings);
    debug('4404', S);
    pipeline = [$as_event(S), $read_parameters(S), $as_row(S), $finalize(S), $cleanup(S)];
    return this.new_stream({
      pipeline: pipeline
    });
  };

  $as_event = function(S) {
    return $(function(data, send) {
      return send(['data', data]);
    });
  };

  as_text = function(x) {
    if (CND.isa_text(x)) {
      return x;
    } else {
      return rpr(x);
    }
  };

  $read_parameters = function(S) {
    return D.$on_first(function(event, send) {
      var _, data, idx, key, mark, type_of_data, widths;
      mark = event[0], data = event[1];
      send(event);
      if (mark !== 'data') {
        return;
      }
      send(['table', '']);
      if (S.keys == null) {
        switch (type_of_data = CND.type_of(data)) {
          case 'list':
            S.keys = (function() {
              var i, len, results;
              results = [];
              for (idx = i = 0, len = data.length; i < len; idx = ++i) {
                _ = data[idx];
                results.push(idx);
              }
              return results;
            })();
            break;
          case 'pod':
            S.keys = (function() {
              var results;
              results = [];
              for (key in data) {
                results.push(key);
              }
              return results;
            })();
            if (S.titles == null) {
              S.titles = S.keys;
            }
            break;
          default:
            return send.error(new Error("expected a list or a POD, got a " + type_of_data));
        }
        if (S._slice != null) {
          S.keys.length = S._slice;
        }
      }
      if (typeof widths === "undefined" || widths === null) {
        widths = (function() {
          var i, len, ref, results;
          ref = S.keys;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            key = ref[i];
            results.push(S.width);
          }
          return results;
        })();
      }
      if (S.titles != null) {
        if (S._slice != null) {
          S.titles.length = S._slice;
        }
        send(['table', as_row(S, S.titles)]);
      }
      return send(['table', '│──────────────────────│──────────────────────│']);
    });
  };

  as_row = (function(_this) {
    return function(S, data, keys) {
      var R, i, idx, j, key, len, ref, ref1, ref2, ref3, ref4;
      if (keys == null) {
        keys = null;
      }
      R = [];
      if (keys != null) {
        for (idx = i = 0, len = keys.length; i < len; idx = ++i) {
          key = keys[idx];
          R.push(to_width(as_text(data[key]), (ref = (ref1 = S.widths) != null ? ref1[idx] : void 0) != null ? ref : S.width));
        }
      } else {
        for (idx = j = 0, ref2 = data.length; 0 <= ref2 ? j < ref2 : j > ref2; idx = 0 <= ref2 ? ++j : --j) {
          R.push(to_width(as_text(data[idx]), (ref3 = (ref4 = S.widths) != null ? ref4[idx] : void 0) != null ? ref3 : S.width));
        }
      }
      return S._left + (R.join(S._mid)) + S._right;
    };
  })(this);

  $as_row = function(S) {
    return $(function(event, send) {
      var data, mark;
      mark = event[0], data = event[1];
      if (mark === 'data') {
        return send(['table', as_row(S, data, S.keys)]);
      }
      return send(event);
    });
  };

  $finalize = function(S) {
    return D.$on_stop(function(send) {
      send(['table', '│──────────────────────│──────────────────────│']);
      return send(['table', '']);
    });
  };

  $cleanup = function(S) {
    return $(function(event, send) {
      var data, mark;
      mark = event[0], data = event[1];
      if (mark === 'table') {
        send(data);
      }
      return null;
    });
  };

  (function(self) {
    var name, results, value;
    D = require('./main');
    results = [];
    for (name in self) {
      value = self[name];
      results.push(D[name] = value);
    }
    return results;
  })(this);

}).call(this);

//# sourceMappingURL=plugin-tabulate.js.map
