// Generated by CoffeeScript 1.8.0
(function() {
  var BNP, TEST, TRM, alert, badge, debug, echo, help, info, log, rpr, run, urge, warn, whisper,
    __slice = [].slice;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TEST';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  BNP = require('coffeenode-bitsnpieces');

  module.exports = run = function(x) {
    var T, arity, caller, check_count, entry, error, fail_count, failures, name, pass_count, target, test, test_count;
    T = {};
    test_count = 0;
    check_count = 0;
    pass_count = 0;
    fail_count = 0;
    failures = {};
    T.eq = function() {
      var P, error;
      P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];

      /* Tests whether all arguments are pairwise and deeply equal. Uses CoffeeNode Bits'n'Pieces' `equal`
      for testing as (1) Node's `assert` distinguishes—unnecessarily—between shallow and deep equality, and,
      worse, [`assert.equal` and `assert.deepEqual` are broken](https://github.com/joyent/node/issues/7161),
      as they use JavaScript's broken `==` equality operator instead of `===`.
       */
      check_count += 1;
      if (BNP.equals.apply(BNP, P)) {
        return pass_count += 1;
      } else {
        fail_count += 1;
        error = new Error("not equal: " + (rpr(P)));
        error['caller'] = TEST.get_caller_description(1);
        throw error;
      }
    };
    T.rsvp = function(callback) {
      debug('©phhjN', BNP.get_caller_locators(delta));
      return (function(_this) {
        return function() {
          var P, error;
          error = arguments[0], P = 2 <= arguments.length ? __slice.call(arguments, 1) : [];

          /* TAINT need better error handling */
          if (error != null) {
            throw error;
          }
          return callback.apply(null, P);
        };
      })(this);
    };
    T.ok = function(result) {

      /* Tests whether `result` is strictly `true` (not only true-ish). */
      if (result !== true) {
        throw new Error("expected true, got " + (rpr(result)));
      }
    };
    T.fail = function(message) {
      debug('©9HhEC', BNP.get_caller_locators(delta));
      throw new Error(message);
    };
    for (name in x) {
      test = x[name];
      test = test.bind(x);
      test_count += 1;
      switch (arity = test.length) {
        case 1:
          try {
            test(T);
          } catch (_error) {
            error = _error;

            /* NB `entry[ 'name' ]` should normally match `entry[ 'caller' ][ 'name' ]` */
            caller = error['caller'];
            entry = {
              'name': name,
              'message': error['message'],
              'caller': caller
            };
            if (caller == null) {
              fail_count += 1;
            }
            target = failures[name] != null ? failures[name] : failures[name] = [];
            target.push([entry]);
          }
          break;
        case 2:

          /* TAINT need ASYNC or similar to manage callbacks in concert with synhronous code */
          test(T, (function(_this) {
            return function(error) {
              if (error != null) {
                throw error;
              }
            };
          })(this));
          break;
        default:
          throw new Error("expected test with 1 or 2 arguments, got one with " + arity);
      }
    }
    info('test_count:   ', test_count);
    info('check_count:  ', check_count);
    info('pass_count:   ', pass_count);
    info('fail_count:   ', fail_count);
    return info('failures:     ', failures);
  };

  this.get_caller_description = function(delta) {
    var locator;
    if (delta == null) {
      delta = 1;
    }
    locator = (BNP.get_caller_locators(delta + 1))[0];
    return BNP.caller_description_from_locator(locator);
  };

  TEST = this;

}).call(this);
