// Generated by CoffeeScript 2.3.1
(function() {
  'use strict';
  var $, $add_data_region, $as_event, $async, CND, L, PD, badge, debug, defer, echo, help, info, jr, rpr, select, stamp, test, urge, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS/TESTS/SELECT';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  test = require('guy-test');

  ({jr} = CND);

  //...........................................................................................................
  L = require('../select');

  PD = require('../..');

  ({$, $async, select, stamp} = PD);

  defer = setImmediate;

  //-----------------------------------------------------------------------------------------------------------
  $add_data_region = function() {
    var is_first;
    is_first = true;
    return $('null', function(d, send) {
      if (is_first) {
        send(PD.new_event('[data'));
        is_first = false;
      }
      if (d != null) {
        return send(d);
      } else {
        return send(PD.new_event(']data'));
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  $as_event = function() {
    return $(function(x, send) {
      var type;
      type = CND.type_of(x);
      if (type === 'pod') {
        return send(x);
      }
      if (type === 'number') {
        return send(PD.new_single_event('number', x));
      }
      if ((type === 'text') && (x.startsWith('~'))) {
        return send(PD.new_system_event(x.slice(1)));
      }
      if (type === 'text') {
        return send(PD.new_single_event('text', x));
      }
      throw new Error(`Âµ93883 unhandled type ${rpr(type)}`);
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this["$collect 1"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        [null,
        [1,
        2,
        3,
        4,
        5,
        6]],
        [
          {
            "key": "[data"
          },
          {
            "key": "^collection",
            "value": [
              {
                "key": "^number",
                "value": 1
              },
              {
                "key": "^number",
                "value": 2
              },
              {
                "key": "^number",
                "value": 3
              },
              {
                "key": "^number",
                "value": 4
              },
              {
                "key": "^number",
                "value": 5
              },
              {
                "key": "^number",
                "value": 6
              }
            ]
          },
          {
            "key": "]data"
          }
        ],
        null
      ],
      [
        [
          {
            "value": true
          },
          [1,
          2,
          3,
          4,
          5,
          6]
        ],
        [
          {
            "key": "[data"
          },
          {
            "key": "^collection",
            "value": [1,
          2,
          3,
          4,
          5,
          6]
          },
          {
            "key": "]data"
          }
        ],
        null
      ],
      [
        [
          {
            "value": true
          },
          [1,
          2,
          3,
          "~collect",
          4,
          5,
          6]
        ],
        [
          {
            "key": "[data"
          },
          {
            "key": "^collection",
            "value": [1,
          2,
          3]
          },
          {
            "key": "~collect"
          },
          {
            "key": "^collection",
            "value": [4,
          5,
          6]
          },
          {
            "key": "]data"
          }
        ],
        null
      ]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        return new Promise(function(resolve, reject) {
          var R, inputs, parameters, pipeline;
          [parameters, inputs] = probe;
          R = [];
          pipeline = [];
          pipeline.push(PD.new_value_source(inputs));
          pipeline.push($add_data_region());
          pipeline.push($as_event());
          pipeline.push(PD.$watch(function(d) {
            return whisper(jr(d));
          }));
          pipeline.push(PD.$collect(parameters));
          pipeline.push(PD.$watch(function(d) {
            return urge(jr(d));
          }));
          pipeline.push(PD.$watch(function(d) {
            return R.push(d);
          }));
          pipeline.push(PD.$drain(function() {
            return resolve(R);
          }));
          return PD.pull(...pipeline);
        });
      });
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["$collect with callback"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        [
          {
            "value": true
          },
          [1,
          2,
          3,
          4,
          5,
          6]
        ],
        [
          [[1,
          2,
          3,
          4,
          5,
          6]],
          [
            {
              "key": "[data"
            },
            {
              "key": "]data"
            }
          ]
        ],
        null
      ],
      [
        [
          {
            "value": true,
            "select": "number"
          },
          [1,
          2,
          3,
          "between",
          4,
          5,
          6]
        ],
        [
          [[1,
          2,
          3],
          [4,
          5,
          6]],
          [
            {
              "key": "[data"
            },
            {
              "key": "^text",
              "value": "between"
            },
            {
              "key": "]data"
            }
          ]
        ],
        null
      ]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        return new Promise(function(resolve, reject) {
          var R, collections, drainer, inputs, parameters, pipeline, remaining;
          [parameters, inputs] = probe;
          collections = [];
          remaining = [];
          R = [collections, remaining];
          //...................................................................................................
          parameters.callback = function(collection) {
            return collections.push(collection);
          };
          drainer = function() {
            return resolve(R);
          };
          //...................................................................................................
          pipeline = [];
          pipeline.push(PD.new_value_source(inputs));
          pipeline.push($add_data_region());
          pipeline.push($as_event());
          // pipeline.push PD.$show()
          pipeline.push(PD.$collect(parameters));
          pipeline.push(PD.$watch(function(d) {
            return remaining.push(d);
          }));
          pipeline.push(PD.$drain(drainer));
          return PD.pull(...pipeline);
        });
      });
    }
    done();
    return null;
  };

  //###########################################################################################################
  if (module.parent == null) {
    test(this);
  }

  // test @[ "$collect with callback" ]

}).call(this);

//# sourceMappingURL=collect.test.js.map
