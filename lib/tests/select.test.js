// Generated by CoffeeScript 2.3.1
(function() {
  //###########################################################################################################
  var CND, _classify_selector, _keypattern, _match_keypattern, _select_one, _tag_from_selector, badge, debug, echo, f, help, info, jr, rpr, select, test, urge, warn, whisper,
    indexOf = [].indexOf;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS/TESTS/SELECT';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  test = require('guy-test');

  jr = JSON.stringify;

  //...........................................................................................................
  // PS                        = require '../..'
  // { $, $async, }            = PS

  //-----------------------------------------------------------------------------------------------------------
  this._prune = function() {
    var name, ref, value;
    ref = this;
    for (name in ref) {
      value = ref[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  select = function(d, ...selectors) {
    var i, len, selector;
    if (selectors.length === 0) {
      throw new Error("µ29929 expected selectors, got none");
    }
    for (i = 0, len = selectors.length; i < len; i++) {
      selector = selectors[i];
      if (!_select_one(selector)) {
        return false;
      }
    }
    return true;
  };

  //-----------------------------------------------------------------------------------------------------------
  _keypattern = /^(?<sigils>[<^>~]*)\s*(?:(?<prefix>[^:<^>~\s]+?):)?\s*(?<name>[^:<^>~\s]*)$/;

  //-----------------------------------------------------------------------------------------------------------
  _tag_from_selector = function(selector) {
    if (!((CND.isa_text(selector)) && (selector.startsWith('#')) && (selector.length > 1))) {
      /* Return tag if `selector` is marked as tag selector, `null` otherwise. */
      return null;
    }
    return selector.slice(1);
  };

  //-----------------------------------------------------------------------------------------------------------
  _classify_selector = function(selector) {
    var match, tag, type;
    if (CND.isa_function(selector)) {
      return ['function', selector];
    }
    if ((type = CND.type_of(selector)) !== 'text') {
      throw new Error(`µ99843 expected a text, got a ${type}`);
    }
    if ((tag = _tag_from_selector(selector)) != null) {
      return ['tag', tag];
    }
    if ((match = selector.match(_keypattern)) != null) {
      return ['keypattern', match.groups];
    }
    throw new Error(`µ99843 illegal selector ${rpr(selector)}`);
  };

  //-----------------------------------------------------------------------------------------------------------
  _match_keypattern = function(d_key, keypattern) {
    var match, name_ok, prefix_ok, sigil, sigils_ok;
    if (!((CND.isa_text(d_key)) && (d_key.length > 1))) {
      throw new Error(`µ77784 illegal event key ${rpr(d_key)}`);
    }
    sigil = d_key[0];
    if (!(indexOf.call('<^>~', sigil) >= 0)) {
      throw new Error(`µ77784 event key ${rpr(d_key)} has illegal sigil ${rpr(sigil)}`);
    }
    sigils_ok = indexOf.call(keypattern.sigils, sigil) >= 0;
    if (!sigils_ok) {
      return false;
    }
    if ((match = d_key.match(_keypattern)) == null) {
      //.........................................................................................................
      throw new Error(`µ77784 illegal event key ${rpr(d_key)}`);
    }
    if ((keypattern.prefix != null) && (keypattern.prefix !== '*')) {
      prefix_ok = match.groups.prefix === keypattern.prefix;
      if (!prefix_ok) {
        return false;
      }
    }
    //.........................................................................................................
    if ((keypattern.name != null) && (keypattern.name.length > 0)) {
      name_ok = keypattern.name === match.groups.name;
      if (!name_ok) {
        return false;
      }
    }
    //.........................................................................................................
    return true;
  };

  //-----------------------------------------------------------------------------------------------------------
  _select_one = function(d, selector) {
    var clasz;
    [clasz, selector] = _classify_selector(selector);
    switch (clasz) {
      case 'function':
        return selector(d);
      case 'tag':
        return _match_tag(d, selector);
      case 'keypattern':
        return _match_keypattern(d, selector);
    }
    throw new Error(`µ37373 illegal selector class ${rpr(clasz)}`);
  };

  //-----------------------------------------------------------------------------------------------------------
  f = async function(T, method, probe, matcher, errmsg_pattern) {
    var error, result;
    errmsg_pattern = errmsg_pattern != null ? new RegExp(errmsg_pattern) : null;
    try {
      result = (await method());
    } catch (error1) {
      error = error1;
      // throw error
      if ((errmsg_pattern != null) && (errmsg_pattern.test(error.message))) {
        echo(CND.green(jr([probe, null, errmsg_pattern.source])));
        T.ok(true);
      } else {
        echo(CND.orange(jr([probe, null, error.message])));
      }
      // return reject "failed with #{error.message}"
      return null;
    }
    if (CND.equals(result, matcher)) {
      T.ok(true);
      echo(CND.lime(jr([probe, result, null])));
    } else {
      T.fail(`neq: result ${jr(result)}, matcher ${jr(matcher)}`);
      echo(CND.red(jr([probe, result, null])));
    }
    // return resolve result
    return result;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["keypattern"] = async function(T, done) {
    var errmsg_pattern, i, len, matcher, method, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        "",
        {
          "sigils": "",
          "name": ""
        },
        null
      ],
      [
        "^foo",
        {
          "sigils": "^",
          "name": "foo"
        },
        null
      ],
      [
        "<foo",
        {
          "sigils": "<",
          "name": "foo"
        },
        null
      ],
      [
        "  ",
        {
          "sigils": "",
          "name": ""
        },
        null
      ],
      [
        ">foo",
        {
          "sigils": ">",
          "name": "foo"
        },
        null
      ],
      [
        "<>foo",
        {
          "sigils": "<>",
          "name": "foo"
        },
        null
      ],
      [
        "<>^foo",
        {
          "sigils": "<>^",
          "name": "foo"
        },
        null
      ],
      [
        "^ foo",
        {
          "sigils": "^",
          "name": "foo"
        },
        null
      ],
      [
        "<  foo",
        {
          "sigils": "<",
          "name": "foo"
        },
        null
      ],
      [
        "> foo",
        {
          "sigils": ">",
          "name": "foo"
        },
        null
      ],
      [
        "<> foo",
        {
          "sigils": "<>",
          "name": "foo"
        },
        null
      ],
      [
        "^<> foo",
        {
          "sigils": "^<>",
          "name": "foo"
        },
        null
      ],
      ['< > ^ foo',
      null,
      "Cannot read property 'groups' of null"],
      [
        "^prfx:foo",
        {
          "sigils": "^",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<prfx:foo",
        {
          "sigils": "<",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        ">prfx:foo",
        {
          "sigils": ">",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<>prfx:foo",
        {
          "sigils": "<>",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<>^prfx:foo",
        {
          "sigils": "<>^",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "^ prfx: foo",
        {
          "sigils": "^",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<  prfx: foo",
        {
          "sigils": "<",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "> prfx: foo",
        {
          "sigils": ">",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<> prfx: foo",
        {
          "sigils": "<>",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "^<> prfx: foo",
        {
          "sigils": "^<>",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      ["< > ^ prfx: foo",
      null,
      "Cannot read property 'groups' of null"],
      [
        "^<>",
        {
          "sigils": "^<>",
          "name": ""
        },
        null
      ]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, errmsg_pattern] = probes_and_matchers[i];
      method = function() {
        var R, key, ref, ref1, value;
        R = (ref = (ref1 = probe.match(_keypattern)) != null ? ref1.groups : void 0) != null ? ref : null;
        if (R == null) {
          return null;
        }
        for (key in R) {
          value = R[key];
          if (value === void 0) {
            delete R[key];
          }
        }
        return R;
      };
      await f(T, method, probe, matcher, errmsg_pattern);
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["select 1"] = async function(T, done) {
    var errmsg_pattern, i, len, matcher, method, probe, probes_and_matchers;
    probes_and_matchers = [[['^frob', '^frob'], true], [['^frob', '<frob'], false], [['^frob', '<>frob'], false], [['^frob', '<^>frob'], true], [['^frob', '<>^frob'], true], [['<frob', '<>^frob'], true], [['>frob', '<>^frob'], true], [['frob', '<>^frob'], null, "event key 'frob' has illegal sigil 'f'"], [['~copy', '~frob'], false], [['~copy', '~copy'], true], [['~copy', '^~copy'], true], [['~copy', '<>^~copy'], true]];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, errmsg_pattern] = probes_and_matchers[i];
      method = function() {
        var d, selector;
        [d, selector] = probe;
        return _select_one(d, selector);
      };
      await f(T, method, probe, matcher, errmsg_pattern);
    }
    done();
    return null;
  };

  //###########################################################################################################
  if (module.parent == null) {
    // include = [
    //   "async 1"
    //   "async 1 paramap"
    //   "async 2"
    //   ]
    // @_prune()
    test(this);
  }

}).call(this);

//# sourceMappingURL=select.test.js.map
