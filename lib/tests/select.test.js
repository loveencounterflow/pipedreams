// Generated by CoffeeScript 2.4.1
(function() {
  'use strict';
  var CND, L, PD, badge, debug, echo, help, info, jr, rpr, test, urge, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS/TESTS/SELECT';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  test = require('guy-test');

  jr = JSON.stringify;

  //...........................................................................................................
  L = require('../select');

  PD = require('../..');

  // { $, $async, }            = PD

  //-----------------------------------------------------------------------------------------------------------
  this["selector keypatterns"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        "",
        {
          "sigils": "",
          "name": ""
        },
        null
      ],
      [
        "^foo",
        {
          "sigils": "^",
          "name": "foo"
        },
        null
      ],
      [
        "<foo",
        {
          "sigils": "<",
          "name": "foo"
        },
        null
      ],
      ["  ",
      null,
      null],
      [
        ">foo",
        {
          "sigils": ">",
          "name": "foo"
        },
        null
      ],
      [
        "<>foo",
        {
          "sigils": "<>",
          "name": "foo"
        },
        null
      ],
      [
        "<>^foo",
        {
          "sigils": "<>^",
          "name": "foo"
        },
        null
      ],
      ["^ foo",
      null,
      null],
      [
        "^prfx:foo",
        {
          "sigils": "^",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<prfx:foo",
        {
          "sigils": "<",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        ">prfx:foo",
        {
          "sigils": ">",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<>prfx:foo",
        {
          "sigils": "<>",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<>^prfx:foo",
        {
          "sigils": "<>^",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "^<>",
        {
          "sigils": "^<>",
          "name": ""
        },
        null
      ]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        var R, key, ref, ref1, value;
        R = (ref = (ref1 = probe.match(L._selector_keypattern)) != null ? ref1.groups : void 0) != null ? ref : null;
        if (R == null) {
          return null;
        }
        for (key in R) {
          value = R[key];
          if (value === void 0) {
            delete R[key];
          }
        }
        return R;
      });
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["datom keypatterns"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [
      ["text",
      null,
      null],
      [
        "^text",
        {
          "sigil": "^",
          "name": "text"
        },
        null
      ],
      [
        "<bold",
        {
          "sigil": "<",
          "name": "bold"
        },
        null
      ],
      [
        ">bold",
        {
          "sigil": ">",
          "name": "bold"
        },
        null
      ],
      [
        "~collect",
        {
          "sigil": "~",
          "name": "collect"
        },
        null
      ],
      [
        "~kwic:collect",
        {
          "sigil": "~",
          "prefix": "kwic",
          "name": "collect"
        },
        null
      ],
      [
        "<kwic:bar",
        {
          "sigil": "<",
          "prefix": "kwic",
          "name": "bar"
        },
        null
      ],
      [
        ">kwic:bar",
        {
          "sigil": ">",
          "prefix": "kwic",
          "name": "bar"
        },
        null
      ],
      [">!kwic:bar",
      null,
      null],
      ["<>kwic:bar",
      null,
      null]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        var R, key, ref, ref1, value;
        R = (ref = (ref1 = probe.match(L._datom_keypattern)) != null ? ref1.groups : void 0) != null ? ref : null;
        if (R == null) {
          return null;
        }
        for (key in R) {
          value = R[key];
          if (value === void 0) {
            delete R[key];
          }
        }
        return R;
      });
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["classify_selector"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [
      ["#justatag",
      ["tag",
      "justatag"],
      null],
      [
        "^bar",
        [
          "keypattern",
          {
            "sigils": "^",
            "name": "bar"
          }
        ],
        null
      ],
      ["!!!(->)",
      ["function",
      null],
      null]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        var R, key, ref, value;
        if (probe.startsWith('!!!')) {
          probe = (function() {});
        }
        R = L._classify_selector(probe);
        if (R[0] === 'keypattern') {
          ref = R[1];
          for (key in ref) {
            value = ref[key];
            if (value === void 0) {
              delete R[1][key];
            }
          }
        } else if (R[0] === 'function') {
          R[1] = null;
        }
        return R;
      });
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["select 2"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        [
          {
            key: '^number',
            value: 42
          },
          '^number'
        ],
        true
      ],
      [
        [
          {
            key: '^number',
            value: 42,
            stamped: true
          },
          '^number'
        ],
        false
      ],
      [
        [
          {
            key: '^number',
            value: 42,
            stamped: true
          },
          '#stamped',
          '^number'
        ],
        true
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          '#stamped',
          '<italic'
        ],
        true
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          '#stamped',
          '>italic'
        ],
        false
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          '#stamped',
          '<>italic'
        ],
        true
      ],
      [
        [
          {
            key: '<italic'
          },
          '#stamped',
          '<italic'
        ],
        true
      ],
      [
        [
          {
            key: '<italic'
          },
          '#stamped',
          '>italic'
        ],
        false
      ],
      [
        [
          {
            key: '<italic'
          },
          '#stamped',
          '<>italic'
        ],
        true
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          '<italic'
        ],
        false
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          '>italic'
        ],
        false
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          '<>italic'
        ],
        false
      ],
      [
        [
          {
            key: "*data"
          },
          '*data'
        ],
        null,
        'illegal key or selector'
      ],
      [
        [
          {
            key: "data>"
          },
          'data>'
        ],
        null,
        'illegal key or selector'
      ],
      [
        [
          {
            key: "%data"
          },
          '%data'
        ],
        null,
        'illegal key or selector'
      ],
      [
        [
          {
            key: "[data"
          },
          '[data'
        ],
        true,
        null
      ],
      [
        [
          {
            key: "data]"
          },
          'data]'
        ],
        null,
        'illegal key or selector'
      ],
      [
        [
          {
            key: "]data"
          },
          ']data'
        ],
        true,
        null
      ]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        var d, selectors;
        [d, ...selectors] = probe;
        return PD.select(d, ...selectors);
      });
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["select 2 using lists"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        [
          {
            key: '^number',
            value: 42
          },
          ['^number']
        ],
        true
      ],
      [
        [
          {
            key: '^number',
            value: 42,
            stamped: true
          },
          ['^number']
        ],
        false
      ],
      [
        [
          {
            key: '^number',
            value: 42,
            stamped: true
          },
          ['#stamped',
          '^number']
        ],
        true
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          ['#stamped',
          '<italic']
        ],
        true
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          ['#stamped',
          '>italic']
        ],
        false
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          ['#stamped',
          '<>italic']
        ],
        true
      ],
      [
        [
          {
            key: '<italic'
          },
          ['#stamped',
          '<italic']
        ],
        true
      ],
      [
        [
          {
            key: '<italic'
          },
          ['#stamped',
          '>italic']
        ],
        false
      ],
      [
        [
          {
            key: '<italic'
          },
          ['#stamped',
          '<>italic']
        ],
        true
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          ['<italic']
        ],
        false
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          ['>italic']
        ],
        false
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          ['<>italic']
        ],
        false
      ]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        var d, selectors;
        [d, ...selectors] = probe;
        return PD.select(d, ...selectors);
      });
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["select 3"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        [
          {
            key: '^number',
            value: 42
          },
          '^number',
          "( d ) => d.value > 42"
        ],
        false
      ],
      [
        [
          {
            key: '^number',
            value: 44
          },
          '^number',
          "( d ) => d.value > 42"
        ],
        true
      ]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        var d, selectors;
        [d, ...selectors] = probe;
        selectors[selectors.length - 1] = eval(selectors[selectors.length - 1]);
        return PD.select(d, ...selectors);
      });
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["select ignores values other than PODs"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [[[null, '^number'], false], [[123, '^number'], false]];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        return new Promise(function(resolve, reject) {
          var d, selector;
          [d, selector] = probe;
          try {
            resolve(PD.select(d, selector));
          } catch (error1) {
            error = error1;
            return resolve(error.message);
          }
          return null;
        });
      });
    }
    done();
    return null;
  };

  //###########################################################################################################
  if (module.parent == null) {
    test(this);
  }

  // test @[ "selector keypatterns" ]
// test @[ "select 2" ]

}).call(this);

//# sourceMappingURL=select.test.js.map
