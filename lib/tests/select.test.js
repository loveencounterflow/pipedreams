// Generated by CoffeeScript 2.3.1
(function() {
  'use strict';
  var CND, L, badge, debug, echo, f, help, info, jr, rpr, test, urge, warn, whisper,
    indexOf = [].indexOf;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS/TESTS/SELECT';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  test = require('guy-test');

  jr = JSON.stringify;

  //...........................................................................................................
  L = require('../select');

  // PS                        = require '../..'
  // { $, $async, }            = PS

  //-----------------------------------------------------------------------------------------------------------
  this._prune = function() {
    var name, ref, value;
    ref = this;
    for (name in ref) {
      value = ref[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  f = async function(T, method, probe, matcher, errmsg_pattern) {
    var error, result;
    errmsg_pattern = errmsg_pattern != null ? new RegExp(errmsg_pattern) : null;
    try {
      result = (await method());
    } catch (error1) {
      error = error1;
      // throw error
      if ((errmsg_pattern != null) && (errmsg_pattern.test(error.message))) {
        echo(CND.green(jr([probe, null, errmsg_pattern.source])));
        T.ok(true);
      } else {
        echo(CND.orange(jr([probe, null, error.message])));
      }
      // return reject "failed with #{error.message}"
      return null;
    }
    if (CND.equals(result, matcher)) {
      T.ok(true);
      echo(CND.lime(jr([probe, result, null])));
    } else {
      T.fail(`neq: result ${jr(result)}, matcher ${jr(matcher)}`);
      echo(CND.red(jr([probe, result, null])));
    }
    // return resolve result
    return result;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["keypattern"] = async function(T, done) {
    var errmsg_pattern, i, len, matcher, method, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        "",
        {
          "sigils": "",
          "name": ""
        },
        null
      ],
      [
        "^foo",
        {
          "sigils": "^",
          "name": "foo"
        },
        null
      ],
      [
        "<foo",
        {
          "sigils": "<",
          "name": "foo"
        },
        null
      ],
      [
        "  ",
        {
          "sigils": "",
          "name": ""
        },
        null
      ],
      [
        ">foo",
        {
          "sigils": ">",
          "name": "foo"
        },
        null
      ],
      [
        "<>foo",
        {
          "sigils": "<>",
          "name": "foo"
        },
        null
      ],
      [
        "<>^foo",
        {
          "sigils": "<>^",
          "name": "foo"
        },
        null
      ],
      [
        "^ foo",
        {
          "sigils": "^",
          "name": "foo"
        },
        null
      ],
      [
        "<  foo",
        {
          "sigils": "<",
          "name": "foo"
        },
        null
      ],
      [
        "> foo",
        {
          "sigils": ">",
          "name": "foo"
        },
        null
      ],
      [
        "<> foo",
        {
          "sigils": "<>",
          "name": "foo"
        },
        null
      ],
      [
        "^<> foo",
        {
          "sigils": "^<>",
          "name": "foo"
        },
        null
      ],
      ['< > ^ foo',
      null,
      "Cannot read property 'groups' of null"],
      [
        "^prfx:foo",
        {
          "sigils": "^",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<prfx:foo",
        {
          "sigils": "<",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        ">prfx:foo",
        {
          "sigils": ">",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<>prfx:foo",
        {
          "sigils": "<>",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<>^prfx:foo",
        {
          "sigils": "<>^",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "^ prfx: foo",
        {
          "sigils": "^",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<  prfx: foo",
        {
          "sigils": "<",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "> prfx: foo",
        {
          "sigils": ">",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<> prfx: foo",
        {
          "sigils": "<>",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "^<> prfx: foo",
        {
          "sigils": "^<>",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      ["< > ^ prfx: foo",
      null,
      "Cannot read property 'groups' of null"],
      [
        "^<>",
        {
          "sigils": "^<>",
          "name": ""
        },
        null
      ]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, errmsg_pattern] = probes_and_matchers[i];
      method = function() {
        var R, key, ref, ref1, value;
        R = (ref = (ref1 = probe.match(L._keypattern)) != null ? ref1.groups : void 0) != null ? ref : null;
        if (R == null) {
          return null;
        }
        for (key in R) {
          value = R[key];
          if (value === void 0) {
            delete R[key];
          }
        }
        return R;
      };
      await f(T, method, probe, matcher, errmsg_pattern);
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["select 1"] = async function(T, done) {
    var errmsg_pattern, i, len, matcher, method, probe, probes_and_matchers;
    probes_and_matchers = [[['^frob', '^frob'], true], [['^frob', '<frob'], false], [['^frob', '<>frob'], false], [['^frob', '<^>frob'], true], [['^frob', '<>^frob'], true], [['<frob', '<>^frob'], true], [['>frob', '<>^frob'], true], [['frob', '<>^frob'], null, "event key 'frob' has illegal sigil 'f'"], [['~copy', '~frob'], false], [['~copy', '~copy'], true], [['~copy', '^~copy'], true], [['~copy', '<>^~copy'], true]];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, errmsg_pattern] = probes_and_matchers[i];
      method = function() {
        var d, selector;
        [d, selector] = probe;
        return L._select_one(d, selector);
      };
      await f(T, method, probe, matcher, errmsg_pattern);
    }
    done();
    return null;
  };

  //###########################################################################################################
  if (module.parent == null) {
    // include = [
    //   "async 1"
    //   "async 1 paramap"
    //   "async 2"
    //   ]
    // @_prune()
    test(this);
  }

}).call(this);

//# sourceMappingURL=select.test.js.map
