// Generated by CoffeeScript 2.3.1
(function() {
  'use strict';
  var CND, L, PD, badge, debug, echo, f, help, info, jr, rpr, test, urge, warn, whisper,
    indexOf = [].indexOf;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS/TESTS/SELECT';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  test = require('guy-test');

  jr = JSON.stringify;

  //...........................................................................................................
  L = require('../select');

  PD = require('../..');

  // { $, $async, }            = PD

  //-----------------------------------------------------------------------------------------------------------
  this._prune = function() {
    var name, ref, value;
    ref = this;
    for (name in ref) {
      value = ref[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  f = async function(T, method, probe, matcher, errmsg_pattern) {
    var error, result;
    errmsg_pattern = errmsg_pattern != null ? new RegExp(errmsg_pattern) : null;
    try {
      result = (await method());
    } catch (error1) {
      error = error1;
      // throw error
      if ((errmsg_pattern != null) && (errmsg_pattern.test(error.message))) {
        echo(CND.green(jr([probe, null, errmsg_pattern.source])));
        T.ok(true);
      } else {
        echo(CND.indigo("unexpected exception", jr([probe, null, error.message])));
        T.fail(`unexpected exception for probe ${jr(probe)}:\n${error.message}`);
      }
      // return reject "failed with #{error.message}"
      return null;
    }
    if (CND.equals(result, matcher)) {
      T.ok(true);
      echo(CND.lime(jr([probe, result, null])));
    } else {
      T.fail(`neq: result ${jr(result)}, matcher ${jr(matcher)}`);
      echo(CND.red(jr([probe, result, null])));
    }
    // return resolve result
    return result;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["selector keypatterns"] = async function(T, done) {
    var errmsg_pattern, i, len, matcher, method, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        "",
        {
          "sigils": "",
          "name": ""
        },
        null
      ],
      [
        "^foo",
        {
          "sigils": "^",
          "name": "foo"
        },
        null
      ],
      [
        "<foo",
        {
          "sigils": "<",
          "name": "foo"
        },
        null
      ],
      ["  ",
      null,
      null],
      [
        ">foo",
        {
          "sigils": ">",
          "name": "foo"
        },
        null
      ],
      [
        "<>foo",
        {
          "sigils": "<>",
          "name": "foo"
        },
        null
      ],
      [
        "<>^foo",
        {
          "sigils": "<>^",
          "name": "foo"
        },
        null
      ],
      ["^ foo",
      null,
      null],
      [
        "^prfx:foo",
        {
          "sigils": "^",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<prfx:foo",
        {
          "sigils": "<",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        ">prfx:foo",
        {
          "sigils": ">",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<>prfx:foo",
        {
          "sigils": "<>",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "<>^prfx:foo",
        {
          "sigils": "<>^",
          "prefix": "prfx",
          "name": "foo"
        },
        null
      ],
      [
        "^<>",
        {
          "sigils": "^<>",
          "name": ""
        },
        null
      ]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, errmsg_pattern] = probes_and_matchers[i];
      method = function() {
        var R, key, ref, ref1, value;
        R = (ref = (ref1 = probe.match(L._selector_keypattern)) != null ? ref1.groups : void 0) != null ? ref : null;
        if (R == null) {
          return null;
        }
        for (key in R) {
          value = R[key];
          if (value === void 0) {
            delete R[key];
          }
        }
        return R;
      };
      await f(T, method, probe, matcher, errmsg_pattern);
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["event keypatterns"] = async function(T, done) {
    var errmsg_pattern, i, len, matcher, method, probe, probes_and_matchers;
    probes_and_matchers = [
      ["text",
      null,
      null],
      [
        "^text",
        {
          "sigil": "^",
          "name": "text"
        },
        null
      ],
      [
        "<bold",
        {
          "sigil": "<",
          "name": "bold"
        },
        null
      ],
      [
        ">bold",
        {
          "sigil": ">",
          "name": "bold"
        },
        null
      ],
      [
        "~collect",
        {
          "sigil": "~",
          "name": "collect"
        },
        null
      ],
      [
        "~kwic:collect",
        {
          "sigil": "~",
          "prefix": "kwic",
          "name": "collect"
        },
        null
      ],
      [
        "<kwic:bar",
        {
          "sigil": "<",
          "prefix": "kwic",
          "name": "bar"
        },
        null
      ],
      [
        ">kwic:bar",
        {
          "sigil": ">",
          "prefix": "kwic",
          "name": "bar"
        },
        null
      ],
      [">!kwic:bar",
      null,
      null],
      ["<>kwic:bar",
      null,
      null]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, errmsg_pattern] = probes_and_matchers[i];
      method = function() {
        var R, key, ref, ref1, value;
        R = (ref = (ref1 = probe.match(L._event_keypattern)) != null ? ref1.groups : void 0) != null ? ref : null;
        if (R == null) {
          return null;
        }
        for (key in R) {
          value = R[key];
          if (value === void 0) {
            delete R[key];
          }
        }
        return R;
      };
      await f(T, method, probe, matcher, errmsg_pattern);
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["classify_selector"] = async function(T, done) {
    var errmsg_pattern, i, len, matcher, method, probe, probes_and_matchers;
    probes_and_matchers = [
      ["#justatag",
      ["tag",
      "justatag"],
      null],
      [
        "^bar",
        [
          "keypattern",
          {
            "sigils": "^",
            "name": "bar"
          }
        ],
        null
      ],
      ["!!!(->)",
      ["function",
      null],
      null]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, errmsg_pattern] = probes_and_matchers[i];
      method = function() {
        var R, key, ref, value;
        if (probe.startsWith('!!!')) {
          probe = (function() {});
        }
        R = L._classify_selector(probe);
        if (R[0] === 'keypattern') {
          ref = R[1];
          for (key in ref) {
            value = ref[key];
            if (value === void 0) {
              delete R[1][key];
            }
          }
        } else if (R[0] === 'function') {
          R[1] = null;
        }
        return R;
      };
      await f(T, method, probe, matcher, errmsg_pattern);
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["select 2"] = async function(T, done) {
    var errmsg_pattern, i, len, matcher, method, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        [
          {
            key: '^number',
            value: 42
          },
          '^number'
        ],
        true
      ],
      [
        [
          {
            key: '^number',
            value: 42,
            stamped: true
          },
          '^number'
        ],
        false
      ],
      [
        [
          {
            key: '^number',
            value: 42,
            stamped: true
          },
          '#stamped',
          '^number'
        ],
        true
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          '#stamped',
          '<italic'
        ],
        true
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          '#stamped',
          '>italic'
        ],
        false
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          '#stamped',
          '<>italic'
        ],
        true
      ],
      [
        [
          {
            key: '<italic'
          },
          '#stamped',
          '<italic'
        ],
        true
      ],
      [
        [
          {
            key: '<italic'
          },
          '#stamped',
          '>italic'
        ],
        false
      ],
      [
        [
          {
            key: '<italic'
          },
          '#stamped',
          '<>italic'
        ],
        true
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          '<italic'
        ],
        false
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          '>italic'
        ],
        false
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          '<>italic'
        ],
        false
      ]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, errmsg_pattern] = probes_and_matchers[i];
      method = function() {
        var d, selectors;
        [d, ...selectors] = probe;
        return PD.select(d, ...selectors);
      };
      await f(T, method, probe, matcher, errmsg_pattern);
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["select 2 using lists"] = async function(T, done) {
    var errmsg_pattern, i, len, matcher, method, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        [
          {
            key: '^number',
            value: 42
          },
          ['^number']
        ],
        true
      ],
      [
        [
          {
            key: '^number',
            value: 42,
            stamped: true
          },
          ['^number']
        ],
        false
      ],
      [
        [
          {
            key: '^number',
            value: 42,
            stamped: true
          },
          ['#stamped',
          '^number']
        ],
        true
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          ['#stamped',
          '<italic']
        ],
        true
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          ['#stamped',
          '>italic']
        ],
        false
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          ['#stamped',
          '<>italic']
        ],
        true
      ],
      [
        [
          {
            key: '<italic'
          },
          ['#stamped',
          '<italic']
        ],
        true
      ],
      [
        [
          {
            key: '<italic'
          },
          ['#stamped',
          '>italic']
        ],
        false
      ],
      [
        [
          {
            key: '<italic'
          },
          ['#stamped',
          '<>italic']
        ],
        true
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          ['<italic']
        ],
        false
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          ['>italic']
        ],
        false
      ],
      [
        [
          {
            key: '<italic',
            stamped: true
          },
          ['<>italic']
        ],
        false
      ]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, errmsg_pattern] = probes_and_matchers[i];
      method = function() {
        var d, selectors;
        [d, ...selectors] = probe;
        return PD.select(d, ...selectors);
      };
      await f(T, method, probe, matcher, errmsg_pattern);
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["select 3"] = async function(T, done) {
    var errmsg_pattern, i, len, matcher, method, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        [
          {
            key: '^number',
            value: 42
          },
          '^number',
          "( d ) => d.value > 42"
        ],
        false
      ],
      [
        [
          {
            key: '^number',
            value: 44
          },
          '^number',
          "( d ) => d.value > 42"
        ],
        true
      ]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, errmsg_pattern] = probes_and_matchers[i];
      method = function() {
        var d, selectors;
        [d, ...selectors] = probe;
        selectors[selectors.length - 1] = eval(selectors[selectors.length - 1]);
        return PD.select(d, ...selectors);
      };
      await f(T, method, probe, matcher, errmsg_pattern);
    }
    done();
    return null;
  };

  // first-only
  // last-only
  // before-start
  // after-stop

  //###########################################################################################################
  if (module.parent == null) {
    // include = [
    //   "async 1"
    //   "async 1 paramap"
    //   "async 2"
    //   ]
    // @_prune()
    test(this);
  }

}).call(this);

//# sourceMappingURL=select.test.js.map
