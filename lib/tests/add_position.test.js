// Generated by CoffeeScript 2.5.1
(function() {
  'use strict';
  var CND, L, PD, badge, debug, echo, help, info, jr, rpr, test, urge, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS/TESTS/ADD_POSITION';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  test = require('guy-test');

  jr = JSON.stringify;

  //...........................................................................................................
  L = require('../select');

  PD = require('../..');

  // { $, $async, }            = PD

  //-----------------------------------------------------------------------------------------------------------
  this["$add_position() with values"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers, run;
    probes_and_matchers = [
      [
        0,
        [
          {
            "$first": true,
            "value": 1,
            "key": "^value",
            "$dirty": true
          },
          {
            "$last": true,
            "value": 0,
            "key": "^value",
            "$dirty": true
          }
        ],
        null
      ],
      [
        1,
        [
          {
            "$dirty": true,
            "key": "^value",
            "value": 1,
            "$first": true,
            "$last": true
          }
        ],
        null
      ],
      [
        2,
        [
          {
            "$first": true,
            "value": 1,
            "key": "^value",
            "$dirty": true
          },
          {
            "$last": true,
            "value": 2,
            "key": "^value",
            "$dirty": true
          }
        ],
        null
      ],
      [
        3,
        [
          {
            "$first": true,
            "value": 1,
            "key": "^value",
            "$dirty": true
          },
          {
            "value": 2,
            "key": "^value"
          },
          {
            "$last": true,
            "value": 3,
            "key": "^value",
            "$dirty": true
          }
        ],
        null
      ]
    ];
    //.........................................................................................................
    run = function(n) {
      return new Promise((resolve, reject) => {
        var i, idx, pipeline, ref, source;
        source = PD.new_push_source();
        pipeline = [];
        pipeline.push(source);
        pipeline.push(PD.$add_position());
        // pipeline.push PD.$show()
        pipeline.push(PD.$collect());
        pipeline.push(PD.$watch(function(collector) {
          return resolve(collector);
        }));
        pipeline.push(PD.$drain());
        PD.pull(...pipeline);
        for (idx = i = 1, ref = n; (1 <= ref ? i <= ref : i >= ref); idx = 1 <= ref ? ++i : --i) {
          source.send(idx);
        }
        source.end();
        return null;
      });
    };
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        return new Promise(async function(resolve, reject) {
          var result;
          result = (await run(probe));
          resolve(result);
          return null;
        });
      });
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["$add_position() with datoms"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers, run;
    probes_and_matchers = [
      [
        0,
        [
          {
            "$first": true,
            "key": "^foo",
            "idx": 1,
            "$dirty": true
          },
          {
            "$last": true,
            "key": "^foo",
            "idx": 0,
            "$dirty": true
          }
        ],
        null
      ],
      [
        1,
        [
          {
            "$dirty": true,
            "idx": 1,
            "key": "^foo",
            "$first": true,
            "$last": true
          }
        ],
        null
      ],
      [
        2,
        [
          {
            "$first": true,
            "key": "^foo",
            "idx": 1,
            "$dirty": true
          },
          {
            "$last": true,
            "key": "^foo",
            "idx": 2,
            "$dirty": true
          }
        ],
        null
      ],
      [
        3,
        [
          {
            "$first": true,
            "key": "^foo",
            "idx": 1,
            "$dirty": true
          },
          {
            "key": "^foo",
            "idx": 2
          },
          {
            "$last": true,
            "key": "^foo",
            "idx": 3,
            "$dirty": true
          }
        ],
        null
      ]
    ];
    //.........................................................................................................
    run = function(n) {
      return new Promise((resolve, reject) => {
        var i, idx, pipeline, ref, source;
        source = PD.new_push_source();
        pipeline = [];
        pipeline.push(source);
        pipeline.push(PD.$add_position());
        // pipeline.push PD.$show()
        pipeline.push(PD.$collect());
        pipeline.push(PD.$watch(function(collector) {
          return resolve(collector);
        }));
        pipeline.push(PD.$drain());
        PD.pull(...pipeline);
        for (idx = i = 1, ref = n; (1 <= ref ? i <= ref : i >= ref); idx = 1 <= ref ? ++i : --i) {
          source.send(PD.new_datom('^foo', {idx}));
        }
        source.end();
        return null;
      });
    };
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        return new Promise(async function(resolve, reject) {
          var result;
          result = (await run(probe));
          resolve(result);
          return null;
        });
      });
    }
    done();
    return null;
  };

  //###########################################################################################################
  if (module.parent == null) {
    test(this);
    test(this["$add_position() with values"]);
  }

  // test @[ "$add_position() with datoms" ]

}).call(this);

//# sourceMappingURL=add_position.test.js.map
