// Generated by CoffeeScript 1.10.0
(function() {
  var CND, alert, badge, debug, help, rpr, urge, warn;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS/TRANSFORM-SPLIT-TSV';

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  this.$split_tsv = function(settings) {

    /*
    
    A stream transform to help in reading files with data in
    [Tab-Separated Values (TSV)](http://www.iana.org/assignments/media-types/text/tab-separated-values)
    format. It accepts a stream of buffers or text, splits it into
    lines, and splits each line into fields (using the tab character, U+0009). In the process
    it can also skip empty and blank lines, omit comments, and name fields.
    
    + `comments` defines how to recognize a comment. If it is a string, lines and individual fields that start
      with the specified text are left out of the results. It is also possible to use a RegEx or a custom
      function to recognize comments.
    
    + When `empty` is set to `false`, empty lines (and lines that contain nothing but empty fields) are
      left in the stream.
    
    * If `settings[ 'names' ]` is set to `'inline'`, field names are gleaned from the first non-discarded line
      of input; if it is a list of `n` elements, it defines labels for the first `n` columns of data. Columns
      with no defined name will be labelled as `'field-0'`, `'field-5'` and so on, depending on the zero-based
      index of the respective column. Where naming of fields is used, each TSV data line will be turned into a
      JS object with the appropriately named members, such as `{ name: 'John', age: 32, 'field-2': 'lawyer', }`;
      where no naming is used, lists of values are sent into the stream, such as `[ 'John', 32, 'lawyer', ]`.
    
    Observe that `$split_tsv` has been (experimentally) factored out into a plugin of sorts; to use it, be sure
    to `require 'pipedreams/lib/plugin-split-tsv'` after your `D = require 'pipedreams'` statement. This import
    has no interesting return value, but will provide `D.$split_tsv` for you to use.
     */

    /* TAINT temporary clause */
    var $name_fields, $skip_empty_fields, $skip_empty_lines, $skip_field_comments, $skip_line_comments, $split_line, $trim, comment_pattern, comments, is_comment, name_fields, names, pipeline, ref, ref1, ref2, skip_comments, skip_empty_lines, splitter, type, use_names;
    if (settings != null) {
      if (settings['first'] != null) {
        throw new Error("setting 'first' deprecated");
      }
      if (settings['trim'] != null) {
        throw new Error("setting 'trim' deprecated");
      }
      if (settings['splitter'] != null) {
        throw new Error("setting 'splitter' not yet supported");
      }
    }
    splitter = '\t';
    skip_empty_lines = !((ref = settings != null ? settings['empty'] : void 0) != null ? ref : false);
    use_names = (ref1 = settings != null ? settings['names'] : void 0) != null ? ref1 : null;
    comment_pattern = (ref2 = settings != null ? settings['comments'] : void 0) != null ? ref2 : '#';
    skip_comments = !(comment_pattern === false);
    if (comment_pattern === false) {
      comment_pattern = null;
    }
    $trim = (function(_this) {
      return function() {
        return _this.$(function(line, send) {
          return send(_this.$split_tsv._trim(line));
        });
      };
    })(this);

    /* TAINT may want to specify empty lines, fields */
    if (skip_empty_lines !== true && skip_empty_lines !== false) {
      throw new Error("### MEH 1 ###");
    }
    switch (type = CND.type_of(comment_pattern)) {
      case 'null':
      case 'undefined':
        comments = false;
        is_comment = function(text) {
          return false;
        };
        break;
      case 'text':
        comments = true;
        is_comment = function(text) {
          return text.startsWith(comment_pattern);
        };
        break;
      case 'regex':
        comments = true;
        is_comment = function(text) {
          return comment_pattern.test(text);
        };
        break;
      case 'function':
        comments = true;
        is_comment = function(text) {
          return !!comment_pattern(text);
        };
        break;
      default:
        throw new Error("expected `null`, a text, a RegEx or a function for 'comment', got a " + type);
    }
    if (skip_comments) {
      $skip_line_comments = (function(_this) {
        return function() {
          return _this.$(function(line, send) {
            if (!is_comment(line)) {
              return send(line);
            }
          });
        };
      })(this);
      $skip_field_comments = (function(_this) {
        return function() {
          return _this.$(function(fields, send) {
            var field, i, idx, len;
            for (idx = i = 0, len = fields.length; i < len; idx = ++i) {
              field = fields[idx];
              if (!is_comment(field)) {
                continue;
              }
              fields.length = idx;
              break;
            }
            if (!(skip_empty_lines && fields.length === 0)) {
              return send(fields);
            }
          });
        };
      })(this);
    }
    if (skip_empty_lines) {
      $skip_empty_lines = (function(_this) {
        return function() {
          return _this.$(function(line, send) {
            if (line.length > 0) {
              return send(line);
            }
          });
        };
      })(this);
      $skip_empty_lines = this._rpr('skip-empty-lines', 'skip-empty-lines', null, $skip_empty_lines);
      $skip_empty_fields = (function(_this) {
        return function() {
          return _this.$(function(fields, send) {
            var field, i, len;
            for (i = 0, len = fields.length; i < len; i++) {
              field = fields[i];
              if (field.length === 0) {
                continue;
              }
              send(fields);
              break;
            }
            return null;
          });
        };
      })(this);
      $skip_empty_fields = this._rpr('skip-empty-fields', 'skip-empty-fields', null, $skip_empty_fields);
    }
    if (use_names === false) {
      use_names = null;
    }
    if (use_names != null) {
      names = null;
      if (CND.isa_list(use_names)) {
        names = use_names;
        $name_fields = (function(_this) {
          return function() {
            return _this.$(function(fields, send) {
              return send(name_fields(fields));
            });
          };
        })(this);
      } else if (use_names === 'inline' || use_names === true) {
        $name_fields = (function(_this) {
          return function() {
            var is_first;
            is_first = true;
            return _this.$(function(fields, send) {
              if (!is_first) {
                return send(name_fields(fields));
              }
              is_first = false;
              return names = fields;
            });
          };
        })(this);
      } else {
        throw new Error("expected setting names to be true, false, 'inline', or a list; got " + (rpr(use_names)));
      }
      use_names = true;
      name_fields = (function(_this) {
        return function(fields) {
          var R, field, i, idx, len, ref3;
          R = {};
          for (idx = i = 0, len = fields.length; i < len; idx = ++i) {
            field = fields[idx];
            R[(ref3 = names[idx]) != null ? ref3 : "field-" + idx] = field;
          }
          return R;
        };
      })(this);
    }
    $split_line = (function(_this) {
      return function() {
        return _this.$(function(line, send) {
          return send(line.split(splitter));
        });
      };
    })(this);
    pipeline = [];
    pipeline.push(this.$split());
    pipeline.push($trim());
    if (skip_empty_lines) {
      pipeline.push($skip_empty_lines());
    }
    if (skip_comments) {
      pipeline.push($skip_line_comments());
    }
    pipeline.push($split_line());
    if (skip_comments) {
      pipeline.push($skip_field_comments());
    }
    if (skip_empty_lines) {
      pipeline.push($skip_empty_fields());
    }
    if (use_names) {
      pipeline.push($name_fields());
    }
    return this._rpr("split-tsv", "split-tsv", null, this.new_stream({
      pipeline: pipeline
    }));
  };

  this.$split_tsv._trim = (function(_this) {
    return function(line) {
      var R;
      R = line;
      R = R.replace(_this.$split_tsv._ends_pattern, '');
      R = R.replace(_this.$split_tsv._mid_pattern, '\t');
      return R;
    };
  })(this);

  this.$split_tsv._ends_pattern = /(?:^[\x20\f\n\r\v​\u00a0\u1680​\u180e\u2000-\u200a​\u2028\u2029\u202f\u205f​\u3000\ufeff]+)|(?:[\x20\f\n\r\v​\u00a0\u1680​\u180e\u2000-\u200a​\u2028\u2029\u202f\u205f​\u3000\ufeff]+$)/g;

  this.$split_tsv._mid_pattern = /[\x20\f\n\r\v​\u00a0\u1680​\u180e\u2000-\u200a​\u2028\u2029\u202f\u205f​\u3000\ufeff]*\t[\x20\f\n\r\v​\u00a0\u1680​\u180e\u2000-\u200a​\u2028\u2029\u202f\u205f​\u3000\ufeff]*/g;

  (function(self) {
    var D, name, results, value;
    D = require('./main');
    results = [];
    for (name in self) {
      value = self[name];
      results.push(D[name] = value);
    }
    return results;
  })(this);

}).call(this);

//# sourceMappingURL=plugin-split-tsv.js.map
