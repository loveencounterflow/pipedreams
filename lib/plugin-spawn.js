// Generated by CoffeeScript 1.11.1
(function() {
  var CND, CP, alert, badge, debug, help, rpr, urge, warn;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS/PLUGIN-SPAWN';

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  CP = require('child_process');

  this._new_stream_from_pattern_and_path = function(pattern_and_path, hints, settings) {
    var R, codes, command, cp, cp_settings, cwd, error_lines, errors, finish, has_ended, ignore_case, keys, parameters, path, pattern, pattern_txt, stderr_finished, stdout_finished, type;
    if ((type = CND.type_of(pattern_and_path)) !== 'pod') {
      throw new Error("expected a POD, got a " + type);
    }
    if (!CND.is_subset((keys = Object.keys(pattern_and_path)), ['pattern', 'path'])) {
      throw new Error("expected a POD, with keys 'pattern' and 'path', got one with " + keys);
    }
    if (hints != null) {
      throw new Error("hints not implemented, got " + (rpr(hints)));
    }
    if (settings != null) {
      throw new Error("settings not implemented, got " + (rpr(settings)));
    }
    R = this.new_stream();
    cwd = process.cwd();
    pattern = pattern_and_path.pattern, path = pattern_and_path.path;
    pattern_txt = pattern['source'];
    ignore_case = pattern['ignoreCase'];
    debug('77698', pattern_and_path);
    debug('77698', ignore_case);
    cp_settings = {
      cwd: cwd
    };
    command = 'grep';
    parameters = [];
    parameters.push('--extended-regexp');
    parameters.push('-e');
    parameters.push(pattern_txt);
    if (ignore_case) {
      parameters.push('--ignore-case');
    }
    parameters.push(path);
    debug('12034', command + " " + (parameters.join(' ')));
    cp = CP.spawn(command, parameters, cp_settings);
    stdout_finished = false;
    stderr_finished = false;
    has_ended = false;
    error_lines = [];
    errors = [];
    codes = [];
    finish = (function(_this) {
      return function() {

        /* "Normally the exit status is 0 if a line is selected, 1 if no lines were selected, and 2 if an error
        occurred."
         */
        var ref;
        if (has_ended) {
          return;
        }
        if (errors.length === 0 && error_lines.length === 0) {
          if (!(stdout_finished && stderr_finished && ((ref = codes[0]) === 0 || ref === 1))) {
            return;
          }
          _this.end(R);
          has_ended = true;
          return;
        }
        if (errors.length > 0) {
          has_ended = true;
          return R.emit('error', errors[0]);
        } else if (error_lines.length > 0) {
          has_ended = true;
          return R.emit('error', new Error(error_lines.join('\n')));
        } else if (codes[0] === 2) {
          has_ended = true;
          return R.emit('error', new Error("grep exited with error code " + codes[0]));
        }
      };
    })(this);
    cp.stdout.pipe(this.$split()).pipe(this.$((function(_this) {
      return function(line) {
        return _this.send(R, line);
      };
    })(this))).pipe(this.$('finish', (function(_this) {
      return function() {
        stdout_finished = true;
        return finish();
      };
    })(this)));
    cp.stderr.pipe(this.$split()).pipe(this.$((function(_this) {
      return function(line) {
        return error_lines.push(line);
      };
    })(this))).pipe(this.$('finish', (function(_this) {
      return function() {
        stderr_finished = true;
        return finish();
      };
    })(this)));
    cp.on('error', (function(_this) {
      return function(error) {
        errors.push(error);
        return finish();
      };
    })(this));
    cp.on('close', (function(_this) {
      return function(code) {
        codes.push(code);
        return finish();
      };
    })(this));
    return R;
  };

  (function(self) {
    var D, name, results, value;
    D = require('./main');
    results = [];
    for (name in self) {
      value = self[name];
      results.push(D[name] = value);
    }
    return results;
  })(this);

}).call(this);

//# sourceMappingURL=plugin-spawn.js.map
