// Generated by CoffeeScript 1.10.0
(function() {
  var CND, alert, badge, debug, help, rpr, urge, warn;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS/TRANSFORM-SPLIT-TSV';

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);


  /* TAINT make `first: split` the default (always trim all fields) */


  /* TAINT remove or rename `first` option; too obscure, too complex */


  /* TAINT sanitize whitespace right after line read w/ RegEx, no need to iterate over fields */

  this.$split_tsv = function(settings) {

    /* A fairly complex stream transform to help in reading files with data in
    [Tab-Separated Values (TSV)](http://www.iana.org/assignments/media-types/text/tab-separated-values)
    format.
    
    * `comments` defines how to recognize a comment. If it is a string, lines (or fields, when `first:
      'split'` has been specified) that start with the specified text are left out of the results.
      It is also possible to use a RegEx or a custom function to recognize comments.
    
    * `trim`: `false` for no trimming, `true` for trimming both ends of each line (with `first: 'trim'`)
      or each field (with `first: 'split'`).
    
    * `first`: either `'trim'` or `'split'`. No effect with `trim: false`; otherwise, indicates whether
      first the line is trimmed (which means that leading and trailing tabs are also removed), or whether
      we should first split into lines, and then trim each field individually. The `first: 'trim'` method—the
      default—is faster, but it may conflate empty fields if there are any. The `first: 'split'` method
      will first split each line using the `splitter` setting, and then trim all the fields individually.
      This has the side-effect that comments (as field values on their own, not when tacked unto a non-comment
      value) are reliably recognized and sorted out (when `comments` is set to a sensible value).
    
    * `splitter` defines one or more characters to split each line into fields.
    
    * When `empty` is set to `false`, empty lines (and lines that contain nothing but empty fields) are
      left in the stream.
     */
    var $name_fields, $skip_comments, $skip_empty_fields, $skip_empty_lines, $split_line, $trim, comment_pattern, comments, first, is_comment, name_fields, names, pipeline, ref, ref1, ref2, ref3, ref4, ref5, ref6, skip_empty, splitter, trim, type, type_of_splitter, use_names;
    if (settings['first'] != null) {
      throw new Error("setting 'trim' deprecated");
    }
    first = (ref = settings != null ? settings['first'] : void 0) != null ? ref : 'trim';
    trim = (ref1 = settings != null ? settings['trim'] : void 0) != null ? ref1 : true;
    splitter = (ref2 = settings != null ? settings['splitter'] : void 0) != null ? ref2 : '\t';
    skip_empty = !((ref3 = settings != null ? settings['empty'] : void 0) != null ? ref3 : false);
    comment_pattern = (ref4 = settings != null ? settings['comments'] : void 0) != null ? ref4 : '#';
    use_names = (ref5 = settings != null ? settings['names'] : void 0) != null ? ref5 : null;
    if (first !== 'trim' && first !== 'split') {
      throw new Error("### MEH ###");
    }

    /* TAINT may want to allow custom function to do trimming */
    switch (trim) {
      case true:
        if (first === 'trim') {
          $trim = (function(_this) {
            return function() {
              return _this.$(function(line, send) {
                return send(line.trim());
              });
            };
          })(this);
        } else {
          $trim = (function(_this) {
            return function() {
              return _this.$(function(fields, send) {
                var field, i, idx, len;
                for (idx = i = 0, len = fields.length; i < len; idx = ++i) {
                  field = fields[idx];
                  fields[idx] = field.trim();
                }
                return send(fields);
              });
            };
          })(this);
        }
        break;
      case false:
        null;
        break;
      default:
        throw new Error("### MEH ###");
    }

    /* TAINT may want to specify empty lines, fields */
    if (skip_empty !== true && skip_empty !== false) {
      throw new Error("### MEH ###");
    }
    switch (type = CND.type_of(comment_pattern)) {
      case 'null':
      case 'undefined':
        comments = false;
        is_comment = function(text) {
          return false;
        };
        break;
      case 'text':
        comments = true;
        is_comment = function(text) {
          return text.startsWith(comment_pattern);
        };
        break;
      case 'regex':
        comments = true;
        is_comment = function(text) {
          return comment_pattern.test(text);
        };
        break;
      case 'function':
        comments = true;
        is_comment = function(text) {
          return !!comment_pattern(text);
        };
        break;
      default:
        throw new Error("### MEH ###");
    }
    if (first === 'trim') {
      $skip_comments = (function(_this) {
        return function() {
          return _this.$(function(line, send) {
            if (!is_comment(line)) {
              return send(line);
            }
          });
        };
      })(this);
    } else {
      $skip_comments = (function(_this) {
        return function() {
          return _this.$(function(fields, send) {
            var field, i, idx, len;
            for (idx = i = 0, len = fields.length; i < len; idx = ++i) {
              field = fields[idx];
              if (!is_comment(field)) {
                continue;
              }
              fields.length = idx;
              break;
            }
            if (!(skip_empty && fields.length === 0)) {
              return send(fields);
            }
          });
        };
      })(this);
    }
    if (skip_empty) {
      $skip_empty_lines = (function(_this) {
        return function() {
          return _this.$(function(line, send) {
            if (line.length > 0) {
              return send(line);
            }
          });
        };
      })(this);
      $skip_empty_lines = this._rpr('skip-empty-lines', 'skip-empty-lines', null, $skip_empty_lines);
      if (first === 'split') {
        $skip_empty_fields = (function(_this) {
          return function() {
            return _this.$(function(fields, send) {
              var field, i, len;
              for (i = 0, len = fields.length; i < len; i++) {
                field = fields[i];
                if (field.length === 0) {
                  continue;
                }
                send(fields);
                break;
              }
              return null;
            });
          };
        })(this);
        $skip_empty_fields = this._rpr('skip-empty-fields', 'skip-empty-fields', null, $skip_empty_fields);
      }
    }
    if (use_names === false) {
      use_names = null;
    }
    if (use_names != null) {
      names = null;
      if (CND.isa_list(use_names)) {
        names = use_names;
        $name_fields = (function(_this) {
          return function() {
            return _this.$(function(fields, send) {
              return send(name_fields(fields));
            });
          };
        })(this);
      } else if (use_names === 'inline' || use_names === true) {
        $name_fields = (function(_this) {
          return function() {
            var is_first;
            is_first = true;
            return _this.$(function(fields, send) {
              if (!is_first) {
                return send(name_fields(fields));
              }
              is_first = false;
              return names = fields;
            });
          };
        })(this);
      } else {
        throw new Error("expected setting names to be true, false, 'inline', or a list; got " + (rpr(use_names)));
      }
      use_names = true;
      name_fields = (function(_this) {
        return function(fields) {
          var R, field, i, idx, len, ref6;
          R = {};
          for (idx = i = 0, len = fields.length; i < len; idx = ++i) {
            field = fields[idx];
            R[(ref6 = names[idx]) != null ? ref6 : "field-" + idx] = field;
          }
          return R;
        };
      })(this);
    }
    if ((ref6 = (type_of_splitter = CND.type_of(splitter))) !== 'text' && ref6 !== 'regex' && ref6 !== 'function') {
      throw new Error("### MEH ###");
    }
    if (type_of_splitter === 'function') {
      throw new Error("splitter as function no yet implemented");
    }
    $split_line = (function(_this) {
      return function() {
        return _this.$(function(line, send) {
          return send(line.split(splitter));
        });
      };
    })(this);
    pipeline = [];
    pipeline.push(this.$split());
    if (first === 'trim') {
      pipeline.push($trim());
    }
    if (skip_empty) {
      pipeline.push($skip_empty_lines());
    }
    if (first === 'trim' && comments) {
      pipeline.push($skip_comments());
    }
    pipeline.push($split_line());
    if (first === 'split') {
      pipeline.push($trim());
    }
    if (first === 'split' && comments) {
      pipeline.push($skip_comments());
    }
    if (first === 'split' && skip_empty) {
      pipeline.push($skip_empty_fields());
    }
    if (use_names) {
      pipeline.push($name_fields());
    }
    return this._rpr("split-tsv", "split-tsv", null, this.new_stream({
      pipeline: pipeline
    }));
  };

  module.exports = this.$split_tsv.bind(require('./main'));

}).call(this);

//# sourceMappingURL=transform-split-tsv.js.map
