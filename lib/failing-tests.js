// Generated by CoffeeScript 1.10.0

/* This module contains tests that are of dubious value, outdated, or fail
for unknown reasons; they are kept here to keep the code around and maybe
reuse them at a later point in time.
 */

(function() {
  var $, $async, CND, D, alert, badge, debug, echo, help, info, log, rpr, test, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'PIPEDREAMS/tests';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  D = require('./main');

  $ = D.$, $async = D.$async;

  this["(v4) new_stream_from_pipeline (2)"] = function(T, done) {
    var create_frob_tee;
    create_frob_tee = null;
    (function() {
      return create_frob_tee = function(settings) {
        var R, add, multiply, square, unsquared;
        multiply = $((function(_this) {
          return function(data, send) {
            return send(data * 2);
          };
        })(this));
        add = $((function(_this) {
          return function(data, send) {
            return send(data + 2);
          };
        })(this));
        square = $((function(_this) {
          return function(data, send) {
            return send(Math.pow(data, 2));
          };
        })(this));
        unsquared = D.new_stream();
        R = D.new_stream_from_pipeline([multiply, add, unsquared, square]);
        R['inputs'] = {
          add: add
        };
        R['outputs'] = {
          unsquared: unsquared
        };
        return R;
      };
    })();
    (function() {
      var frob, i, input, inputs, len, n, output, output_matchers, output_results, outputs, probes, unsquared_matchers, unsquared_results;
      probes = [1, 2, 3, 4, 5, 6, 7, 8, 9];
      output_matchers = [16, 36, 64, 64, 100, 144, 196, 256, 324, 400];
      output_results = [];
      unsquared_matchers = [4, 6, 8, -8, 10, 12, 14, 16, 18, 20];
      unsquared_results = [];
      frob = create_frob_tee();
      input = frob.input, output = frob.output, inputs = frob.inputs, outputs = frob.outputs;
      outputs['unsquared'].pipe($((function(_this) {
        return function(data, send) {
          return unsquared_results.push(data);
        };
      })(this)));
      output.pipe($((function(_this) {
        return function(data, send) {
          if (data === 100) {
            inputs['add'].write(-10);
          }
          return send(data);
        };
      })(this))).pipe($((function(_this) {
        return function(data, send) {
          output_results.push(data);
          return send(data);
        };
      })(this)));
      output.on('end', (function(_this) {
        return function() {
          debug('4435', JSON.stringify(unsquared_results));
          debug('4435', JSON.stringify(unsquared_matchers));
          debug('4435', JSON.stringify(output_results));
          debug('4435', JSON.stringify(output_matchers));
          T.eq(unsquared_results, unsquared_matchers);
          T.eq(output_results, output_matchers);
          return done();
        };
      })(this));
      for (i = 0, len = probes.length; i < len; i++) {
        n = probes[i];
        input.write(n);
      }
      return input.end();
    })();
    return null;
  };

  this["(v4) failing asynchronous demo with event-stream, PipeDreams v2"] = function(T, T_done) {
    var $client_method_called_here, $collect_results, S, db, delay, glyph, i, len, read_one_phrase, ref;
    db = [['千', 'strokeorder', '312'], ['仟', 'strokeorder', '32312'], ['韆', 'strokeorder', '122125112125221134515454']];
    delay = (function(_this) {
      return function(glyph, f) {
        var dt;
        dt = CND.random_integer(1, 1500);
        whisper("delay for " + glyph + ": " + dt + "ms");
        return setTimeout(f, dt);
      };
    })(this);
    read_one_phrase = (function(_this) {
      return function(glyph, handler) {
        return delay(glyph, function() {
          var i, len, obj, phrase, prd, sbj;
          for (i = 0, len = db.length; i < len; i++) {
            phrase = db[i];
            sbj = phrase[0], prd = phrase[1], obj = phrase[2];
            if (sbj !== glyph) {
              continue;
            }
            return handler(null, phrase);
          }
          return handler(null, null);
        });
      };
    })(this);
    $client_method_called_here = (function(_this) {
      return function(S) {
        return D._ES.map(function(glyph, handler) {
          S.count += +1;
          urge('7765-1 $client_method_called_here:', glyph);
          return read_one_phrase(glyph, function(error, phrase) {
            if (error != null) {
              return handler(error);
            }
            S.count += -1;
            urge('7765-2 $client_method_called_here:', phrase);
            if (phrase != null) {
              handler(null, phrase);
            }
            return handler();
          });
        });
      };
    })(this);
    $collect_results = (function(_this) {
      return function(S) {
        var collector;
        collector = [];
        return $(function(data, send, end) {
          if (data != null) {
            collector.push(data);
            help('7765-3 $collect_results data:     ', data);
          }
          if (end != null) {
            info(collector);
            return end();
          }
        });
      };
    })(this);
    S = {};
    S.count = 0;
    S.end_stream = null;
    S.input = D.new_stream();
    S.input.pipe($client_method_called_here(S)).pipe($collect_results(S)).pipe(D.$on_end((function(_this) {
      return function() {
        return T_done();
      };
    })(this)));
    ref = Array.from('千仟韆');
    for (i = 0, len = ref.length; i < len; i++) {
      glyph = ref[i];
      S.input.write(glyph);
    }
    S.input.end();
    return null;
  };

  this["(v4) asynchronous DB-like"] = function(T, T_done) {
    var db, delay, glyph, i, input, len, read_facets, ref;
    db = [['千', 'variant', '仟'], ['千', 'variant', '韆'], ['千', 'similarity', '于'], ['千', 'similarity', '干'], ['千', 'usagecode', 'CJKTHM'], ['千', 'strokeorder', '312'], ['千', 'reading', 'qian'], ['千', 'reading', 'foo'], ['千', 'reading', 'bar'], ['仟', 'strokeorder', '32312'], ['仟', 'usagecode', 'CJKTHm'], ['仟', 'reading', 'qian'], ['韆', 'strokeorder', '122125112125221134515454'], ['韆', 'usagecode', 'KTHm'], ['韆', 'reading', 'qian']];
    delay = (function(_this) {
      return function(f) {
        return setTimeout(f, CND.random_integer(100, 800));
      };
    })(this);
    read_facets = (function(_this) {
      return function(glyph, handler) {
        return delay(function() {
          var i, len, obj, prd, record, ref, sbj;
          ref = CND.shuffle(db);
          for (i = 0, len = ref.length; i < len; i++) {
            record = ref[i];
            sbj = record[0], prd = record[1], obj = record[2];
            if (sbj !== glyph) {
              continue;
            }
            urge('1');
            handler(null, {
              value: record,
              done: false
            });
          }
          urge('2');
          return handler(null, {
            value: null,
            done: true
          });
        });
      };
    })(this);
    input = D.new_stream();
    input.pipe(D.$show("before:")).pipe($async((function(_this) {
      return function(glyph, send) {
        return read_facets(glyph, function(error, event) {
          var done, value;
          if (error != null) {
            throw error;
          }
          urge('7765', event);
          value = event.value, done = event.done;
          if (value != null) {
            send(value);
          }
          debug('4431', value);
          if (done) {
            return send.done();
          }
        });
      };
    })(this))).pipe(D.$show("after: ")).pipe((function(_this) {
      return function() {
        var collector;
        collector = [];
        return $(function(data, send, end) {
          if (data != null) {
            collector.push(data);
          }
          debug('4432', collector);
          if (end != null) {
            return delay(function() {
              end();
              return T_done();
            });
          }
        });
      };
    })(this)());
    ref = Array.from('千仟韆國');
    for (i = 0, len = ref.length; i < len; i++) {
      glyph = ref[i];
      input.write(glyph);
    }
    input.end();
    return null;
  };

  this["(v4) asynchronous (using ES.map)"] = function(T, T_done) {
    var $client_method_called_here, $collect_results, $detect_stream_end, $foo, S, db, delay, glyph, i, len, read_one_phrase, ref;
    db = [['千', 'strokeorder', '312'], ['仟', 'strokeorder', '32312'], ['韆', 'strokeorder', '122125112125221134515454']];
    delay = (function(_this) {
      return function(glyph, f) {
        var dt;
        dt = CND.random_integer(1, 1500);
        whisper("delay for " + glyph + ": " + dt + "ms");
        return setTimeout(f, dt);
      };
    })(this);
    read_one_phrase = (function(_this) {
      return function(glyph, handler) {
        return delay(glyph, function() {
          var i, len, obj, phrase, prd, sbj;
          for (i = 0, len = db.length; i < len; i++) {
            phrase = db[i];
            sbj = phrase[0], prd = phrase[1], obj = phrase[2];
            if (sbj !== glyph) {
              continue;
            }
            return handler(null, phrase);
          }
          return handler(null, null);
        });
      };
    })(this);
    $detect_stream_end = (function(_this) {
      return function(S) {
        return $(function(data, send, end) {
          if (data != null) {
            send(data);
          }
          if (end != null) {
            warn("$detect_stream_end detected end of stream at count " + S.count);
            return S.end_stream = end;
          }
        });
      };
    })(this);
    $client_method_called_here = (function(_this) {
      return function(S) {
        return D._ES.map(function(glyph, handler) {
          debug('7762', S.input.readable);
          S.count += +1;
          return read_one_phrase(glyph, function(error, phrase) {
            if (error != null) {
              return handler(error);
            }
            info(S.count, CND.truth(S.end_stream != null));
            S.count += -1;
            urge('7765', phrase);
            if (phrase != null) {
              handler(null, phrase);
            }
            return handler();
          });
        });
      };
    })(this);
    $foo = (function(_this) {
      return function(S) {
        if ((S.end_stream != null) && S.count <= 0) {
          S.end_stream();
          return T_done();
        }
      };
    })(this);
    $collect_results = (function(_this) {
      return function(S) {
        var collector;
        collector = [];
        return $(function(data, send) {
          info('7764', '$collect_results', CND.truth(data != null));
          if (data != null) {
            collector.push(data);
            return help('7765 $collect_results data:', data);
          }
        });
      };
    })(this);
    S = {};
    S.count = 0;
    S.end_stream = null;
    S.input = D.new_stream();
    S.input.pipe($client_method_called_here(S)).pipe($collect_results(S));
    ref = Array.from('千仟韆');
    for (i = 0, len = ref.length; i < len; i++) {
      glyph = ref[i];
      S.input.write(glyph);
    }
    S.input.end();
    return null;
  };

  this["(v4) synchronous collect"] = function(T, done) {
    var collector, f, input, output, split2, text, through2;
    text = "Just in order to stress it, a 'character’ in this chart is equivalent to 'a Unicode\ncodepoint’, so for example 馬 and 马 count as two characters, and 關, 关, 関, 闗, 𨶹 count\nas five characters. Dictionaries will list 馬马 as 'one character with two variants’\nand 關关関闗𨶹 as 'one character with five variants’, but that’s not what we’re counting\nhere.";
    f = function(text) {};
    through2 = require('through2');
    split2 = require('split2');
    input = through2();
    output = through2.obj();
    input.pipe((function(_this) {
      return function() {
        var last_is_nl;
        last_is_nl = false;
        return $(function(data, send, end) {
          if (data != null) {
            if (CND.isa_text(data)) {
              last_is_nl = data[data.length - 1] === 0x0a;
            } else {
              last_is_nl = data[data.length - 1] === '\n';
            }
            send(data);
          }
          if (end != null) {
            debug('4431', last_is_nl);
            if (!last_is_nl) {
              send('\n');
            }
            return end();
          }
        });
      };
    })(this)()).pipe(split2()).pipe($(function(data) {
      if (data != null) {
        return help(rpr(data));
      }
    })).pipe(output);
    output.pipe((function(_this) {
      return function() {
        return $(function(data, send, end) {
          if (data != null) {
            collector.push(data);
          }
          if (end != null) {
            info(collector);
            return end();
          }
        });
      };
    })(this)());
    input.on('end', function() {
      return warn('2—stream ended');
    });
    output.on('end', function() {
      return warn('3—stream ended');
    });
    collector = [];
    input.push(text + (text.endsWith('\n') ? '' : '\n'));
    input.push(null);
    debug(collector);
    return setTimeout(done, 500);
  };

  this["(v4) asynchronous collect"] = function(T, T_done) {
    var input, stream, text;
    text = "Just in order to stress it, a 'character’ in this chart is equivalent to 'a Unicode\ncodepoint’, so for example 馬 and 马 count as two characters, and 關, 关, 関, 闗, 𨶹 count\nas five characters. Dictionaries will list 馬马 as 'one character with two variants’\nand 關关関闗𨶹 as 'one character with five variants’, but that’s not what we’re counting\nhere.";
    input = D.new_stream_from_text(text);
    stream = input.pipe(D.$split()).pipe($async((function(_this) {
      return function(line, send, end) {
        debug('1121', CND.truth(line != null), CND.truth(send.end != null), CND.truth(end != null));
        if (line != null) {
          setTimeout((function() {
            return send(line);
          }), 200);
        }
        if (end != null) {
          urge('text completed');
          send.done("\ntext completed.");
          return end();
        }
      };
    })(this)));
    D.collect(stream, (function(_this) {
      return function(error, result) {
        T.eq(result, (text.split('\n')) + "\ntext completed.");
        debug('©4D8tA', 'T_done');
        return T_done();
      };
    })(this));
    return input.resume();
  };


  /*
  #-----------------------------------------------------------------------------------------------------------
  @[ "(v4) $bridge" ] = ( T, done ) ->
     * input   = D.new_file_readstream ( require 'path' ).resolve __dirname, '../package.json'
    MSP         = require 'mississippi'
    has_url     = no
    has_ended   = no
    input       = ( require 'fs' ).createReadStream ( require 'path' ).resolve __dirname, '../package.json'
     * throughput  = ( require 'fs' ).createWriteStream '/tmp/foo'
     * #.........................................................................................................
     * D.$bridge = ( stream ) ->
     *   stream.on 'close',  => urge 'close'
     *   stream.on 'finish', => urge 'finish'
     *   main  = ( data, _, callback ) ->
     *     debug '4453', data
     *     stream.write data
     *     @push data
     *     callback()
     *   flush = ( callback ) ->
     *     stream.close()
     *     callback()
     *   # return MSP.through.obj main, flush
     *   return D.new_stream()
    #.........................................................................................................
    input
      .pipe D.$split()
      .pipe D.$show()
      .pipe $ ( line ) =>
        has_url = has_url or ( /// "homepage" .* "https:\/\/github .* \/pipedreams" /// ).test line
       * .pipe D.$bridge ( require 'fs' ).createWriteStream '/tmp/foo'
       * .pipe MSP.duplex ( ( require 'fs' ).createWriteStream '/tmp/foo' ), D.new_stream()
       * .pipe D.$bridge process.stdout
      .pipe D.$on_end =>
        has_ended = yes
        if has_url then T.ok yes
        else            T.fail "expected to find a URL"
        done()
     * report_failure = =>
     *   return if has_ended
     *   T.fail ".pipe D.$on_end was not called"
     *   done()
     * setTimeout report_failure, 2000
    return null
   */

  this["(v4) new_file_readstream"] = function(T, done) {
    var has_url, input;
    input = D.new_file_readstream((require('path')).resolve(__dirname, '../package.json'));
    has_url = false;
    input.pipe(D.$split()).pipe(D.$show()).pipe($((function(_this) {
      return function(line) {
        return has_url = has_url || /"homepage".*"https:\/\/github.*\/pipedreams"/.test(line);
      };
    })(this))).pipe(D.$on_end((function(_this) {
      return function() {
        if (has_url) {
          T.ok(true);
        } else {
          T.fail("expected to find a URL");
        }
        return done();
      };
    })(this)));
    return input.resume();
  };

  this._main = function() {
    return test(this, {
      'timeout': 3000
    });
  };

  if (module.parent == null) {
    this._main();
  }

}).call(this);

//# sourceMappingURL=failing-tests.js.map
