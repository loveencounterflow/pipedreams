// Generated by CoffeeScript 1.9.0
(function() {
  var CND, DS, LODASH, alert, badge, collect_and_check, debug, echo, get_index, help, info, log, rpr, settings, test, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'PIPEDREAMS2/tests';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  LODASH = require('lodash');

  test = require('guy-test');

  DS = require('./densort');

  get_index = function(element, key) {
    if (CND.isa_function(key)) {
      return key(element);
    } else {
      return element[key];
    }
  };

  collect_and_check = function(T, key, first_idx, input, max_buffer_size) {
    var collection, ds, element_count, idx, input_element, last_idx, output, output_idxs, target, target_idxs, _i, _j, _len, _len1, _ref;
    if (max_buffer_size == null) {
      max_buffer_size = null;
    }
    output = [];
    target = LODASH.sortBy(LODASH.cloneDeep(input), key);
    element_count = input.length;
    ds = DS.new_densort(key, first_idx, function(stats) {
      if (max_buffer_size != null) {
        return T.eq(stats, [element_count, max_buffer_size]);
      }
    });
    _ref = [input, [null]];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      collection = _ref[_i];
      for (_j = 0, _len1 = collection.length; _j < _len1; _j++) {
        input_element = collection[_j];
        ds(input_element, function(error, output_element) {
          if (error != null) {
            throw error;
          }
          if (output_element != null) {
            return output.push(output_element);
          } else {
            return T.eq(output, target);
          }
        });
      }
    }
    last_idx = element_count + first_idx - 1;
    target_idxs = (function() {
      var _k, _results;
      _results = [];
      for (idx = _k = first_idx; _k <= last_idx; idx = _k += +1) {
        _results.push(idx);
      }
      return _results;
    })();
    output_idxs = (function() {
      var _k, _ref1, _results;
      _results = [];
      for (idx = _k = first_idx; _k <= last_idx; idx = _k += +1) {
        _results.push(get_index((_ref1 = output[idx]) != null ? _ref1 : [], key));
      }
      return _results;
    })();
    T.eq(output_idxs, target_idxs);
    return output;
  };

  this["densort 0"] = function(T, done) {
    var first_idx, input, key, max_buffer_size, output;
    key = 0;
    first_idx = 0;
    max_buffer_size = 0;
    input = [];
    output = collect_and_check(T, key, first_idx, input, max_buffer_size);
    return done();
  };

  this["densort 1"] = function(T, done) {
    var first_idx, input, key, max_buffer_size, output;
    key = 0;
    first_idx = 0;
    max_buffer_size = 0;
    input = [[0, 'A'], [1, 'B'], [2, 'C']];
    output = collect_and_check(T, key, first_idx, input, max_buffer_size);
    return done();
  };

  this["densort 2"] = function(T, done) {
    var first_idx, input, inputs, key, max_buffer_size, output, _i, _len, _ref;
    key = 0;
    first_idx = 0;
    inputs = [[[[0, 'A'], [1, 'B'], [2, 'C']], 0], [[[0, 'A'], [2, 'C'], [1, 'B']], 2], [[[1, 'B'], [0, 'A'], [2, 'C']], 2], [[[1, 'B'], [2, 'C'], [0, 'A']], 3], [[[2, 'C'], [0, 'A'], [1, 'B']], 2], [[[2, 'C'], [1, 'B'], [0, 'A']], 3]];
    for (_i = 0, _len = inputs.length; _i < _len; _i++) {
      _ref = inputs[_i], input = _ref[0], max_buffer_size = _ref[1];
      output = collect_and_check(T, key, first_idx, input, max_buffer_size);
    }
    return done();
  };

  this["densort 3"] = function(T, done) {
    var chr, count, error, first_idx, idx, input, input_txt, key, message, messages;
    key = 0;
    first_idx = 0;
    input = [[0, 'a'], [1, 'b'], [2, 'c'], [3, 'd'], [4, 'e'], [5, 'f'], [6, 'g']];
    count = 0;
    messages = [];
    while (true) {
      count += +1;
      if (count % 1e5 === 0) {
        whisper(count);
      }
      input_txt = ((function() {
        var _i, _len, _ref, _results;
        _results = [];
        for (_i = 0, _len = input.length; _i < _len; _i++) {
          _ref = input[_i], idx = _ref[0], chr = _ref[1];
          _results.push("" + idx);
        }
        return _results;
      })()).join('');
      try {
        collect_and_check(T, key, first_idx, input);
      } catch (_error) {
        error = _error;
        message = error['message'] + ": " + input_txt;
        messages.push(message);
        warn(input_txt);
        T.fail(message);
      }
      if (!CND.ez_permute(input)) {
        break;
      }
    }
    return done();
  };

  this["densort 4"] = function(T, done) {
    var chr, error, first_idx, input, input_txt, inputs, key, message, output, _i, _len;
    key = 0;
    first_idx = 0;
    inputs = ['012345', '102354', '1032', '10243'];
    for (_i = 0, _len = inputs.length; _i < _len; _i++) {
      input = inputs[_i];
      input_txt = input;
      input = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = input.length; _j < _len1; _j++) {
          chr = input[_j];
          _results.push([parseInt(chr, 10)]);
        }
        return _results;
      })();
      try {
        output = collect_and_check(T, key, first_idx, input);
      } catch (_error) {
        error = _error;
        message = error['message'] + ": " + input_txt;
        warn(input_txt);
        T.fail(message);
      }
    }
    return done();
  };

  this["densort 5"] = function(T, done) {
    var first_idx, input, key, max_buffer_size, output;
    key = 0;
    first_idx = 0;
    max_buffer_size = 13;
    input = [[1, 'B'], [2, 'C'], [3, 'D'], [4, 'E'], [5, 'F'], [6, 'G'], [7, 'H'], [8, 'I'], [9, 'J'], [10, 'K'], [11, 'L'], [12, 'M'], [0, 'A']];
    output = collect_and_check(T, key, first_idx, input, max_buffer_size);
    return done();
  };

  this["densort 6"] = function(T, done) {
    var first_idx, input, key, max_buffer_size, output;
    key = 0;
    first_idx = 0;
    max_buffer_size = 7;
    input = [[2, 'C'], [3, 'D'], [4, 'E'], [5, 'F'], [6, 'G'], [1, 'B'], [0, 'A'], [7, 'H'], [8, 'I'], [9, 'J'], [10, 'K'], [11, 'L'], [12, 'M']];
    output = collect_and_check(T, key, first_idx, input, max_buffer_size);
    return done();
  };

  this["densort 7"] = function(T, done) {
    var first_idx, input, key, max_buffer_size;
    key = 0;
    first_idx = 1;
    max_buffer_size = null;
    input = [[0, 'A'], [1, 'B'], [2, 'C'], [3, 'D'], [4, 'E']];
    T.throws('index too small: 0', function() {
      return collect_and_check(T, key, first_idx, input, max_buffer_size);
    });
    return done();
  };

  this["densort 7"] = function(T, done) {
    var first_idx, input, key, max_buffer_size;
    key = 0;
    first_idx = 0;
    max_buffer_size = null;
    input = [[0, 'A'], [1, 'B'], [2, 'C'], [4, 'E']];
    T.throws('detected missing elements', function() {
      return collect_and_check(T, key, first_idx, input, max_buffer_size);
    });
    return done();
  };

  settings = {
    'timeout': 2500
  };

  test(this, settings);

}).call(this);
