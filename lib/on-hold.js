// Generated by CoffeeScript 1.10.0

/*

This module contains candidate PipeDreams methods that have been put on hold
because they are of dubious value, do not fall clearly within the scope of the
PipeDreams library, or have implementation issues yet to be solved.

In order to opt-in and use these methods (as far as the're usable at all),
use `require 'pipdreams/lib/on-hold'`.
 */

(function() {
  var CND, MSP, alert, badge, debug, echo, f, help, info, log, rpr, urge, warn, whisper,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);


  /* https://github.com/maxogden/mississippi */

  MSP = require('mississippi');


  /* http://stringjs.com */


  /* https://github.com/mcollina/split2 */


  /* https://github.com/mziccard/node-timsort */

  f = function() {
    this.new_file_readstream = function() {
      var P, ref;
      P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = require('fs')).createReadStream.apply(ref, P);
    };
    this.new_file_readlinestream = function() {
      var P;
      P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.new_stream({
        pipeline: [this.new_file_readstream.apply(this, P), this.$split()]
      });
    };
    this.new_sink = function() {
      return this.new_stream({
        pipeline: [this.$bridge((require('fs')).createWriteStream('/dev/null'))]
      });
    };
    this.new_file_writestream = function() {
      throw new Error("new_file_writestream not implemented");
    };
    this.$bridge = function(stream) {

      /* Make it so that the pipeline may be continued even below a writable but not readable stream.
      Conceivably, this method could have be named `tunnel` as well. Something to get you across, you get the
      meaning.
       */
      var arity;
      if ((arity = arguments.length) !== 1) {
        throw new Error("expected a single argument, got " + arity);
      }
      if (!this.isa_stream(stream)) {
        throw new Error("expected a stream, got a " + (CND.type_of(stream)));
      }
      if (!stream.writable) {
        throw new Error("expected a writable stream");
      }
      if (stream.readable) {
        throw new Error("expected a writable, non-readable stream");
      }
      return this.$((function(_this) {
        return function(data, send, end) {
          if (data != null) {
            stream.write(data);
          }
          send(data);
          if (end != null) {
            if (stream !== process.stdout) {
              stream.end();
            }
            return end();
          }
        };
      })(this));
    };
    this.$observe = function(method) {

      /* Call `method` for each piece of data; when `method` has returned with whatever result, send data on.
       */
      var arity;
      throw new Error("`$observe ( data ) ->` replaced by `$ ( data ) ->`");
      switch (arity = method.length) {
        case 1:
          return this.$((function(_this) {
            return function(data) {
              return method(data);
            };
          })(this));
        case 2:
          return this.$((function(_this) {
            return function(data, send, end) {
              if (data != null) {
                method(data, false);
                send(data);
              }
              if (end != null) {
                method(null, true);
                return end();
              }
            };
          })(this));
      }
      throw new Error("expected method with arity 1 or 2, got one with arity " + arity);
    };
    this.spawn_and_read = function() {
      var P, readstream_from_spawn, spawn;
      P = 1 <= arguments.length ? slice.call(arguments, 0) : [];

      /* from https://github.com/alessioalex/spawn-to-readstream:
      
      Make child process spawn behave like a read stream (buffer the error, don't emit end if error emitted).
      
      ```js
      var toReadStream = require('spawn-to-readstream'),
          spawn        = require('child_process').spawn;
      
      toReadStream(spawn('ls', ['-lah'])).on('error', function(err) {
        throw err;
      }).on('end', function() {
        console.log('~~~ DONE ~~~');
      }).on('data', function(data) {
        console.log('ls data :::', data.toString());
      });
      ```
       */
      readstream_from_spawn = require('spawn-to-readstream');
      spawn = (require('child_process')).spawn;
      return readstream_from_spawn(spawn.apply(null, P));
    };
    return this.spawn_and_read_lines = function() {
      var P, R, input, last_line;
      P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      last_line = null;
      R = this.new_stream();
      input = this.spawn_and_read.apply(this, P);
      input.pipe(this.$split()).pipe(this.$((function(_this) {
        return function(line, send, end) {
          if (line != null) {
            if (last_line != null) {
              R.write(last_line);
            }
            last_line = line;
          }
          if (end != null) {
            if ((last_line != null) && last_line.length > 0) {
              R.write(last_line);
            }
            R.end();
            return end();
          }
        };
      })(this)));
      return R;
    };
  };

  f.apply(require('./main'));

}).call(this);

//# sourceMappingURL=on-hold.js.map
