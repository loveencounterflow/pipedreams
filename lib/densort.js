// Generated by CoffeeScript 1.10.0
(function() {
  var CND, alert, badge, debug, echo, help, info, log, rpr, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'PIPEDREAMS2/densort';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  this.new_densort = function(getter, first_idx, report_handler) {
    var buffer, buffer_element, buffer_size, element_count, getter_is_function, max_buffer_size, min_legal_idx, previous_idx, send_buffered_elements, sent_count, smallest_idx;
    if (getter == null) {
      getter = 1;
    }
    if (first_idx == null) {
      first_idx = 0;
    }
    if (report_handler == null) {
      report_handler = null;
    }

    /* Given up to three arguments—a `getter`, a `first_idx`, and a `report_handler`—return a function
    `densort = ( element, handler ) ->` that in turn accepts a series of indexed elements and a callback
    function which it will be called once for each element and in the order of the element indices.
    
    The `densort` function should be called one for each element; each element should be an object or
    primitive value. In case `getter` is not callable, then indices will be retrieved as `element[ getter ]`
    (`getter` defaulting to `1`, because i often send 'event' lists similar to `[ type, idx, payload... ]` down
    the stream); in case `getter` is a function, indices will be retrieved as `getter element`. When the series
    of elements has ended, `densort` should be called once more with a `null` value to signal this.
    
    The `handler` argument to `densort` should be a NodeJS-style callback function, i.e. it should accept
    two arguments, `error` and `element`; it is sort of symmetric to `densort` as it will be called once
    as `handler null, element` for each element and once as `handler null, null` to signal exhaustion of the
    series.
     */
    getter_is_function = CND.isa_function(getter);
    buffer = [];
    buffer_size = 0;
    previous_idx = first_idx - 1;
    smallest_idx = Infinity;
    min_legal_idx = 0;
    max_buffer_size = 0;
    element_count = 0;
    sent_count = 0;
    if (report_handler === true) {
      report_handler = function(arg) {
        var efficiency, event_count, max_buffer_size, percentage;
        event_count = arg[0], max_buffer_size = arg[1];
        percentage = (max_buffer_size / event_count * 100).toFixed(2);
        efficiency = (1 - max_buffer_size / event_count).toFixed(2);
        return info("\nPipeDreams DenSort:\nof " + event_count + " elements, up to " + max_buffer_size + " (" + percentage + "%) had to be buffered;\nefficiency: " + efficiency);
      };
    }
    buffer_element = (function(_this) {
      return function(idx, element, handler) {
        if (buffer[idx] != null) {
          return handler(new Error("duplicate index " + (rpr(idx))));
        }
        smallest_idx = Math.min(smallest_idx, idx);
        buffer[idx] = element;
        buffer_size += +1;
        return null;
      };
    })(this);
    send_buffered_elements = (function(_this) {
      return function(handler) {

        /* Refuse to send anything unless all elements with smaller indexes have already been sent: */
        var element, results;
        if (sent_count < (smallest_idx - first_idx)) {
          return;
        }
        results = [];
        while (true) {

          /* Terminate loop in case nothing is in the buffer or we have reached an empty position: */
          if (buffer_size < 1 || ((element = buffer[smallest_idx]) == null)) {
            min_legal_idx = Math.max(min_legal_idx, smallest_idx);
            break;
          }

          /* Remove element to be sent from buffer (making it a sparse list in most cases), adjust sentinels and
          send element:
           */
          delete buffer[smallest_idx];
          previous_idx = smallest_idx;
          max_buffer_size = Math.max(max_buffer_size, buffer_size);
          smallest_idx += +1;
          buffer_size += -1;
          sent_count += +1;
          min_legal_idx = Math.max(min_legal_idx, smallest_idx);
          results.push(handler(null, element));
        }
        return results;
      };
    })(this);
    return (function(_this) {
      return function(element, handler) {
        var idx;
        if (element != null) {
          element_count += +1;
          idx = getter_is_function ? getter(element) : element[getter];
          if (idx < first_idx) {
            return handler(new Error("index too small: " + (rpr(idx))));
          }
          if (idx < min_legal_idx) {
            return handler(new Error("duplicate index: " + (rpr(idx))));
          }
          if (buffer_size === 0 && idx === previous_idx + 1) {
            previous_idx = idx;
            min_legal_idx = idx + 1;
            sent_count += +1;
            if (buffer_size < 1) {
              smallest_idx = Infinity;
            }
            return handler(null, element);
          } else {
            buffer_element(idx, element, handler);
            return send_buffered_elements(handler);
          }
        } else {
          send_buffered_elements(handler);
          if (buffer_size > 0) {
            return handler(new Error("detected missing elements"));
          }
          if (report_handler != null) {
            report_handler([element_count, max_buffer_size]);
          }
          return handler(null, null);
        }
      };
    })(this);
  };

}).call(this);
