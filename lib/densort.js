// Generated by CoffeeScript 1.8.0
(function() {
  var TRM, TYPES, alert, badge, debug, echo, help, info, log, new_densort, rpr, urge, warn, whisper;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'PIPEDREAMS2/densort';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  TYPES = require('coffeenode-types');

  module.exports = new_densort = function(key, first_idx, report_handler) {
    var buffer, buffer_element, buffer_size, element_count, key_is_function, max_buffer_size, min_legal_idx, previous_idx, send_buffered_elements, sent_count, smallest_idx;
    if (key == null) {
      key = 1;
    }
    if (first_idx == null) {
      first_idx = 0;
    }
    if (report_handler == null) {
      report_handler = null;
    }
    key_is_function = TYPES.isa_function(key);
    buffer = [];

    /* Amount of buffered items: */
    buffer_size = 0;

    /* Index of most recently sent item: */
    previous_idx = first_idx - 1;

    /* Index of first item in buffer: */
    smallest_idx = Infinity;

    /* 'Backlog' of the range of indexes that have already been sent out: */
    min_legal_idx = 0;
    max_buffer_size = 0;
    element_count = 0;
    sent_count = 0;
    buffer_element = (function(_this) {
      return function(idx, element) {
        smallest_idx = Math.min(smallest_idx, idx);
        buffer[idx] = element;
        buffer_size += +1;
        return null;
      };
    })(this);
    send_buffered_elements = (function(_this) {
      return function(handler) {

        /* Refuse to send anything unless all elements with smaller indexes have already been sent: */
        var element, _results;
        if (sent_count < (smallest_idx - first_idx)) {
          return;
        }
        _results = [];
        while (true) {

          /* Terminate loop in case nothing is in the buffer or we have reached an empty position: */
          if (buffer_size < 1 || ((element = buffer[smallest_idx]) == null)) {
            min_legal_idx = smallest_idx;
            break;
          }

          /* Remove element to be sent from buffer (making it a sparse list in most cases), adjust sentinels and
          send element:
           */
          delete buffer[smallest_idx];
          previous_idx = smallest_idx;
          max_buffer_size = Math.max(max_buffer_size, buffer_size);
          smallest_idx += +1;
          buffer_size += -1;
          sent_count += +1;
          _results.push(handler(null, element));
        }
        return _results;
      };
    })(this);
    return (function(_this) {
      return function(element, handler) {
        var idx;
        if (element != null) {
          element_count += +1;
          idx = key_is_function ? key(element) : element[key];
          if (idx < min_legal_idx) {
            return send.error(new Error("duplicate index " + (rpr(idx))));
          }
          if (buffer_size === 0 && idx === previous_idx + 1) {

            /* In case no items are in the buffer and the current index is the one after the previous index, we
            can send on the element immediately:
             */
            previous_idx = idx;
            sent_count += +1;
            return handler(null, element);
          } else {

            /* Otherwise, we put the element into the buffer under its index; should the position in the buffer
            not be vacant, we emit an error. Afterwards, we try to emit as many elements from the buffer as
            possible:
             */
            if (buffer[idx] != null) {
              throw new Error("duplicate index " + (rpr(idx)));
            }
            buffer_element(idx, element);
            return send_buffered_elements(handler);
          }
        } else {

          /* Lastly, let's emit all remaining elements in the buffer; should there be any elements left, we issue
          an error:
           */
          send_buffered_elements(handler);
          if (buffer_size > 0) {
            throw new Error("detected missing elements");
          }
          if (report_handler != null) {
            report_handler([element_count, max_buffer_size]);
          }
          return handler(null, null);
        }
      };
    })(this);
  };

}).call(this);
