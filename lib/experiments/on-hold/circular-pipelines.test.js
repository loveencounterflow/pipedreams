// Generated by CoffeeScript 2.4.1
(function() {
  //###########################################################################################################
  var $, $async, $call_back, $collect_numbers, CND, COLLATZ, FS, OS, PATH, PD, after, alert, assign, badge, copy, debug, declare, defer, echo, help, info, isa, jr, log, new_collatz_pipeline, provide_collatz, rpr, rprx, select, size_of, stamp, test, type_of, types, urge, validate, warn, whisper,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPEDREAMS/TESTS/CIRCULAR-PIPELINES';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  PATH = require('path');

  FS = require('fs');

  OS = require('os');

  test = require('guy-test');

  //...........................................................................................................
  PD = require('../..');

  ({$, $async, select, stamp} = PD);

  //...........................................................................................................
  ({jr, copy, assign} = CND);

  //...........................................................................................................
  after = function(dts, f) {
    return setTimeout(f, dts * 1000);
  };

  defer = setImmediate;

  rprx = function(d) {
    var ref, ref1;
    return `${d.sigil} ${d.key}:: ${jr((ref = d.value) != null ? ref : null)} ${jr((ref1 = d.stamped) != null ? ref1 : false)}`;
  };

  //...........................................................................................................
  types = require('../_types');

  ({isa, validate, declare, size_of, type_of} = types);

  //-----------------------------------------------------------------------------------------------------------
  provide_collatz = function() {
    //-----------------------------------------------------------------------------------------------------------
    this.new_number_datom = function(value, ...other) {
      return PD.new_single_datom('number', {value}, ...other);
    };
    //-----------------------------------------------------------------------------------------------------------
    this.is_one = function(n) {
      return n === 1;
    };
    this.is_odd = function(n) {
      return modulo(n, 2) !== 0;
    };
    this.is_even = function(n) {
      return modulo(n, 2) === 0;
    };
    //-----------------------------------------------------------------------------------------------------------
    this.$odd_numbers = function(S) {
      return $((d, send) => {
        if ((select(d, '^number')) && (!this.is_one(d.value)) && (this.is_odd(d.value))) {
          /* If data datom matches condition, stamp and send it; then, send new data that has been computed
          from the datom: */
          send(stamp(d));
          send(PD.R.recycling(this.new_number_datom(d.value * 3 + 1, {
            from: d.value
          })));
        } else {
          /* If data datom doesn't match condition, just send it on; this will implicitly include
          any `~sync` datoms: */
          send(d);
        }
        return null;
      });
    };
    //-----------------------------------------------------------------------------------------------------------
    this.$even_numbers = function(S) {
      /* Same as `$odd_numbers()`, just simplified, and with a different condition for data selection: */
      return $((d, send) => {
        if (!((select(d, '^number')) && (this.is_even(d.value)))) {
          return send(d);
        }
        send(stamp(d));
        send(PD.R.recycling(this.new_number_datom(d.value / 2, {
          from: d.value
        })));
        return null;
      });
    };
    //-----------------------------------------------------------------------------------------------------------
    this.$skip_known = function(S) {
      var known;
      known = new Set();
      return $((d, send) => {
        if (!select(d, '^number')) {
          return send(d);
        }
        if (known.has(d.value)) {
          return null;
        }
        send(d);
        return known.add(d.value);
      });
    };
    //-----------------------------------------------------------------------------------------------------------
    this.$terminate = function(S) {
      return $((d, send) => {
        if ((select(d, '^number', '#stamped')) && (this.is_one(d.value))) {
          send(stamp(d));
          send(PD.new_end_datom());
        } else {
          send(d);
        }
        return null;
      });
    };
    //-----------------------------------------------------------------------------------------------------------
    this.$throw_on_illegal = function() {
      return PD.$watch(function(d) {
        var type;
        if ((select(d, '^number', '#stamped')) && (type = type_of(d.value)) !== 'number') {
          throw new Error(`found an illegal ${type} in ${rpr(d)}`);
        }
        return null;
      });
    };
    //-----------------------------------------------------------------------------------------------------------
    this.$main = function(S) {
      var pipeline;
      pipeline = [];
      pipeline.push(COLLATZ.$skip_known(S));
      // pipeline.push PD.$delay 0.1
      pipeline.push(COLLATZ.$even_numbers(S));
      pipeline.push(COLLATZ.$odd_numbers(S));
      pipeline.push(COLLATZ.$throw_on_illegal(S));
      // pipeline.push COLLATZ.$terminate            S
      return PD.pull(...pipeline);
    };
    //-----------------------------------------------------------------------------------------------------------
    return this;
  };

  COLLATZ = provide_collatz.apply({});

  //-----------------------------------------------------------------------------------------------------------
  $collect_numbers = function(S) {
    var collector;
    collector = null;
    return $(function(d, send) {
      if (collector == null) {
        collector = [];
      }
      if (select(d, '~collect')) { //, '#stamped'
        send(stamp(d));
        send(PD.new_single_datom('numbers', collector));
        collector = null;
      } else if (select(d, '^number', '#stamped')) {
        collector.push(d.value);
      } else {
        send(d);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  $call_back = function(S, callback) {
    var collector, handler_called;
    collector = null;
    handler_called = false;
    return $({
      last: null
    }, function(d, send) {
      if (d != null) {
        if (select(d, '^numbers')) {
          if (collector == null) {
            collector = [];
          }
          collector.push(d.value);
        } else if (select(d, '~call_back')) {
          handler_called = true;
          callback(collector != null ? collector : []);
          collector = null;
        }
      } else {
        if ((collector != null) || !handler_called) {
          handler_called = true;
          callback(collector != null ? collector : []);
          collector = null;
        }
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  new_collatz_pipeline = function(S, callback) {
    var R, pipeline;
    S.source = PD.new_push_source();
    pipeline = [];
    //.........................................................................................................
    pipeline.push(S.source);
    pipeline.push(PD.R.$unwrap_recycled());
    // pipeline.push PD.$watch ( d ) -> help '37744-4', jr d
    // pipeline.push PD.$delay 0.25
    pipeline.push(PD.$defer());
    pipeline.push(COLLATZ.$main(S));
    pipeline.push(PD.R.$recycle(S.source.send));
    pipeline.push(PD.$show());
    pipeline.push($collect_numbers(S));
    pipeline.push($call_back(S, callback));
    pipeline.push(PD.$drain(function() {
      return help('ok');
    }));
    PD.pull(...pipeline);
    //.........................................................................................................
    R = function(value) {
      if (CND.isa_number(value)) {
        return S.source.send(PD.new_single_datom('number', value));
      } else {
        return S.source.send(value);
      }
    };
    R.end = function() {
      return S.source.end();
    };
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["collatz-conjecture"] = async function(T, done) {
    var S, error, i, len, matcher, probe, probes_and_matchers;
    S = {};
    probes_and_matchers = [[[2, 3, 4, 5, 6, 7, 8, 9, 10], [[2, 1], [3, 10, 5, 16, 8, 4], [], [], [6], [7, 22, 11, 34, 17, 52, 26, 13, 40, 20], [], [9, 28, 14], []]]];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        return new Promise(function(resolve, reject) {
          var callback, j, len1, n, send;
          callback = function(result) {
            help(jr([probe, result]));
            // T.eq result, matcher
            return resolve(result);
          };
          //.......................................................................................................
          send = new_collatz_pipeline(S, callback);
          send(PD.new_datom('[data'));
          for (j = 0, len1 = probe.length; j < len1; j++) {
            n = probe[j];
            (function(n) {
              send(n);
              return send(PD.new_system_datom('collect', null, {
                $: {n}
              }));
            })(n);
          }
          send(PD.new_datom(']data'));
          return send(PD.new_system_datom('call_back'));
        });
      });
    }
    //.........................................................................................................
    done();
    return null;
  };

  //###########################################################################################################
  if (module.parent == null) {
    // test @, { timeout: 30000, }
    test(this["collatz-conjecture"]);
  }

}).call(this);

//# sourceMappingURL=circular-pipelines.test.js.map
