{
  "version": 3,
  "file": "recycle.js",
  "sourceRoot": "../../..",
  "sources": [
    "src/experiments/on-hold/recycle.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'PIPEDREAMS/RECYCLE'\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\ninfo                      = CND.get_logger 'info',      badge\nurge                      = CND.get_logger 'urge',      badge\nhelp                      = CND.get_logger 'help',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\nPD                        = require '..'\n{ $, $async, }            = PD\n{ assign\n  is_empty\n  jr }                    = CND\n\n\n#-----------------------------------------------------------------------------------------------------------\n@new_sync_datom = -> PD.new_system_datom 'sync'\n\n#-----------------------------------------------------------------------------------------------------------\n@$unwrap_recycled = ->\n  ### If the datom is a `~recycle` datom, send its associated `~sync` datom, if any, then its value;\n  otherwise, send the datom itself. ###\n  q1        = [] ### priority queue for recycled datoms       ###\n  q2        = [] ### secondary queue for newly arrived datoms ###\n  waiting   = false\n  # sent_sync = false\n  my_sync   = @new_sync_datom()\n  return $ ( d, send ) =>\n    # urge '77833-1', \"#{d.sigil}#{d.key}:#{jr d.value ? null}\"\n    #.......................................................................................................\n    ### If datom is this circle's sync, send next datom from q2, followed by my sync, and set state to\n    waiting (for the sync to recycle back to here). If there's nothing left in the q2, that means we are\n    done for the time being, and can stop waiting. ###\n    if d is my_sync\n      waiting = false\n      # debug '77833-2', jr { waiting, q1, q2, }\n      unless is_empty q1\n        ### send next recycled datom from the priority queue: ###\n        waiting = true\n        send q1.pop()\n        # debug '77833-3', jr { waiting, q1, q2, }\n        send my_sync\n      else unless is_empty q2\n        ### TAINT must wrap other circles' syncs so they don't get picked up by this circle's transforms ###\n        waiting = true\n        send q2.pop()\n        # debug '77833-4', jr { waiting, q1, q2, }\n        send my_sync\n    #.......................................................................................................\n    ### If datom is recycling, put it into the priority queue to send it right after sync has recycled: ###\n    else if @is_recycling d\n      if waiting\n        q1.unshift d.value\n        # debug '77833-5', jr { waiting, q1, q2, }\n      else\n        send d.value\n        # debug '77833-6', jr { waiting, q1, q2, }\n      # send d.value\n    #.......................................................................................................\n    ### If we're in waiting state, q2 the datom: ###\n    else if waiting\n      q2.unshift d\n      # debug '77833-7', jr { waiting, q1, q2, }\n    #.......................................................................................................\n    else\n      waiting = true\n      # debug '77833-8', jr { waiting, q1, q2, }\n      send d\n      send my_sync\n    return null\n\n#-----------------------------------------------------------------------------------------------------------\n@$recycle = ( resend ) ->\n  ### Stream transform to send datoms either down the pipeline (using `send`) or\n  to an alternate destination, using the `resend` method ( the only argument to\n  this function). Normally, this will be the `send` method of a push source, but\n  it could be any function that accepts a single datom as argument. ###\n  return $ { last: PD._symbols.end, }, ( d, send ) =>\n    return resend PD._symbols.end unless d?\n    if      ( @is_sync      d ) then resend d\n    else if ( @is_recycling d ) then resend d\n    else send d\n    return null\n\n#-----------------------------------------------------------------------------------------------------------\n@recycling = ( d, sync = null ) ->\n  PD.new_system_datom 'recycle', d, if sync? then { sync, } else null\n\n#-----------------------------------------------------------------------------------------------------------\n@is_recycling = ( d ) ->\n  ### Return whether datom is a recycling wrapper datom. ###\n  return ( d.key is '~recycle' )\n\n#-----------------------------------------------------------------------------------------------------------\n@is_recycling_sync = ( d ) ->\n  ### Return whether datom is a sync datom that accompanies a recycling datom. ###\n  return ( d.key is '~sync' ) and ( d.value > 0 )\n\n#-----------------------------------------------------------------------------------------------------------\n@is_sync = ( d ) ->\n  ### Return whether datom is a recycling wrapper datom. ###\n  return ( d.key is '~sync' )\n\n\n\n\n"
  ]
}