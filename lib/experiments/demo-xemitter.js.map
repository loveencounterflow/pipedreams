{
  "version": 3,
  "file": "demo-xemitter.js",
  "sourceRoot": "../..",
  "sources": [
    "src/experiments/demo-xemitter.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'PIPEDREAMS/EXPERIMENTS/XEMITTER'\ndebug                     = CND.get_logger 'debug',     badge\nalert                     = CND.get_logger 'alert',     badge\nwhisper                   = CND.get_logger 'whisper',   badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\ninfo                      = CND.get_logger 'info',      badge\n#...........................................................................................................\nPD                        = require '../..'\njr                        = JSON.stringify\ndefer                     = setImmediate\n{ $\n  $async }                = PD\nXE                        = PD.XE.new_scope()\nother_XE                  = PD.XE.new_scope()\n\n# { emit\n#   delegate\n#   delegate_strict\n#   listen_to_all\n#   listen_to\n#   contract }              = PD.XE\n\n#-----------------------------------------------------------------------------------------------------------\n### Used to make plausible context-binding did work: ###\n@some_method = ->\n\n#-----------------------------------------------------------------------------------------------------------\n### Define a listener for all datoms; when being called, `this` will be set to the first argument (in this\ncase `@`, which here represents the module). Observe you cannot use fat-arrow functions here: ###\nXE.listen_to_all @, ( key, datom ) ->\n  whisper 'µ28823-1', key, datom, ( k for k of @ )\n  return \"listener #1\"\n\n#-----------------------------------------------------------------------------------------------------------\n### Same as above, but the method context is here implicitly defined by the fat-arrow syntax: ###\nXE.listen_to_all ( key, datom ) =>\n  whisper 'µ28823-2', key, datom, ( k for k of @ )\n  return \"listener #2\"\n\n#-----------------------------------------------------------------------------------------------------------\n### Listen to datoms with key `'^something': ###\nXE.listen_to '~something', ( d ) =>\n  whisper 'µ28823-3', d\n  return \"listener #3\"\n\n#-----------------------------------------------------------------------------------------------------------\n### Define a listener for several datom types (a.k.a. 'keys', 'channels')... ###\ncomputation_listener = ( d ) =>\n  urge \"a computation has been requested: #{CND.white d.key}: #{CND.lime jr d.value}\"\n  return \"listener #4\"\n\n#-----------------------------------------------------------------------------------------------------------\n### ...and bind it to two kinds of datoms: ###\nXE.listen_to '^plus-sync',  computation_listener\nXE.listen_to '^plus-async', computation_listener\n# XE.listen_to_once '^plus-async', ( d ) -> debug '37733', d\n\n#-----------------------------------------------------------------------------------------------------------\n### Register a 'contractor' (a.k.a. 'result producer') for `^plus-sync` datoms: ###\nXE.contract '^plus-sync', ( d ) =>\n  return d.value.a + d.value.b\n\n#-----------------------------------------------------------------------------------------------------------\n### Register a 'contractor' (a.k.a. 'result producer') for `^plus-async` datoms; observe that asynchronous\ncontractors should return a promise: ###\nXE.contract '^plus-async', ( d ) =>\n  return new Promise ( resolve, reject ) =>\n    defer => resolve d.value.a + d.value.b\n\n#-----------------------------------------------------------------------------------------------------------\n### Make sure it's ok to yield `null`: ###\nXE.contract '^always-null', ( d ) => null\n\n# #-----------------------------------------------------------------------------------------------------------\n# XE.contract_once '^multiply', ( d ) => debug '26672', d; d.value.a * d.value.b\n\n#-----------------------------------------------------------------------------------------------------------\nother_XE.listen_to_all ( key, d ) =>\n  urge \"other_XE received #{jr d}\"\n\n\n############################################################################################################\ndo =>\n  ### Emit a few datoms to see what happens: ###\n  XE.emit 'foo', { value: 42, }\n  XE.emit PD.new_system_datom 'something', 42\n\n  ### You *must* use `await` to collect any or all results from an datom, *even when the contractor is\n  synchronous*. The return value for emit is a list of all the values produced by all listeners to an datom;\n  in case there is a contractor for an datom, the contractor's result is wrapped in a `~XEMITTER-preferred`\n  datom: ###\n\n  info 'µ28823-4', await XE.emit PD.new_datom '^plus-sync', { a: 42, b: 108, }\n  # -> [ 'listener #4', { key: '~xemitter-preferred', value: 150 }, 'listener #1', 'listener #2' ]\n\n  info 'µ28823-5', await XE.emit PD.new_datom '^plus-async', { a: 42, b: 108, }\n  # -> [ 'listener #4', { key: '~xemitter-preferred', value: 150 }, 'listener #1', 'listener #2' ]\n\n  ### When using `delegate()` instead of `emit()`, the preferred value (a.k.a. '*the* datom result')\n  will be picked out of the list and unwrapped for you: ###\n  info 'µ28823-6', await XE.delegate PD.new_datom '^plus-sync',  { a: 42, b: 108, }\n  info 'µ28823-6', await XE.delegate PD.new_datom '^plus-async', { a: 42, b: 108, }\n  info 'µ28823-6', await XE.delegate PD.new_datom '^always-null'\n  # -> 150\n\n  ### When delegating an datom without a listener, an error will be thrown: ###\n  try\n    info 'µ28823-7', await XE.delegate PD.new_datom '^unknown-datom', 'some value'\n  catch error\n    warn 'µ28823-8', error.message\n    # -> Error: µ83733 no results for '^unknown-datom'\n\n  # info 'µ28823-9', await XE.delegate PD.new_datom '^multiply', { a: 3, b: 4, }\n  # try\n  #   info 'µ28823-10', await XE.delegate PD.new_datom '^multiply', { a: 3, b: 4, }\n  # catch error\n  #   warn error.message\n  #   # -> Error: µ83733 no results for '^unknown-datom'\n\n  ### Emitting on `other_XE` must not send datoms to main `XE`: ###\n  debug 'µ76767', await other_XE.emit PD.new_datom '^datom-on-other-xe', 111\n\n\n\n\n\n"
  ]
}