{
  "version": 3,
  "file": "demo-xemitter.js",
  "sourceRoot": "../..",
  "sources": [
    "src/experiments/demo-xemitter.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'PIPEDREAMS/EXPERIMENTS/XEMITTER'\ndebug                     = CND.get_logger 'debug',     badge\nalert                     = CND.get_logger 'alert',     badge\nwhisper                   = CND.get_logger 'whisper',   badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\ninfo                      = CND.get_logger 'info',      badge\n#...........................................................................................................\nPD \t\t\t\t\t\t\t\t\t\t\t\t= require '../..'\njr \t\t\t\t\t\t\t\t\t\t\t\t= JSON.stringify\ndefer \t\t\t\t\t\t\t\t\t\t= setImmediate\n{ $\n\t$async\n\tXE }\t\t\t\t\t\t\t\t\t\t= PD\n# { emit\n#   delegate\n#   delegate_strict\n#   listen_to_all\n#   listen_to\n#   contract }              = PD.XE\n\n#-----------------------------------------------------------------------------------------------------------\n### Used to make plausible context-binding did work: ###\n@some_method = ->\n\n#-----------------------------------------------------------------------------------------------------------\n### Define a listener for all events; when being called, `this` will be set to the first argument (in this\ncase `@`, which here represents the module). Observe you cannot use fat-arrow functions here: ###\nXE.listen_to_all @, ( key, event ) ->\n\twhisper 'µ28823-1', key, event, ( k for k of @ )\n\treturn \"listener #1\"\n\n#-----------------------------------------------------------------------------------------------------------\n### Same as above, but the method context is here implicitly defined by the fat-arrow syntax: ###\nXE.listen_to_all ( key, event ) =>\n\twhisper 'µ28823-2', key, event, ( k for k of @ )\n\treturn \"listener #2\"\n\n#-----------------------------------------------------------------------------------------------------------\n### Listen to datoms with key `'^something': ###\nXE.listen_to '~something', ( d ) =>\n\twhisper 'µ28823-3', d\n\treturn \"listener #3\"\n\n#-----------------------------------------------------------------------------------------------------------\n### Define a listener for several event types (a.k.a. 'keys', 'channels')... ###\ncomputation_listener = ( d ) =>\n\turge \"a computation has been requested: #{CND.white d.key}: #{CND.lime jr d.value}\"\n\treturn \"listener #4\"\n\n#-----------------------------------------------------------------------------------------------------------\n### ...and bind it to two kinds of events: ###\nXE.listen_to '^plus-sync', \tcomputation_listener\nXE.listen_to '^plus-async', computation_listener\n# XE.listen_to_once '^plus-async', ( d ) -> debug '37733', d\n\n#-----------------------------------------------------------------------------------------------------------\n### Register a 'contractor' (a.k.a. 'result producer') for `^plus-sync` events: ###\nXE.contract '^plus-sync', ( d ) =>\n\treturn d.value.a + d.value.b\n\n#-----------------------------------------------------------------------------------------------------------\n### Register a 'contractor' (a.k.a. 'result producer') for `^plus-async` events; observe that asynchronous\ncontractors should return a promise: ###\nXE.contract '^plus-async', ( d ) =>\n\treturn new Promise ( resolve, reject ) =>\n\t\tdefer => resolve d.value.a + d.value.b\n\n# #-----------------------------------------------------------------------------------------------------------\n# XE.contract_once '^multiply', ( d ) => debug '26672', d; d.value.a * d.value.b\n\n\n############################################################################################################\ndo =>\n\t### Emit a few events to see what happens: ###\n\tXE.emit 'foo', { value: 42, }\n\tXE.emit PD.new_system_event 'something', 42\n\n\t### You *must* use `await` to collect any or all results from an event, *even when the contractor is\n\tsynchronous*. The return value for emit is a list of all the values produced by all listeners to an event;\n\tin case there is a contractor for an event, the contractor's result is wrapped in a `~XEMITTER-preferred`\n\tdatom: ###\n\n\tinfo 'µ28823-4', await XE.emit PD.new_event '^plus-sync', { a: 42, b: 108, }\n\t# -> [ 'listener #4', { key: '~xemitter-preferred', value: 150 }, 'listener #1', 'listener #2' ]\n\n\tinfo 'µ28823-5', await XE.emit PD.new_event '^plus-async', { a: 42, b: 108, }\n\t# -> [ 'listener #4', { key: '~xemitter-preferred', value: 150 }, 'listener #1', 'listener #2' ]\n\n\t### When using `delegate()` instead of `emit()`, the preferred value (a.k.a. '*the* event result')\n\twill be picked out of the list and unwrapped for you: ###\n\tinfo 'µ28823-6', await XE.delegate PD.new_event '^plus-async', { a: 42, b: 108, }\n\t# -> 150\n\n\t### When delegating an event without a listener, an error will be thrown: ###\n\ttry\n\t\tinfo 'µ28823-7', await XE.delegate PD.new_event '^unknown-event', 'some value'\n\tcatch error\n\t\twarn 'µ28823-8', error.message\n\t\t# -> Error: µ83733 no results for '^unknown-event'\n\n\t# info 'µ28823-9', await XE.delegate PD.new_event '^multiply', { a: 3, b: 4, }\n\t# try\n\t# \tinfo 'µ28823-10', await XE.delegate PD.new_event '^multiply', { a: 3, b: 4, }\n\t# catch error\n\t# \twarn error.message\n\t# \t# -> Error: µ83733 no results for '^unknown-event'\n\n"
  ]
}