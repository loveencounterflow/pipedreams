// Generated by CoffeeScript 2.5.1
(function() {
  'use strict';
  var $, $async, CND, FS, L, PATH, PS, alert, assign, badge, copy, debug, echo, help, info, is_empty, jr, log, rpr, rprx, urge, warn, whisper,
    indexOf = [].indexOf;

  //###########################################################################################################
  PATH = require('path');

  FS = require('fs');

  //...........................................................................................................
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS/EXPERIMENTS/RECYCLE';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  PS = require('pipestreams');

  ({$, $async} = PS);

  rprx = function(d) {
    var ref1, ref2;
    return `${d.sigil} ${d.key}:: ${jr((ref1 = d.value) != null ? ref1 : null)} ${jr((ref2 = d.stamped) != null ? ref2 : false)}`;
  };

  //...........................................................................................................
  ({is_empty, copy, assign, jr} = CND);

  /*

  Pipestream Events v2
  ====================

  d         := { sigil,          key, value, ..., $, }    # implicit global namespace
            := { sigil, prefix,  key, value, ..., $, }    # explicit namespace

   * `d.sigil` indicates 'regionality':

  sigil     := '.' # proper singleton
            := '~' # system singleton
            := '(' # start-of-region (SOR)    # '<'
            := ')' # end-of-region   (EOR)    # '>'

   * `prefix` indicates the namespace; where missing on an datom or is `null`, `undefined` or `'global'`,
   * it indicates the global namespace:

  prefix    := null | undefined | 'global' | non-empty text

  key       := non-empty text         # typename

  value     := any                    # payload

  $         := pod                    # system-level attributes, to be copied from old to new datoms

   */
  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.stamp = function(d) {
    /* Set the `stamped` attribute on datom to sigil it as processed. Stamped datoms will not be selected
     by the `select` method, only by the `select_all` method. */
    d.stamped = true;
    return d;
  };

  //===========================================================================================================
  // RECYCLING
  //-----------------------------------------------------------------------------------------------------------
  this.$unwrap_recycled = function() {
    /* If the datom is a `~recycle` datom, send its associated `~sync` datom, if any, then its value;
     otherwise, send the datom itself. */
    var my_sync, q1, q2/* priority queue for recycled datoms       */, waiting/* secondary queue for newly arrived datoms */;
    q1 = [];
    q2 = [];
    waiting = false;
    // sent_sync = false
    my_sync = this.new_sync_datom();
    return $((d, send) => {
      // urge '77833-1', "#{d.sigil}#{d.key}:#{jr d.value ? null}"
      //.......................................................................................................
      /* If datom is this circle's sync, send next datom from q2, followed by my sync, and set state to
         waiting (for the sync to recycle back to here). If there's nothing left in the q2, that means we are
         done for the time being, and can stop waiting. */
      if (d === my_sync) {
        waiting = false;
        // debug '77833-2', jr { waiting, q1, q2, }
        if (!is_empty(q1)) {
          waiting = true;
          send(q1.pop());
          // debug '77833-3', jr { waiting, q1, q2, }
          send(my_sync);
        } else if (!is_empty(q2)) {
          /* TAINT must wrap other circles' syncs so they don't get picked up by this circle's transforms */
          waiting = true;
          send(q2.pop());
          // debug '77833-4', jr { waiting, q1, q2, }
          send(my_sync);
        }
      //.......................................................................................................
      /* If datom is recycling, put it into the priority queue to send it right after sync has recycled: */
      } else if (this.is_recycling(d)) {
        if (waiting) {
          q1.unshift(d.value);
        } else {
          // debug '77833-5', jr { waiting, q1, q2, }
          send(d.value);
        }
      // debug '77833-6', jr { waiting, q1, q2, }
      // send d.value
      //.......................................................................................................
      /* If we're in waiting state, q2 the datom: */
      } else if (waiting) {
        q2.unshift(d);
      } else {
        // debug '77833-7', jr { waiting, q1, q2, }
        //.......................................................................................................
        waiting = true;
        // debug '77833-8', jr { waiting, q1, q2, }
        send(d);
        send(my_sync);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$recycle = function(push) {
    /* Stream transform to send datoms either down the pipeline (using `send`) or
     to an alternate destination, using the `push` method ( the only argument to
     this function). Normally, this will be the `push` method of a push source, but
     it could be any function that accepts a single datom as argument. */
    return $((d, send) => {
      if (this.is_sync(d)) {
        push(d);
      } else if (this.is_recycling(d)) {
        push(d);
      } else {
        send(d);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.recycling = function(d, sync = null) {
    return this.new_system_datom('recycle', d, sync != null ? {sync} : null);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.is_recycling = function(d) {
    /* Return whether datom is a recycling wrapper datom. */
    return (d.sigil === '~') && (d.key === 'recycle');
  };

  //-----------------------------------------------------------------------------------------------------------
  this.is_recycling_sync = function(d) {
    /* Return whether datom is a sync datom that accompanies a recycling datom. */
    return (d.sigil === '~') && (d.key === 'sync') && (d.value > 0);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.is_sync = function(d) {
    /* Return whether datom is a recycling wrapper datom. */
    return (d.sigil === '~') && (d.key === 'sync');
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @new_sync_helpers = ->
  //   ###
  //   ###
  //   buffer = []
  //   #.........................................................................................................
  //   hold = ( d ) =>
  //     return false unless @is_sync d
  //     buffer.push d
  //     return true
  //   #.........................................................................................................
  //   recycle = =>
  //     throw new Error "µ49984 sync buffer empty" if is_empty buffer
  //     R       = buffer.shift()
  //     R.value = ( R.value ? 0 ) + 1
  //     return R
  //   #.........................................................................................................
  //   release = =>
  //     throw new Error "µ49984 sync buffer empty" if is_empty buffer
  //     return buffer.shift()
  //   #.........................................................................................................
  //   return { hold, release, recycle, buffer, }

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.select = function(d, prefix, sigils, keys) {
    var arity;
    if (this.is_stamped(d)) {
      /* Reject all stamped datoms: */
      return false;
    }
    // return false if @is_recycling d
    /* TAINT avoid to test twice for arity */
    switch (arity = arguments.length) {
      case 3:
        return this.select_all(d, prefix, sigils);
      case /* d, sigils, keys */4:
        return this.select_all(d, prefix, sigils, keys);
      default:
        throw new Error(`expected 3 to 4 arguments, got ${arity}`);
    }
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @select_system = ( d, prefix, keys ) ->
  //   ### TAINT avoid to test twice for arity ###
  //   switch arity = arguments.length
  //     when 2 then return @select_all d, prefix, sigils ### d, sigils, keys ###
  //     when 3 then return @select_all d, prefix, sigils, keys
  //     else throw new Error "expected 3 to 4 arguments, got arity"

  //-----------------------------------------------------------------------------------------------------------
  this.select_all = function(d, prefix, sigils, keys) {
    /* accepts 3 or 4 arguments; when 4, then second must be prefix (only one prefix allowed);
     `sigils` and `keys` may be text or list of texts. */
    var _type, arity, ref1, ref2;
    switch (arity = arguments.length) {
      // when 2 then [ prefix, sigils, keys, ] = [ null, prefix, sigils, ]
      case 3:
        [prefix, sigils, keys] = [null, prefix, sigils];
        break;
      case 4:
        null;
        break;
      default:
        throw new Error("expected 3 to 4 arguments, got arity");
    }
    if ((prefix == null) || (prefix === 'global')) {
      //.........................................................................................................
      prefix = null;
    }
    if (sigils == null) {
      sigils = null;
    }
    if (keys == null) {
      keys = null;
    }
    switch (_type = CND.type_of(prefix)) {
      case 'null':
        null;
        break;
      case 'text':
        if (d.prefix !== prefix) {
          return false;
        }
        break;
      default:
        throw new Error(`expected a text or a list, got a ${_type}`);
    }
    switch (_type = CND.type_of(sigils)) {
      case 'null':
        null;
        break;
      case 'text':
        if (d.sigil !== sigils) {
          return false;
        }
        break;
      case 'list':
        if (ref1 = d.sigil, indexOf.call(sigils, ref1) < 0) {
          return false;
        }
        break;
      default:
        throw new Error(`expected a text or a list, got a ${_type}`);
    }
    switch (_type = CND.type_of(keys)) {
      case 'null':
        null;
        break;
      case 'text':
        if (d.key !== keys) {
          return false;
        }
        break;
      case 'list':
        if (ref2 = d.key, indexOf.call(keys, ref2) < 0) {
          return false;
        }
        break;
      default:
        throw new Error(`expected a text or a list, got a ${_type}`);
    }
    return true;
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.is_system = function(d) {
    /* Return whether datom is a system datom (i.e. whether its `sigil` equals `'~'`). */
    return d.sigil === '~';
  };

  //-----------------------------------------------------------------------------------------------------------
  this.is_stamped = function(d) {
    var ref1;
    /* Return whether datom is stamped (i.e. already processed). */
    return (ref1 = d.stamped) != null ? ref1 : false;
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.new_datom = function(sigil, key, value, ...other) {
    var R;
    /* When `other` contains a key `$`, it is treated as a hint to copy
     system-level attributes; if the value of key `$` is a POD that has itself a
     key `$`, then a copy of that value is used. This allows to write `new_datom
     ..., $: d` to copy system-level attributes such as source locations to a new
     datom. */
    if (value != null) {
      R = assign({sigil, key, value}, ...other);
    } else {
      R = assign({sigil, key}, ...other);
    }
    /* TAINT consider to resolve recursively */
    if ((CND.isa_pod(R.$)) && (CND.isa_pod(R.$.$))) {
      R.$ = copy(R.$.$);
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_single_datom = function(key, value, ...other) {
    return this.new_datom('!', key, value, ...other);
  };

  this.new_open_datom = function(key, value, ...other) {
    return this.new_datom('<', key, value, ...other);
  };

  this.new_close_datom = function(key, value, ...other) {
    return this.new_datom('>', key, value, ...other);
  };

  this.new_system_datom = function(key, value, ...other) {
    return this.new_datom('~', key, value, ...other);
  };

  this.new_end_datom = function() {
    return this.new_system_datom('end');
  };

  this.new_sync_datom = function() {
    return this.new_system_datom('sync');
  };

  this.new_flush_datom = function() {
    return this.new_system_datom('flush');
  };

  this.new_text_datom = function(value, ...other) {
    return this.new_single_datom('text', value, ...other);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_warning = function(ref, message, d, ...other) {
    return this.new_system_datom('warning', d, {ref, message}, ...other);
  };

  //###########################################################################################################
  L = this;

  (function() {
    var key, value;
    for (key in L) {
      value = L[key];
      if (!CND.isa_function(value)) {
        continue;
      }
      L[key] = value.bind(L);
    }
    return null;
  })();

}).call(this);

//# sourceMappingURL=recycle.js.map
