// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var $, $async, CND, FS, L, PATH, PS, alert, assign, badge, copy, debug, echo, help, info, is_empty, jr, log, rpr, rprx, urge, warn, whisper,
    indexOf = [].indexOf;

  //###########################################################################################################
  PATH = require('path');

  FS = require('fs');

  //...........................................................................................................
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS/EXPERIMENTS/RECYCLE';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  PS = require('pipestreams');

  ({$, $async} = PS);

  rprx = function(d) {
    var ref1, ref2;
    return `${d.sigil} ${d.key}:: ${jr((ref1 = d.value) != null ? ref1 : null)} ${jr((ref2 = d.stamped) != null ? ref2 : false)}`;
  };

  //...........................................................................................................
  ({is_empty, copy, assign, jr} = CND);

  /*

  Pipestream Events v2
  ====================

  d         := { sigil,          key, value, ..., $, }    # implicit global namespace
            := { sigil, prefix,  key, value, ..., $, }    # explicit namespace

   * `d.sigil` indicates 'regionality':

  sigil     := '.' # proper singleton
            := '~' # system singleton
            := '(' # start-of-region (SOR)    # '<'
            := ')' # end-of-region   (EOR)    # '>'

   * `prefix` indicates the namespace; where missing on an event or is `null`, `undefined` or `'global'`,
   * it indicates the global namespace:

  prefix    := null | undefined | 'global' | non-empty text

  key       := non-empty text         # typename

  value     := any                    # payload

  $         := pod                    # system-level attributes, to be copied from old to new events

   */
  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.stamp = function(d) {
    /* Set the `stamped` attribute on event to sigil it as processed. Stamped events will not be selected
    by the `select` method, only by the `select_all` method. */
    d.stamped = true;
    return d;
  };

  //===========================================================================================================
  // RECYCLING
  //-----------------------------------------------------------------------------------------------------------
  this.$unwrap_recycled = function() {
    /* If the event is a `~recycle` event, send its associated `~sync` event, if any, then its value;
    otherwise, send the event itself. */
    var my_sync, q1, q2/* priority queue for recycled events       */, waiting/* secondary queue for newly arrived events */;
    q1 = [];
    q2 = [];
    waiting = false;
    // sent_sync = false
    my_sync = this.new_sync_event();
    return $((d, send) => {
      // urge '77833-1', "#{d.sigil}#{d.key}:#{jr d.value ? null}"
      //.......................................................................................................
      /* If event is this circle's sync, send next event from q2, followed by my sync, and set state to
      waiting (for the sync to recycle back to here). If there's nothing left in the q2, that means we are
      done for the time being, and can stop waiting. */
      if (d === my_sync) {
        waiting = false;
        // debug '77833-2', jr { waiting, q1, q2, }
        if (!is_empty(q1)) {
          waiting = true;
          send(q1.pop());
          // debug '77833-3', jr { waiting, q1, q2, }
          send(my_sync);
        } else if (!is_empty(q2)) {
          /* TAINT must wrap other circles' syncs so they don't get picked up by this circle's transforms */
          waiting = true;
          send(q2.pop());
          // debug '77833-4', jr { waiting, q1, q2, }
          send(my_sync);
        }
      //.......................................................................................................
      /* If event is recycling, put it into the priority queue to send it right after sync has recycled: */
      } else if (this.is_recycling(d)) {
        if (waiting) {
          q1.unshift(d.value);
        } else {
          // debug '77833-5', jr { waiting, q1, q2, }
          send(d.value);
        }
      // debug '77833-6', jr { waiting, q1, q2, }
      // send d.value
      //.......................................................................................................
      /* If we're in waiting state, q2 the event: */
      } else if (waiting) {
        q2.unshift(d);
      } else {
        // debug '77833-7', jr { waiting, q1, q2, }
        //.......................................................................................................
        waiting = true;
        // debug '77833-8', jr { waiting, q1, q2, }
        send(d);
        send(my_sync);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$recycle = function(push) {
    /* Stream transform to send events either down the pipeline (using `send`) or
    to an alternate destination, using the `push` method ( the only argument to
    this function). Normally, this will be the `push` method of a push source, but
    it could be any function that accepts a single event as argument. */
    return $((d, send) => {
      if (this.is_sync(d)) {
        push(d);
      } else if (this.is_recycling(d)) {
        push(d);
      } else {
        send(d);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.recycling = function(d, sync = null) {
    return this.new_system_event('recycle', d, sync != null ? {sync} : null);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.is_recycling = function(d) {
    /* Return whether event is a recycling wrapper event. */
    return (d.sigil === '~') && (d.key === 'recycle');
  };

  //-----------------------------------------------------------------------------------------------------------
  this.is_recycling_sync = function(d) {
    /* Return whether event is a sync event that accompanies a recycling event. */
    return (d.sigil === '~') && (d.key === 'sync') && (d.value > 0);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.is_sync = function(d) {
    /* Return whether event is a recycling wrapper event. */
    return (d.sigil === '~') && (d.key === 'sync');
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @new_sync_helpers = ->
  //   ###
  //   ###
  //   buffer = []
  //   #.........................................................................................................
  //   hold = ( d ) =>
  //     return false unless @is_sync d
  //     buffer.push d
  //     return true
  //   #.........................................................................................................
  //   recycle = =>
  //     throw new Error "µ49984 sync buffer empty" if is_empty buffer
  //     R       = buffer.shift()
  //     R.value = ( R.value ? 0 ) + 1
  //     return R
  //   #.........................................................................................................
  //   release = =>
  //     throw new Error "µ49984 sync buffer empty" if is_empty buffer
  //     return buffer.shift()
  //   #.........................................................................................................
  //   return { hold, release, recycle, buffer, }

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.select = function(d, prefix, sigils, keys) {
    var arity;
    if (this.is_stamped(d)) {
      /* Reject all stamped events: */
      return false;
    }
    // return false if @is_recycling d
    /* TAINT avoid to test twice for arity */
    switch (arity = arguments.length) {
      case 3:
        return this.select_all(d, prefix, sigils);
      case /* d, sigils, keys */4:
        return this.select_all(d, prefix, sigils, keys);
      default:
        throw new Error(`expected 3 to 4 arguments, got ${arity}`);
    }
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @select_system = ( d, prefix, keys ) ->
  //   ### TAINT avoid to test twice for arity ###
  //   switch arity = arguments.length
  //     when 2 then return @select_all d, prefix, sigils ### d, sigils, keys ###
  //     when 3 then return @select_all d, prefix, sigils, keys
  //     else throw new Error "expected 3 to 4 arguments, got arity"

  //-----------------------------------------------------------------------------------------------------------
  this.select_all = function(d, prefix, sigils, keys) {
    /* accepts 3 or 4 arguments; when 4, then second must be prefix (only one prefix allowed);
    `sigils` and `keys` may be text or list of texts. */
    var _type, arity, ref1, ref2;
    switch (arity = arguments.length) {
      // when 2 then [ prefix, sigils, keys, ] = [ null, prefix, sigils, ]
      case 3:
        [prefix, sigils, keys] = [null, prefix, sigils];
        break;
      case 4:
        null;
        break;
      default:
        throw new Error("expected 3 to 4 arguments, got arity");
    }
    if ((prefix == null) || (prefix === 'global')) {
      //.........................................................................................................
      prefix = null;
    }
    if (sigils == null) {
      sigils = null;
    }
    if (keys == null) {
      keys = null;
    }
    switch (_type = CND.type_of(prefix)) {
      case 'null':
        null;
        break;
      case 'text':
        if (d.prefix !== prefix) {
          return false;
        }
        break;
      default:
        throw new Error(`expected a text or a list, got a ${_type}`);
    }
    switch (_type = CND.type_of(sigils)) {
      case 'null':
        null;
        break;
      case 'text':
        if (d.sigil !== sigils) {
          return false;
        }
        break;
      case 'list':
        if (ref1 = d.sigil, indexOf.call(sigils, ref1) < 0) {
          return false;
        }
        break;
      default:
        throw new Error(`expected a text or a list, got a ${_type}`);
    }
    switch (_type = CND.type_of(keys)) {
      case 'null':
        null;
        break;
      case 'text':
        if (d.key !== keys) {
          return false;
        }
        break;
      case 'list':
        if (ref2 = d.key, indexOf.call(keys, ref2) < 0) {
          return false;
        }
        break;
      default:
        throw new Error(`expected a text or a list, got a ${_type}`);
    }
    return true;
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.is_system = function(d) {
    /* Return whether event is a system event (i.e. whether its `sigil` equals `'~'`). */
    return d.sigil === '~';
  };

  //-----------------------------------------------------------------------------------------------------------
  this.is_stamped = function(d) {
    var ref1;
    /* Return whether event is stamped (i.e. already processed). */
    return (ref1 = d.stamped) != null ? ref1 : false;
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.new_event = function(sigil, key, value, ...other) {
    var R;
    /* When `other` contains a key `$`, it is treated as a hint to copy
    system-level attributes; if the value of key `$` is a POD that has itself a
    key `$`, then a copy of that value is used. This allows to write `new_event
    ..., $: d` to copy system-level attributes such as source locations to a new
    event. */
    if (value != null) {
      R = assign({sigil, key, value}, ...other);
    } else {
      R = assign({sigil, key}, ...other);
    }
    /* TAINT consider to resolve recursively */
    if ((CND.isa_pod(R.$)) && (CND.isa_pod(R.$.$))) {
      R.$ = copy(R.$.$);
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_single_event = function(key, value, ...other) {
    return this.new_event('!', key, value, ...other);
  };

  this.new_open_event = function(key, value, ...other) {
    return this.new_event('<', key, value, ...other);
  };

  this.new_close_event = function(key, value, ...other) {
    return this.new_event('>', key, value, ...other);
  };

  this.new_system_event = function(key, value, ...other) {
    return this.new_event('~', key, value, ...other);
  };

  this.new_end_event = function() {
    return this.new_system_event('end');
  };

  this.new_sync_event = function() {
    return this.new_system_event('sync');
  };

  this.new_flush_event = function() {
    return this.new_system_event('flush');
  };

  this.new_text_event = function(value, ...other) {
    return this.new_single_event('text', value, ...other);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_warning = function(ref, message, d, ...other) {
    return this.new_system_event('warning', d, {ref, message}, ...other);
  };

  //###########################################################################################################
  L = this;

  (function() {
    var key, value;
    for (key in L) {
      value = L[key];
      if (!CND.isa_function(value)) {
        continue;
      }
      L[key] = value.bind(L);
    }
    return null;
  })();

}).call(this);

//# sourceMappingURL=recycle.js.map
