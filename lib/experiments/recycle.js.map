{
  "version": 3,
  "file": "recycle.js",
  "sourceRoot": "../..",
  "sources": [
    "src/experiments/recycle.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n\n############################################################################################################\nPATH                      = require 'path'\nFS                        = require 'fs'\n#...........................................................................................................\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'PIPESTREAMS/EXPERIMENTS/RECYCLE'\nlog                       = CND.get_logger 'plain',     badge\ninfo                      = CND.get_logger 'info',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\nalert                     = CND.get_logger 'alert',     badge\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\nPS                        = require 'pipestreams'\n{ $, $async, }            = PS\nrprx                      = ( d ) -> \"#{d.sigil} #{d.key}:: #{jr d.value ? null} #{jr d.stamped ? false}\"\n#...........................................................................................................\n{ is_empty\n  copy\n  assign\n  jr }                    = CND\n\n\n\n###\n\n\nPipestream Events v2\n====================\n\nd         := { sigil,          key, value, ..., $, }    # implicit global namespace\n          := { sigil, prefix,  key, value, ..., $, }    # explicit namespace\n\n# `d.sigil` indicates 'regionality':\n\nsigil     := '.' # proper singleton\n          := '~' # system singleton\n          := '(' # start-of-region (SOR)    # '<'\n          := ')' # end-of-region   (EOR)    # '>'\n\n# `prefix` indicates the namespace; where missing on an datom or is `null`, `undefined` or `'global'`,\n# it indicates the global namespace:\n\nprefix    := null | undefined | 'global' | non-empty text\n\nkey       := non-empty text         # typename\n\nvalue     := any                    # payload\n\n$         := pod                    # system-level attributes, to be copied from old to new datoms\n\n###\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n@stamp = ( d ) ->\n  ### Set the `stamped` attribute on datom to sigil it as processed. Stamped datoms will not be selected\n  by the `select` method, only by the `select_all` method. ###\n  d.stamped = true\n  return d\n\n\n#===========================================================================================================\n# RECYCLING\n#-----------------------------------------------------------------------------------------------------------\n@$unwrap_recycled = ->\n  ### If the datom is a `~recycle` datom, send its associated `~sync` datom, if any, then its value;\n  otherwise, send the datom itself. ###\n  q1        = [] ### priority queue for recycled datoms       ###\n  q2        = [] ### secondary queue for newly arrived datoms ###\n  waiting   = false\n  # sent_sync = false\n  my_sync   = @new_sync_datom()\n  return $ ( d, send ) =>\n    # urge '77833-1', \"#{d.sigil}#{d.key}:#{jr d.value ? null}\"\n    #.......................................................................................................\n    ### If datom is this circle's sync, send next datom from q2, followed by my sync, and set state to\n    waiting (for the sync to recycle back to here). If there's nothing left in the q2, that means we are\n    done for the time being, and can stop waiting. ###\n    if d is my_sync\n      waiting = false\n      # debug '77833-2', jr { waiting, q1, q2, }\n      unless is_empty q1\n        ### send next recycled datom from the priority queue: ###\n        waiting = true\n        send q1.pop()\n        # debug '77833-3', jr { waiting, q1, q2, }\n        send my_sync\n      else unless is_empty q2\n        ### TAINT must wrap other circles' syncs so they don't get picked up by this circle's transforms ###\n        waiting = true\n        send q2.pop()\n        # debug '77833-4', jr { waiting, q1, q2, }\n        send my_sync\n    #.......................................................................................................\n    ### If datom is recycling, put it into the priority queue to send it right after sync has recycled: ###\n    else if @is_recycling d\n      if waiting\n        q1.unshift d.value\n        # debug '77833-5', jr { waiting, q1, q2, }\n      else\n        send d.value\n        # debug '77833-6', jr { waiting, q1, q2, }\n      # send d.value\n    #.......................................................................................................\n    ### If we're in waiting state, q2 the datom: ###\n    else if waiting\n      q2.unshift d\n      # debug '77833-7', jr { waiting, q1, q2, }\n    #.......................................................................................................\n    else\n      waiting = true\n      # debug '77833-8', jr { waiting, q1, q2, }\n      send d\n      send my_sync\n    return null\n\n#-----------------------------------------------------------------------------------------------------------\n@$recycle = ( push ) ->\n  ### Stream transform to send datoms either down the pipeline (using `send`) or\n  to an alternate destination, using the `push` method ( the only argument to\n  this function). Normally, this will be the `push` method of a push source, but\n  it could be any function that accepts a single datom as argument. ###\n  return $ ( d, send ) =>\n    if      ( @is_sync      d ) then push d\n    else if ( @is_recycling d ) then push d\n    else send d\n    return null\n\n#-----------------------------------------------------------------------------------------------------------\n@recycling = ( d, sync = null ) ->\n  @new_system_datom 'recycle', d, if sync? then { sync, } else null\n\n#-----------------------------------------------------------------------------------------------------------\n@is_recycling = ( d ) ->\n  ### Return whether datom is a recycling wrapper datom. ###\n  return ( d.sigil is '~' ) and ( d.key is 'recycle' )\n\n#-----------------------------------------------------------------------------------------------------------\n@is_recycling_sync = ( d ) ->\n  ### Return whether datom is a sync datom that accompanies a recycling datom. ###\n  return ( d.sigil is '~' ) and ( d.key is 'sync' ) and ( d.value > 0 )\n\n#-----------------------------------------------------------------------------------------------------------\n@is_sync = ( d ) ->\n  ### Return whether datom is a recycling wrapper datom. ###\n  return ( d.sigil is '~' ) and ( d.key is 'sync' )\n\n# #-----------------------------------------------------------------------------------------------------------\n# @new_sync_helpers = ->\n#   ###\n#   ###\n#   buffer = []\n#   #.........................................................................................................\n#   hold = ( d ) =>\n#     return false unless @is_sync d\n#     buffer.push d\n#     return true\n#   #.........................................................................................................\n#   recycle = =>\n#     throw new Error \"µ49984 sync buffer empty\" if is_empty buffer\n#     R       = buffer.shift()\n#     R.value = ( R.value ? 0 ) + 1\n#     return R\n#   #.........................................................................................................\n#   release = =>\n#     throw new Error \"µ49984 sync buffer empty\" if is_empty buffer\n#     return buffer.shift()\n#   #.........................................................................................................\n#   return { hold, release, recycle, buffer, }\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n@select = ( d, prefix, sigils, keys ) ->\n  ### Reject all stamped datoms: ###\n  return false if @is_stamped d\n  # return false if @is_recycling d\n  ### TAINT avoid to test twice for arity ###\n  switch arity = arguments.length\n    when 3 then return @select_all d, prefix, sigils ### d, sigils, keys ###\n    when 4 then return @select_all d, prefix, sigils, keys\n    else throw new Error \"expected 3 to 4 arguments, got #{arity}\"\n\n# #-----------------------------------------------------------------------------------------------------------\n# @select_system = ( d, prefix, keys ) ->\n#   ### TAINT avoid to test twice for arity ###\n#   switch arity = arguments.length\n#     when 2 then return @select_all d, prefix, sigils ### d, sigils, keys ###\n#     when 3 then return @select_all d, prefix, sigils, keys\n#     else throw new Error \"expected 3 to 4 arguments, got arity\"\n\n#-----------------------------------------------------------------------------------------------------------\n@select_all = ( d, prefix, sigils, keys ) ->\n  ### accepts 3 or 4 arguments; when 4, then second must be prefix (only one prefix allowed);\n  `sigils` and `keys` may be text or list of texts. ###\n  switch arity = arguments.length\n    # when 2 then [ prefix, sigils, keys, ] = [ null, prefix, sigils, ]\n    when 3 then [ prefix, sigils, keys, ] = [ null, prefix, sigils, ]\n    when 4 then null\n    else throw new Error \"expected 3 to 4 arguments, got arity\"\n  #.........................................................................................................\n  prefix  = null if ( not prefix? ) or ( prefix is 'global' )\n  sigils  ?= null\n  keys  ?= null\n  switch _type = CND.type_of prefix\n    when 'null' then null\n    when 'text' then return false unless d.prefix is prefix\n    else throw new Error \"expected a text or a list, got a #{_type}\"\n  switch _type = CND.type_of sigils\n    when 'null' then null\n    when 'text' then return false unless d.sigil is sigils\n    when 'list' then return false unless d.sigil in sigils\n    else throw new Error \"expected a text or a list, got a #{_type}\"\n  switch _type = CND.type_of keys\n    when 'null' then null\n    when 'text' then return false unless d.key is keys\n    when 'list' then return false unless d.key in keys\n    else throw new Error \"expected a text or a list, got a #{_type}\"\n  return true\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n@is_system = ( d ) ->\n  ### Return whether datom is a system datom (i.e. whether its `sigil` equals `'~'`). ###\n  return d.sigil is '~'\n\n#-----------------------------------------------------------------------------------------------------------\n@is_stamped = ( d ) ->\n  ### Return whether datom is stamped (i.e. already processed). ###\n  return d.stamped ? false\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n@new_datom = ( sigil, key, value, other... ) ->\n  ### When `other` contains a key `$`, it is treated as a hint to copy\n  system-level attributes; if the value of key `$` is a POD that has itself a\n  key `$`, then a copy of that value is used. This allows to write `new_datom\n  ..., $: d` to copy system-level attributes such as source locations to a new\n  datom. ###\n  if value? then  R = assign { sigil, key, value, }, other...\n  else            R = assign { sigil, key,        }, other...\n  ### TAINT consider to resolve recursively ###\n  if ( CND.isa_pod R.$ ) and ( CND.isa_pod R.$.$ ) then R.$ = copy R.$.$\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@new_single_datom   = ( key, value, other...  ) -> @new_datom '!', key, value, other...\n@new_open_datom     = ( key, value, other...  ) -> @new_datom '<', key, value, other...\n@new_close_datom    = ( key, value, other...  ) -> @new_datom '>', key, value, other...\n@new_system_datom   = ( key, value, other...  ) -> @new_datom '~', key, value, other...\n@new_end_datom      =                           -> @new_system_datom 'end'\n@new_sync_datom     =                           -> @new_system_datom 'sync'\n@new_flush_datom    =                           -> @new_system_datom 'flush'\n@new_text_datom     = (      value, other...  ) -> @new_single_datom 'text',    value, other...\n\n#-----------------------------------------------------------------------------------------------------------\n@new_warning = ( ref, message, d, other...  ) ->\n  @new_system_datom 'warning', d, { ref, message, }, other...\n\n\n############################################################################################################\nL = @\ndo ->\n  for key, value of L\n    continue unless CND.isa_function value\n    L[ key ] = value.bind L\n  return null\n"
  ]
}